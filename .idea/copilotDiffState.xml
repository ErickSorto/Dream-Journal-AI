<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/DrawerController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/DrawerController.kt" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared&#10;&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;&#10;sealed class DrawerCommand {&#10;    data object Open : DrawerCommand()&#10;    data object Close : DrawerCommand()&#10;    data object Toggle : DrawerCommand()&#10;}&#10;&#10;object DrawerController {&#10;    private val _events = Channel&lt;DrawerCommand&gt;(Channel.BUFFERED)&#10;    val events = _events.receiveAsFlow()&#10;&#10;    suspend fun send(command: DrawerCommand) {&#10;        _events.send(command)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_about_me/presentation/AboutMeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_about_me/presentation/AboutMeScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_about_me.presentation&#10;&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.erick_image&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.jetbrains.compose.resources.painterResource&#10;import org.ballistic.dreamjournalai.shared.dream_about_me.presentation.components.DreamAboutMeScreenTopBar&#10;&#10;@Composable&#10;fun AboutMeScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainScreenEvent: (MainScreenEvent) -&gt; Unit,&#10;) {&#10;    val animationDuration = 5000&#10;    val showButton = remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamAboutMeScreenTopBar(mainScreenViewModelState = mainScreenViewModelState)&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .fillMaxSize()&#10;                .navigationBarsPadding(),&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier&#10;                    .verticalScroll(rememberScrollState())&#10;                    .padding(16.dp)&#10;                    .background(&#10;                        shape = RoundedCornerShape(8.dp),&#10;                        brush = Brush.verticalGradient(&#10;                            colors = listOf(&#10;                                DarkBlue.copy(alpha = 0.6f),&#10;                                DarkBlue.copy(alpha = 0.9f),&#10;                                DarkBlue.copy(alpha = 1f),&#10;                            ),&#10;                        )&#10;                    )&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(16.dp, 16.dp, 16.dp, 0.dp)&#10;                        .size(150.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color.Transparent)&#10;                        .shadow(8.dp)&#10;                        .clickable {&#10;                            onMainScreenEvent(MainScreenEvent.OpenStoreLink)&#10;                        }&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(Res.drawable.erick_image),&#10;                        contentDescription = &quot;Erick&quot;,&#10;                        contentScale = ContentScale.Crop,&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                    )&#10;                }&#10;&#10;                Spacer(Modifier.width(16.dp))&#10;&#10;                Box(modifier = Modifier.fillMaxWidth()) {&#10;                    TypewriterText(&#10;                        text = &quot;\&quot;Hi, I'm Erick Sorto, an Android developer who loves creating apps! I spent 6 months developing this app, learning and working hard.&quot; +&#10;                                &quot; Support my passion projects by buying me a burrito, and thank you for your appreciation!\&quot;&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Start,&#10;                        animationDuration = animationDuration,&#10;                        onAnimationComplete = { showButton.value = true }&#10;                    )&#10;                }&#10;            }&#10;&#10;//            AnimatedVisibility(&#10;//                visible = showButton.value,&#10;//                modifier = Modifier&#10;//                    .fillMaxWidth(.8f)&#10;//                    .align(Alignment.BottomCenter)&#10;//                    .padding(bottom = 32.dp),&#10;//            ) {&#10;//                Spacer(Modifier.height(16.dp))&#10;//&#10;//                Button(&#10;//                    modifier = Modifier.padding(16.dp),&#10;//                    shape = RoundedCornerShape(6.dp),&#10;//                    colors = ButtonDefaults.buttonColors(&#10;//                        containerColor = RedOrange&#10;//                    ),&#10;//                    onClick = {&#10;//                        val url = &quot;https://ko-fi.com/ericksorto&quot;&#10;//                        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;//                        openUrlLauncher.launch(intent)&#10;//                    }&#10;//                ) {&#10;//                    Text(&#10;//                        text = &quot;Buy me a burrito!&quot;,&#10;//                        modifier = Modifier.padding(start = 8.dp),&#10;//                        fontSize = 18.sp,&#10;//                        color = Color.White&#10;//                    )&#10;//                    Image(&#10;//                        painter = painterResource(&#10;//                            Res.drawable.burrito_icon&#10;//                        ),&#10;//                        contentDescription = null,&#10;//                        modifier = Modifier.padding(start = 8.dp)&#10;//                    )&#10;//                }&#10;//            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_about_me.presentation&#10;&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.erick_image&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.jetbrains.compose.resources.painterResource&#10;import org.ballistic.dreamjournalai.shared.dream_about_me.presentation.components.DreamAboutMeScreenTopBar&#10;&#10;@Composable&#10;fun AboutMeScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainScreenEvent: (MainScreenEvent) -&gt; Unit,&#10;) {&#10;    val animationDuration = 5000&#10;    val showButton = remember { mutableStateOf(false) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamAboutMeScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainScreenEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .fillMaxSize()&#10;                .navigationBarsPadding(),&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier&#10;                    .verticalScroll(rememberScrollState())&#10;                    .padding(16.dp)&#10;                    .background(&#10;                        shape = RoundedCornerShape(8.dp),&#10;                        brush = Brush.verticalGradient(&#10;                            colors = listOf(&#10;                                DarkBlue.copy(alpha = 0.6f),&#10;                                DarkBlue.copy(alpha = 0.9f),&#10;                                DarkBlue.copy(alpha = 1f),&#10;                            ),&#10;                        )&#10;                    )&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(16.dp, 16.dp, 16.dp, 0.dp)&#10;                        .size(150.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color.Transparent)&#10;                        .shadow(8.dp)&#10;                        .clickable {&#10;                            onMainScreenEvent(MainScreenEvent.OpenStoreLink)&#10;                        }&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(Res.drawable.erick_image),&#10;                        contentDescription = &quot;Erick&quot;,&#10;                        contentScale = ContentScale.Crop,&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                    )&#10;                }&#10;&#10;                Spacer(Modifier.width(16.dp))&#10;&#10;                Box(modifier = Modifier.fillMaxWidth()) {&#10;                    TypewriterText(&#10;                        text = &quot;\&quot;Hi, I'm Erick Sorto, an Android developer who loves creating apps! I spent 6 months developing this app, learning and working hard.&quot; +&#10;                                &quot; Support my passion projects by buying me a burrito, and thank you for your appreciation!\&quot;&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Start,&#10;                        animationDuration = animationDuration,&#10;                        onAnimationComplete = { showButton.value = true }&#10;                    )&#10;                }&#10;            }&#10;&#10;//            AnimatedVisibility(&#10;//                visible = showButton.value,&#10;//                modifier = Modifier&#10;//                    .fillMaxWidth(.8f)&#10;//                    .align(Alignment.BottomCenter)&#10;//                    .padding(bottom = 32.dp),&#10;//            ) {&#10;//                Spacer(Modifier.height(16.dp))&#10;//&#10;//                Button(&#10;//                    modifier = Modifier.padding(16.dp),&#10;//                    shape = RoundedCornerShape(6.dp),&#10;//                    colors = ButtonDefaults.buttonColors(&#10;//                        containerColor = RedOrange&#10;//                    ),&#10;//                    onClick = {&#10;//                        val url = &quot;https://ko-fi.com/ericksorto&quot;&#10;//                        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))&#10;//                        openUrlLauncher.launch(intent)&#10;//                    }&#10;//                ) {&#10;//                    Text(&#10;//                        text = &quot;Buy me a burrito!&quot;,&#10;//                        modifier = Modifier.padding(start = 8.dp),&#10;//                        fontSize = 18.sp,&#10;//                        color = Color.White&#10;//                    )&#10;//                    Image(&#10;//                        painter = painterResource(&#10;//                            Res.drawable.burrito_icon&#10;//                        ),&#10;//                        contentDescription = null,&#10;//                        modifier = Modifier.padding(start = 8.dp)&#10;//                    )&#10;//                }&#10;//            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_about_me/presentation/components/DreamAboutMeScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_about_me/presentation/components/DreamAboutMeScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_about_me.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamAboutMeScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Developer&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_about_me.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamAboutMeScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Developer&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;AboutMe: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_account/AccountSettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_account/AccountSettingsScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_account&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import dev.gitlive.firebase.auth.GoogleAuthProvider as FirebaseGoogleAuthProvider&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_account.components.DreamAccountSettingsScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_account.components.LogoutDeleteLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.AnonymousButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserveLoginState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserverLogoutDeleteState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.SignupLoginLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;&#10;@Composable&#10;fun AccountSettingsScreen(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit = {},&#10;    onSignupEvent: (SignupEvent) -&gt; Unit = {},&#10;    navigateToOnboardingScreen: () -&gt; Unit = {},&#10;    navigateToDreamJournalScreen: () -&gt; Unit = {}&#10;) {&#10;    val isLoading = loginViewModelState.isLoading&#10;    val isUserAnonymous = loginViewModelState.isUserAnonymous&#10;    val isEmailVerified = loginViewModelState.isEmailVerified&#10;    val isUserLoggedIn = loginViewModelState.isLoggedIn&#10;    val animationDisplay = remember { mutableStateOf(false) }&#10;&#10;    // Navigate to Home only when transitioning from not-logged-in to logged-in+verified&#10;    val loggedInAndVerified = isUserLoggedIn &amp;&amp; isEmailVerified &amp;&amp; !isUserAnonymous&#10;    var prevLoggedInAndVerified by remember { mutableStateOf(loggedInAndVerified) }&#10;    LaunchedEffect(loggedInAndVerified) {&#10;        if (!prevLoggedInAndVerified &amp;&amp; loggedInAndVerified) {&#10;            navigateToDreamJournalScreen()&#10;        }&#10;        prevLoggedInAndVerified = loggedInAndVerified&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamAccountSettingsScreenTopBar(mainScreenViewModelState = mainScreenViewModelState)&#10;        },&#10;        snackbarHost = {&#10;            SnackbarHost(hostState = signupViewModelState.snackBarHostState.value)&#10;            SnackbarHost(hostState = loginViewModelState.snackBarHostState.value)&#10;        },&#10;        containerColor = Color.Transparent,&#10;        modifier = Modifier&#10;            .navigationBarsPadding()&#10;            .padding(bottom = 64.dp)&#10;    ) {&#10;        if (loginViewModelState.isEmailVerified &amp;&amp;&#10;            loginViewModelState.isLoggedIn &amp;&amp;&#10;            !loginViewModelState.isUserAnonymous&#10;        ) {&#10;            LogoutDeleteLayout(&#10;                loginViewModelState = loginViewModelState,&#10;                onLoginEvent = onLoginEvent&#10;            )&#10;        } else {&#10;            ObserveLoginState(&#10;                isLoggedIn = isUserLoggedIn,&#10;                isEmailVerified = isEmailVerified,&#10;                isUserAnonymous = isUserAnonymous,&#10;                isUserAnonymousAlready = true,&#10;                navigateToDreamJournalScreen = navigateToDreamJournalScreen,&#10;            )&#10;&#10;            ObserverLogoutDeleteState(&#10;                isLoggedIn = isUserLoggedIn,&#10;                isAnonymous = isUserAnonymous,&#10;                navigateToLoginScreen = navigateToOnboardingScreen&#10;            )&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier&#10;                    .verticalScroll(rememberScrollState())&#10;                    .padding(it)&#10;                    .navigationBarsPadding()&#10;                    .fillMaxSize()&#10;                    .padding(),&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .background(&#10;                            color = LightBlack.copy(alpha = 0.7f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        ),&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Log in to save your dreams! \n&quot; +&#10;                                &quot;You are currently using a guest account.&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                        color = Color.White,&#10;                    )&#10;                }&#10;&#10;                SignupLoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    onLoginEvent = { onLoginEvent(it) },&#10;                    onSignupEvent = { onSignupEvent(it) },&#10;                    onAnimationComplete = {&#10;                        animationDisplay.value = true&#10;                    },&#10;                )&#10;&#10;                MyGoogleSignInButton(&#10;                    { account -&gt;&#10;                        val googleCredential = FirebaseGoogleAuthProvider.credential(&#10;                            idToken = account.idToken,&#10;                            accessToken = account.accessTokenOrNonce&#10;                        )&#10;                        onLoginEvent(LoginEvent.SignInWithGoogle(googleCredential))&#10;                    },&#10;                    {&#10;                        onLoginEvent(LoginEvent.ToggleLoading(false))&#10;                        println(&quot;Google sign-in error: $it&quot;)&#10;                    },&#10;                    isLoading&#10;                )&#10;&#10;                if (!isUserAnonymous) {&#10;                    AnonymousButton(&#10;                        modifier = Modifier&#10;                            .padding(bottom = 8.dp, top = 8.dp, start = 16.dp, end = 16.dp),&#10;                        isVisible = true,&#10;                        onClick = {&#10;                            onLoginEvent(LoginEvent.ToggleLoading(true))&#10;                            onSignupEvent(SignupEvent.AnonymousSignIn)&#10;                        },&#10;                        isEnabled = !isLoading&#10;                    )&#10;                }&#10;&#10;                if (&#10;                    animationDisplay.value&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .background(&#10;                                color = RedOrange.copy(alpha = 0.8f),&#10;                                shape = RoundedCornerShape(16.dp)&#10;                            )&#10;                    ) {&#10;                        TypewriterText(&#10;                            text = &quot;Warning: Guest accounts are deleted after 30 days of inactivity.&quot;,&#10;                            modifier = Modifier.padding(16.dp),&#10;                            textAlign = TextAlign.Center,&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// `MyGoogleSignInButton` is implemented per-platform in androidMain/iosMain (see `GoogleSignInCompose.*`).&#10;// Keep the SignInGoogleButton UI helper here — platform actuals call it.&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_account&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import dev.gitlive.firebase.auth.GoogleAuthProvider as FirebaseGoogleAuthProvider&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_account.components.DreamAccountSettingsScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_account.components.LogoutDeleteLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.AnonymousButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserveLoginState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserverLogoutDeleteState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.SignupLoginLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;&#10;@Composable&#10;fun AccountSettingsScreen(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit = {},&#10;    onSignupEvent: (SignupEvent) -&gt; Unit = {},&#10;    navigateToOnboardingScreen: () -&gt; Unit = {},&#10;    navigateToDreamJournalScreen: () -&gt; Unit = {},&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;    val isLoading = loginViewModelState.isLoading&#10;    val isUserAnonymous = loginViewModelState.isUserAnonymous&#10;    val isEmailVerified = loginViewModelState.isEmailVerified&#10;    val isUserLoggedIn = loginViewModelState.isLoggedIn&#10;    val animationDisplay = remember { mutableStateOf(false) }&#10;&#10;    // Navigate to Home only when transitioning from not-logged-in to logged-in+verified&#10;    val loggedInAndVerified = isUserLoggedIn &amp;&amp; isEmailVerified &amp;&amp; !isUserAnonymous&#10;    var prevLoggedInAndVerified by remember { mutableStateOf(loggedInAndVerified) }&#10;    LaunchedEffect(loggedInAndVerified) {&#10;        if (!prevLoggedInAndVerified &amp;&amp; loggedInAndVerified) {&#10;            navigateToDreamJournalScreen()&#10;        }&#10;        prevLoggedInAndVerified = loggedInAndVerified&#10;    }&#10;&#10;    // Local SnackbarHostState owned by the composable&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;    // Observe global snackbar events and show them here&#10;    ObserveAsEvents(&#10;        flow = SnackbarController.events,&#10;        key1 = snackbarHostState&#10;    ) { event -&gt;&#10;        // show snackbar on UI scope&#10;        scope.launch {&#10;            snackbarHostState.currentSnackbarData?.dismiss()&#10;            val result = snackbarHostState.showSnackbar(&#10;                message = event.message&#10;            )&#10;            if (result == androidx.compose.material3.SnackbarResult.ActionPerformed) {&#10;                event.action?.action?.invoke()&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamAccountSettingsScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        snackbarHost = {&#10;            SnackbarHost(hostState = snackbarHostState)&#10;        },&#10;        containerColor = Color.Transparent,&#10;        modifier = Modifier&#10;            .navigationBarsPadding()&#10;            .padding(bottom = 64.dp)&#10;    ) {&#10;        if (loginViewModelState.isEmailVerified &amp;&amp;&#10;            loginViewModelState.isLoggedIn &amp;&amp;&#10;            !loginViewModelState.isUserAnonymous&#10;        ) {&#10;            LogoutDeleteLayout(&#10;                loginViewModelState = loginViewModelState,&#10;                onLoginEvent = onLoginEvent&#10;            )&#10;        } else {&#10;            ObserveLoginState(&#10;                isLoggedIn = isUserLoggedIn,&#10;                isEmailVerified = isEmailVerified,&#10;                isUserAnonymous = isUserAnonymous,&#10;                isUserAnonymousAlready = true,&#10;                navigateToDreamJournalScreen = navigateToDreamJournalScreen,&#10;            )&#10;&#10;            ObserverLogoutDeleteState(&#10;                isLoggedIn = isUserLoggedIn,&#10;                isAnonymous = isUserAnonymous,&#10;                navigateToLoginScreen = navigateToOnboardingScreen&#10;            )&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier&#10;                    .verticalScroll(rememberScrollState())&#10;                    .padding(it)&#10;                    .navigationBarsPadding()&#10;                    .fillMaxSize()&#10;                    .padding(),&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .background(&#10;                            color = LightBlack.copy(alpha = 0.7f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        ),&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Log in to save your dreams! \n&quot; +&#10;                                &quot;You are currently using a guest account.&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                        color = Color.White,&#10;                    )&#10;                }&#10;&#10;                SignupLoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    onLoginEvent = { onLoginEvent(it) },&#10;                    onSignupEvent = { onSignupEvent(it) },&#10;                    onAnimationComplete = {&#10;                        animationDisplay.value = true&#10;                    },&#10;                )&#10;&#10;                MyGoogleSignInButton(&#10;                    { account -&gt;&#10;                        val googleCredential = FirebaseGoogleAuthProvider.credential(&#10;                            idToken = account.idToken,&#10;                            accessToken = account.accessTokenOrNonce&#10;                        )&#10;                        onLoginEvent(LoginEvent.SignInWithGoogle(googleCredential))&#10;                    },&#10;                    {&#10;                        onLoginEvent(LoginEvent.ToggleLoading(false))&#10;                        println(&quot;Google sign-in error: $it&quot;)&#10;                    },&#10;                    isLoading&#10;                )&#10;&#10;                if (!isUserAnonymous) {&#10;                    AnonymousButton(&#10;                        modifier = Modifier&#10;                            .padding(bottom = 8.dp, top = 8.dp, start = 16.dp, end = 16.dp),&#10;                        isVisible = true,&#10;                        onClick = {&#10;                            onLoginEvent(LoginEvent.ToggleLoading(true))&#10;                            onSignupEvent(SignupEvent.AnonymousSignIn)&#10;                        },&#10;                        isEnabled = !isLoading&#10;                    )&#10;                }&#10;&#10;                if (&#10;                    animationDisplay.value&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .background(&#10;                                color = RedOrange.copy(alpha = 0.8f),&#10;                                shape = RoundedCornerShape(16.dp)&#10;                            )&#10;                    ) {&#10;                        TypewriterText(&#10;                            text = &quot;Warning: Guest accounts are deleted after 30 days of inactivity.&quot;,&#10;                            modifier = Modifier.padding(16.dp),&#10;                            textAlign = TextAlign.Center,&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// `MyGoogleSignInButton` is implemented per-platform in androidMain/iosMain (see `GoogleSignInCompose.*`).&#10;// Keep the SignInGoogleButton UI helper here — platform actuals call it." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_account/components/DreamAccountSettingsScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_account/components/DreamAccountSettingsScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_account.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamAccountSettingsScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Account Settings&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_account.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamAccountSettingsScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Account Settings&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;AccountSettings: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/ForgotPassword.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/ForgotPassword.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;&#10;&#10;@Composable&#10;fun ForgotPassword(&#10;    loginViewModelState: LoginViewModelState,&#10;    navigateBack: () -&gt; Unit,&#10;    showResetPasswordMessage: () -&gt; Unit,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit&#10;) {&#10;    HandleSendPasswordResetEmailResponse(&#10;        loginViewModelState.sendPasswordResetEmailResponse.value,&#10;        navigateBack,&#10;        showResetPasswordMessage,&#10;        showErrorMessage&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun HandleSendPasswordResetEmailResponse(&#10;    sendPasswordResetEmailResponse: Resource&lt;Boolean&gt;,&#10;    navigateBack: () -&gt; Unit,&#10;    showResetPasswordMessage: () -&gt; Unit,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit&#10;) {&#10;    when (sendPasswordResetEmailResponse) {&#10;        is Resource.Loading -&gt; ProgressBar()&#10;        is Resource.Success -&gt; {&#10;            val isPasswordResetEmailSent = sendPasswordResetEmailResponse.data&#10;            LaunchedEffect(isPasswordResetEmailSent) {&#10;                if (isPasswordResetEmailSent == true) {&#10;                    navigateBack()&#10;                    showResetPasswordMessage()&#10;                }&#10;            }&#10;        }&#10;        is Resource.Error -&gt; {&#10;            LaunchedEffect(Unit) {&#10;                println(&quot;Error&quot;)&#10;                showErrorMessage(sendPasswordResetEmailResponse.message)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;&#10;&#10;@Composable&#10;fun ForgotPassword(&#10;    loginViewModelState: LoginViewModelState,&#10;    navigateBack: () -&gt; Unit,&#10;    showResetPasswordMessage: () -&gt; Unit,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit&#10;) {&#10;    HandleSendPasswordResetEmailResponse(&#10;        loginViewModelState.sendPasswordResetEmailResponse,&#10;        navigateBack,&#10;        showResetPasswordMessage,&#10;        showErrorMessage&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun HandleSendPasswordResetEmailResponse(&#10;    sendPasswordResetEmailResponse: Resource&lt;Boolean&gt;,&#10;    navigateBack: () -&gt; Unit,&#10;    showResetPasswordMessage: () -&gt; Unit,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit&#10;) {&#10;    when (sendPasswordResetEmailResponse) {&#10;        is Resource.Loading -&gt; ProgressBar()&#10;        is Resource.Success -&gt; {&#10;            val isPasswordResetEmailSent = sendPasswordResetEmailResponse.data&#10;            LaunchedEffect(isPasswordResetEmailSent) {&#10;                if (isPasswordResetEmailSent == true) {&#10;                    navigateBack()&#10;                    showResetPasswordMessage()&#10;                }&#10;            }&#10;        }&#10;        is Resource.Error -&gt; {&#10;            LaunchedEffect(Unit) {&#10;                println(&quot;Error&quot;)&#10;                showErrorMessage(sendPasswordResetEmailResponse.message)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignIn.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignIn.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.runtime.Composable&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;&#10;@Composable&#10;fun LogIn(&#10;    loginViewModelState: LoginViewModelState,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit,&#10;) {&#10;    when(val signInResponse = loginViewModelState.signInResponse.value) {&#10;        is Resource.Loading&lt;*&gt; -&gt; ProgressBar()&#10;        is Resource.Success&lt;*&gt; -&gt; Unit&#10;        is Resource.Error&lt;*&gt; -&gt; signInResponse.apply {}&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.runtime.Composable&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;&#10;@Composable&#10;fun LogIn(&#10;    loginViewModelState: LoginViewModelState,&#10;    showErrorMessage: (errorMessage: String?) -&gt; Unit,&#10;) {&#10;    when(val signInResponse = loginViewModelState.signInResponse) {&#10;        is Resource.Loading&lt;*&gt; -&gt; ProgressBar()&#10;        is Resource.Success&lt;*&gt; -&gt; Unit&#10;        is Resource.Error&lt;*&gt; -&gt; signInResponse.apply {}&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignUpSignInForgotPasswordLayout.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignUpSignInForgotPasswordLayout.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults.buttonColors&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LighterYellow&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.core.ComposableData&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;&#10;&#10;@Composable&#10;fun SignupLoginTabLayout(loginViewModelState: LoginViewModelState) {&#10;    if (!loginViewModelState.isForgotPasswordLayout.value) {&#10;        Row {&#10;            LoginOrSignupTab(&#10;                text = &quot;Login&quot;,&#10;                isLoginLayout = loginViewModelState.isLoginLayout.value,&#10;                isSignUpLayout = loginViewModelState.isSignUpLayout.value,&#10;                isClicked = {&#10;                    loginViewModelState.isLoginLayout.value = true&#10;                    loginViewModelState.isSignUpLayout.value = false&#10;                },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(end = 4.dp, bottom = 8.dp, start = 16.dp)&#10;            )&#10;            LoginOrSignupTab(&#10;                text = &quot;Signup&quot;,&#10;                isLoginLayout = loginViewModelState.isLoginLayout.value,&#10;                isSignUpLayout = loginViewModelState.isSignUpLayout.value,&#10;                isClicked = {&#10;                    loginViewModelState.isLoginLayout.value = false&#10;                    loginViewModelState.isSignUpLayout.value = true&#10;                },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(start = 4.dp, bottom = 8.dp, end = 16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ForgotPasswordLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    authEvent: (LoginEvent) -&gt; Unit&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            email = loginViewModelState.forgotPasswordEmail,&#10;            onValueChange = {&#10;                authEvent(LoginEvent.EnteredForgotPasswordEmail(it))&#10;            },&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            }&#10;        )&#10;&#10;        Button(&#10;            onClick = {&#10;                authEvent(LoginEvent.SendPasswordResetEmail(loginViewModelState.forgotPasswordEmail))&#10;            },&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            colors = buttonColors(&#10;                containerColor = LighterYellow&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Reset Password&quot;,&#10;                fontSize = 15.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = {&#10;                loginViewModelState.isForgotPasswordLayout.value = false&#10;                loginViewModelState.isLoginLayout.value = true&#10;            },&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            colors = buttonColors(&#10;                containerColor = SkyBlue&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Back to Login&quot;,&#10;                fontSize = 15.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;&#10;    ForgotPassword(&#10;        navigateBack = {&#10;            loginViewModelState.isLoginLayout.value = true&#10;            loginViewModelState.isForgotPasswordLayout.value = false&#10;        },&#10;        showResetPasswordMessage = { /*TODO*/ },&#10;        showErrorMessage = { /*TODO*/ },&#10;        loginViewModelState = loginViewModelState&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SignupLayout(&#10;    signupViewModelState: SignupViewModelState,&#10;    onSignupEvent: (SignupEvent) -&gt; Unit,&#10;) {&#10;    val keyboard = LocalSoftwareKeyboardController.current&#10;&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            email = signupViewModelState.signUpEmail,&#10;            onValueChange = {&#10;                onSignupEvent(SignupEvent.EnteredSignUpEmail(it))&#10;            },&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            }&#10;        )&#10;&#10;        PasswordField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            password = signupViewModelState.signUpPassword,&#10;            onValueChange = { newValue -&gt;&#10;                onSignupEvent(SignupEvent.EnteredSignUpPassword(newValue))&#10;            },&#10;            forgotPassword = { signupViewModelState.isForgotPasswordLayout.value = true },&#10;            isLoginLayout = signupViewModelState.isLoginLayout.value,&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            },&#10;        )&#10;&#10;        Button(&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            onClick = {&#10;                keyboard?.hide()&#10;                onSignupEvent(&#10;                    SignupEvent.SignUpWithEmailAndPassword(&#10;                        signupViewModelState.signUpEmail,&#10;                        signupViewModelState.signUpPassword&#10;                    )&#10;                )&#10;            },&#10;            colors = buttonColors(&#10;                containerColor = SkyBlue&#10;            ),&#10;        ) {&#10;            Text(&#10;                text = &quot;Sign Up&quot;,&#10;                fontSize = 15.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LoginLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit,&#10;    onAnimationComplete: () -&gt; Unit = {}&#10;) {&#10;&#10;    val staggeredDelay = 200L&#10;    val composablesData = listOf(&#10;        ComposableData(key = &quot;Email&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;Password&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;LoginButton&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;SignInGoogleButton&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;AnonymousButton&quot;, visible = remember { mutableStateOf(false) }),&#10;    )&#10;&#10;    LaunchedEffect(key1 = true) {&#10;        for (composableData in composablesData) {&#10;            delay(staggeredDelay)&#10;            composableData.visible.value = true&#10;        }&#10;        onAnimationComplete()&#10;    }&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .padding(horizontal = 16.dp)&#10;                .focusable(),&#10;            email = loginViewModelState.loginEmail,&#10;            onValueChange = {&#10;                onLoginEvent(LoginEvent.EnteredLoginEmail(it))&#10;            },&#10;            isVisible = composablesData.first { it.key == &quot;Email&quot; }.visible&#10;        )&#10;&#10;        PasswordField(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .padding(horizontal = 16.dp)&#10;                .focusable(),&#10;            password = loginViewModelState.loginPassword,&#10;            onValueChange = { newValue -&gt;&#10;                onLoginEvent(LoginEvent.EnteredLoginPassword(newValue))&#10;            },&#10;            forgotPassword = {&#10;                loginViewModelState.isForgotPasswordLayout.value = true&#10;                loginViewModelState.isLoginLayout.value = false&#10;            },&#10;            isLoginLayout = loginViewModelState.isLoginLayout.value,&#10;            isVisible = composablesData.first { it.key == &quot;Password&quot; }.visible&#10;        )&#10;&#10;        LoginButton(&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            loginViewModelState = loginViewModelState,&#10;            onLoginEvent = onLoginEvent,&#10;            isVisible = composablesData.first { it.key == &quot;LoginButton&quot; }.visible,&#10;        )&#10;    }&#10;    LogIn(showErrorMessage = { /*TODO*/ }, loginViewModelState = loginViewModelState)&#10;}&#10;&#10;@Composable&#10;fun LoginOrSignupTab(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    isLoginLayout: Boolean,&#10;    isSignUpLayout: Boolean,&#10;    isClicked: () -&gt; Unit,&#10;) {&#10;    TextButton(&#10;        modifier = modifier&#10;            .background(&#10;                if (isLoginLayout &amp;&amp; text == &quot;Login&quot; || isSignUpLayout &amp;&amp; text == &quot;Signup&quot;) {&#10;                    LightBlack.copy(alpha = 0.7f)&#10;                } else {&#10;                   LightBlack.copy(alpha = 0.1f)&#10;                },&#10;                shape = RoundedCornerShape(8.dp)&#10;            ),&#10;        onClick = { isClicked() },&#10;        shape = RoundedCornerShape(8.dp)&#10;    )&#10;    {&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp,&#10;            color = if (isLoginLayout &amp;&amp; text == &quot;Login&quot; || isSignUpLayout &amp;&amp; text == &quot;Signup&quot;) {&#10;                Color.White&#10;            } else {&#10;                Color.White.copy(alpha = 0.5f)&#10;            },&#10;            fontWeight = FontWeight.Bold,&#10;            maxLines = 1,&#10;            modifier = Modifier.padding(8.dp, 8.dp, 8.dp, 8.dp)&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults.buttonColors&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LighterYellow&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.core.ComposableData&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;&#10;&#10;@Composable&#10;fun SignupLoginTabLayout(loginViewModelState: LoginViewModelState, onLayoutChange: (LoginEvent) -&gt; Unit) {&#10;    if (!loginViewModelState.isForgotPasswordLayout) {&#10;        Row {&#10;            LoginOrSignupTab(&#10;                text = &quot;Login&quot;,&#10;                isLoginLayout = loginViewModelState.isLoginLayout,&#10;                isSignUpLayout = loginViewModelState.isSignUpLayout,&#10;                isClicked = {&#10;                    onLayoutChange(LoginEvent.ShowLoginLayout)&#10;                },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(end = 4.dp, bottom = 8.dp, start = 16.dp)&#10;            )&#10;            LoginOrSignupTab(&#10;                text = &quot;Signup&quot;,&#10;                isLoginLayout = loginViewModelState.isLoginLayout,&#10;                isSignUpLayout = loginViewModelState.isSignUpLayout,&#10;                isClicked = {&#10;                    onLayoutChange(LoginEvent.ShowSignUpLayout)&#10;                },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(start = 4.dp, bottom = 8.dp, end = 16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ForgotPasswordLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    authEvent: (LoginEvent) -&gt; Unit&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            email = loginViewModelState.forgotPasswordEmail,&#10;            onValueChange = {&#10;                authEvent(LoginEvent.EnteredForgotPasswordEmail(it))&#10;            },&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            }&#10;        )&#10;&#10;        Button(&#10;            onClick = {&#10;                authEvent(LoginEvent.SendPasswordResetEmail(loginViewModelState.forgotPasswordEmail))&#10;            },&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            colors = buttonColors(&#10;                containerColor = LighterYellow&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Reset Password&quot;,&#10;                fontSize = 15.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = {&#10;                authEvent(LoginEvent.ShowLoginLayout)&#10;            },&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            colors = buttonColors(&#10;                containerColor = SkyBlue&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Back to Login&quot;,&#10;                fontSize = 15.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;&#10;    ForgotPassword(&#10;        navigateBack = {&#10;            authEvent(LoginEvent.ShowLoginLayout)&#10;        },&#10;        showResetPasswordMessage = { /*TODO*/ },&#10;        showErrorMessage = { /*TODO*/ },&#10;        loginViewModelState = loginViewModelState&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SignupLayout(&#10;    signupViewModelState: SignupViewModelState,&#10;    isLoginLayout: Boolean,&#10;    onSignupEvent: (SignupEvent) -&gt; Unit,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit = {}&#10;) {&#10;    val keyboard = LocalSoftwareKeyboardController.current&#10;&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            email = signupViewModelState.signUpEmail,&#10;            onValueChange = {&#10;                onSignupEvent(SignupEvent.EnteredSignUpEmail(it))&#10;            },&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            }&#10;        )&#10;&#10;        PasswordField(&#10;            modifier = Modifier.padding(horizontal = 16.dp),&#10;            password = signupViewModelState.signUpPassword,&#10;            onValueChange = { newValue -&gt;&#10;                onSignupEvent(SignupEvent.EnteredSignUpPassword(newValue))&#10;            },&#10;            forgotPassword = { onLoginEvent(LoginEvent.ShowForgotPasswordLayout) },&#10;            isLoginLayout = isLoginLayout,&#10;            isVisible = remember {&#10;                mutableStateOf(true)&#10;            },&#10;        )&#10;&#10;        Button(&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            onClick = {&#10;                keyboard?.hide()&#10;                onSignupEvent(&#10;                    SignupEvent.SignUpWithEmailAndPassword(&#10;                        signupViewModelState.signUpEmail,&#10;                        signupViewModelState.signUpPassword&#10;                    )&#10;                )&#10;            },&#10;            colors = buttonColors(&#10;                containerColor = SkyBlue&#10;            ),&#10;        ) {&#10;            Text(&#10;                text = &quot;Sign Up&quot;,&#10;                fontSize = 15.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun LoginLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit,&#10;    onAnimationComplete: () -&gt; Unit = {}&#10;) {&#10;&#10;    val staggeredDelay = 200L&#10;    val composablesData = listOf(&#10;        ComposableData(key = &quot;Email&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;Password&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;LoginButton&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;SignInGoogleButton&quot;, visible = remember { mutableStateOf(false) }),&#10;        ComposableData(key = &quot;AnonymousButton&quot;, visible = remember { mutableStateOf(false) }),&#10;    )&#10;&#10;    LaunchedEffect(key1 = true) {&#10;        for (composableData in composablesData) {&#10;            delay(staggeredDelay)&#10;            composableData.visible.value = true&#10;        }&#10;        onAnimationComplete()&#10;    }&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        EmailField(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .padding(horizontal = 16.dp)&#10;                .focusable(),&#10;            email = loginViewModelState.loginEmail,&#10;            onValueChange = {&#10;                onLoginEvent(LoginEvent.EnteredLoginEmail(it))&#10;            },&#10;            isVisible = composablesData.first { it.key == &quot;Email&quot; }.visible&#10;        )&#10;&#10;        PasswordField(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .padding(horizontal = 16.dp)&#10;                .focusable(),&#10;            password = loginViewModelState.loginPassword,&#10;            onValueChange = { newValue -&gt;&#10;                onLoginEvent(LoginEvent.EnteredLoginPassword(newValue))&#10;            },&#10;            forgotPassword = {&#10;                onLoginEvent(LoginEvent.ShowForgotPasswordLayout)&#10;            },&#10;            isLoginLayout = loginViewModelState.isLoginLayout,&#10;            isVisible = composablesData.first { it.key == &quot;Password&quot; }.visible&#10;        )&#10;&#10;        LoginButton(&#10;            modifier = Modifier.fillMaxWidth(.5f),&#10;            loginViewModelState = loginViewModelState,&#10;            onLoginEvent = onLoginEvent,&#10;            isVisible = composablesData.first { it.key == &quot;LoginButton&quot; }.visible,&#10;        )&#10;    }&#10;    LogIn(showErrorMessage = { /*TODO*/ }, loginViewModelState = loginViewModelState)&#10;}&#10;&#10;@Composable&#10;fun LoginOrSignupTab(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    isLoginLayout: Boolean,&#10;    isSignUpLayout: Boolean,&#10;    isClicked: () -&gt; Unit,&#10;) {&#10;    TextButton(&#10;        modifier = modifier&#10;            .background(&#10;                if (isLoginLayout &amp;&amp; text == &quot;Login&quot; || isSignUpLayout &amp;&amp; text == &quot;Signup&quot;) {&#10;                    LightBlack.copy(alpha = 0.7f)&#10;                } else {&#10;                   LightBlack.copy(alpha = 0.1f)&#10;                },&#10;                shape = RoundedCornerShape(8.dp)&#10;            ),&#10;        onClick = { isClicked() },&#10;        shape = RoundedCornerShape(8.dp)&#10;    )&#10;    {&#10;        Text(&#10;            text = text,&#10;            fontSize = 16.sp,&#10;            color = if (isLoginLayout &amp;&amp; text == &quot;Login&quot; || isSignUpLayout &amp;&amp; text == &quot;Signup&quot;) {&#10;                Color.White&#10;            } else {&#10;                Color.White.copy(alpha = 0.5f)&#10;            },&#10;            fontWeight = FontWeight.Bold,&#10;            maxLines = 1,&#10;            modifier = Modifier.padding(8.dp, 8.dp, 8.dp, 8.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignupLoginLayout.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/components/SignupLoginLayout.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;&#10;@Composable&#10;fun SignupLoginLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit = {},&#10;    onSignupEvent: (SignupEvent) -&gt; Unit = {},&#10;    onAnimationComplete: () -&gt; Unit = {},&#10;) {&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .padding(0.dp, 0.dp, 0.dp, 0.dp)&#10;            .navigationBarsPadding(),&#10;    ) {&#10;&#10;        SignupLoginTabLayout(loginViewModelState = loginViewModelState)&#10;        when {&#10;            loginViewModelState.isLoginLayout.value -&gt; {&#10;                LoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    onLoginEvent = {&#10;                        onLoginEvent(it)&#10;                    },&#10;                    onAnimationComplete = onAnimationComplete&#10;                )&#10;            }&#10;&#10;            loginViewModelState.isForgotPasswordLayout.value -&gt; {&#10;                ForgotPasswordLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                ) {&#10;                    onLoginEvent(it)&#10;                }&#10;            }&#10;&#10;            loginViewModelState.isSignUpLayout.value -&gt; {&#10;                SignupLayout(&#10;                    signupViewModelState = signupViewModelState,&#10;                    onSignupEvent = {&#10;                        onSignupEvent(it)&#10;                    },&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components&#10;&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;&#10;@Composable&#10;fun SignupLoginLayout(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit = {},&#10;    onSignupEvent: (SignupEvent) -&gt; Unit = {},&#10;    onAnimationComplete: () -&gt; Unit = {},&#10;) {&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .padding(0.dp, 0.dp, 0.dp, 0.dp)&#10;            .navigationBarsPadding(),&#10;    ) {&#10;&#10;        SignupLoginTabLayout(loginViewModelState = loginViewModelState, onLayoutChange = onLoginEvent)&#10;        when {&#10;            loginViewModelState.isLoginLayout -&gt; {&#10;                LoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    onLoginEvent = {&#10;                        onLoginEvent(it)&#10;                    },&#10;                    onAnimationComplete = onAnimationComplete&#10;                )&#10;            }&#10;&#10;            loginViewModelState.isForgotPasswordLayout -&gt; {&#10;                ForgotPasswordLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    authEvent = {&#10;                        onLoginEvent(it)&#10;                    }&#10;                )&#10;            }&#10;&#10;            loginViewModelState.isSignUpLayout -&gt; {&#10;                SignupLayout(&#10;                    signupViewModelState = signupViewModelState,&#10;                    isLoginLayout = loginViewModelState.isLoginLayout,&#10;                    onSignupEvent = {&#10;                        onSignupEvent(it)&#10;                    },&#10;                    onLoginEvent = { onLoginEvent(it) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/events/LoginEvent.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/events/LoginEvent.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events&#10;&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;&#10;&#10;sealed class LoginEvent {&#10;    data class SignInWithGoogle(val googleCredential: AuthCredential) : LoginEvent()&#10;    data class LoginWithEmailAndPassword(val email: String, val password: String) : LoginEvent()&#10;    data class SendPasswordResetEmail(val email: String) : LoginEvent()&#10;    data object ReloadUser : LoginEvent()&#10;    data object SignOut : LoginEvent()&#10;    data class RevokeAccess(val password: String?) : LoginEvent()&#10;    data class EnteredLoginEmail(val email: String) : LoginEvent()&#10;    data class EnteredLoginPassword(val password: String) : LoginEvent()&#10;    data class EnteredForgotPasswordEmail(val email: String) : LoginEvent()&#10;    data class ToggleLoading(val isLoading: Boolean) : LoginEvent()&#10;    data object BeginAuthStateListener : LoginEvent()&#10;    data class ReauthAndDelete(val googleCredential: AuthCredential) : LoginEvent()&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events&#10;&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;&#10;&#10;sealed class LoginEvent {&#10;    data class SignInWithGoogle(val googleCredential: AuthCredential) : LoginEvent()&#10;    data class LoginWithEmailAndPassword(val email: String, val password: String) : LoginEvent()&#10;    data class SendPasswordResetEmail(val email: String) : LoginEvent()&#10;    data object ReloadUser : LoginEvent()&#10;    data object SignOut : LoginEvent()&#10;    data class RevokeAccess(val password: String?) : LoginEvent()&#10;    data class EnteredLoginEmail(val email: String) : LoginEvent()&#10;    data class EnteredLoginPassword(val password: String) : LoginEvent()&#10;    data class EnteredForgotPasswordEmail(val email: String) : LoginEvent()&#10;    data class ToggleLoading(val isLoading: Boolean) : LoginEvent()&#10;    data object BeginAuthStateListener : LoginEvent()&#10;    data class ReauthAndDelete(val googleCredential: AuthCredential) : LoginEvent()&#10;&#10;    // Layout control events — composables should emit these to request layout changes&#10;    data object ShowLoginLayout : LoginEvent()&#10;    data object ShowSignUpLayout : LoginEvent()&#10;    data object ShowForgotPasswordLayout : LoginEvent()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/viewmodel/LoginViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/viewmodel/LoginViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel&#10;&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;import dev.gitlive.firebase.auth.AuthResult&#10;import dev.gitlive.firebase.auth.FirebaseUser&#10;import dev.gitlive.firebase.auth.auth&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.ReloadUserResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SendPasswordResetEmailResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SignInResponse&#10;&#10;class LoginViewModel(&#10;    private val repo: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(LoginViewModelState())&#10;    val state: StateFlow&lt;LoginViewModelState&gt; = _state.asStateFlow()&#10;&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        // Initialize some basic state with the current user (if any)&#10;        val user = Firebase.auth.currentUser&#10;        _state.update {&#10;            it.copy(&#10;                isLoggedIn     = user != null,&#10;                isEmailVerified = user?.isEmailVerified == true,&#10;                isUserAnonymous = user?.isAnonymous == true,&#10;                isUserExist     = repo.isUserExist.value&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start observing auth changes. If already started, do nothing.&#10;     */&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) {&#10;            // Already listening, no need to start again&#10;            return&#10;        }&#10;&#10;        authStateJob = viewModelScope.launch {&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                _state.update { currentState -&gt;&#10;                    currentState.copy(&#10;                        isLoggedIn     = user != null,&#10;                        isEmailVerified = user?.isEmailVerified == true,&#10;                        isUserAnonymous = user?.isAnonymous == true,&#10;                        isUserExist     = repo.isUserExist.value&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optional function to stop observing auth changes if needed.&#10;     */&#10;    private fun stopAuthStateListener() {&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;&#10;    fun onEvent(event: LoginEvent) = viewModelScope.launch {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;onEvent received: ${event::class.simpleName}&quot; }&#10;&#10;         when (event) {&#10;            is LoginEvent.SignInWithGoogle -&gt; {&#10;                signInWithGoogle(event.googleCredential)&#10;            }&#10;&#10;            is LoginEvent.LoginWithEmailAndPassword -&gt; {&#10;                loginWithEmailAndPassword(event.email, event.password)&#10;            }&#10;&#10;            is LoginEvent.SendPasswordResetEmail -&gt; {&#10;                sendPasswordResetEmail(event.email)&#10;            }&#10;&#10;            is LoginEvent.EnteredLoginEmail -&gt; {&#10;                _state.update { it.copy(loginEmail = event.email) }&#10;            }&#10;&#10;            is LoginEvent.EnteredLoginPassword -&gt; {&#10;                _state.update { it.copy(loginPassword = event.password) }&#10;            }&#10;&#10;            is LoginEvent.EnteredForgotPasswordEmail -&gt; {&#10;                _state.update { it.copy(forgotPasswordEmail = event.email) }&#10;            }&#10;&#10;            is LoginEvent.ReloadUser -&gt; {&#10;                reloadUser()&#10;            }&#10;&#10;            is LoginEvent.SignOut -&gt; {&#10;                signOut()&#10;            }&#10;&#10;            is LoginEvent.RevokeAccess -&gt; {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;RevokeAccess event passwordProvided=${event.password?.isNotBlank() == true}&quot; }&#10;                revokeAccess(event.password)&#10;            }&#10;&#10;            is LoginEvent.ToggleLoading -&gt; {&#10;                _state.update { it.copy(isLoading = event.isLoading) }&#10;            }&#10;            is LoginEvent.BeginAuthStateListener -&gt; {&#10;                beginAuthStateListener()&#10;            }&#10;&#10;            is LoginEvent.ReauthAndDelete -&gt; {&#10;                reauthWithGoogleAndDelete(event.googleCredential)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    private fun &lt;T&gt; handleResource(&#10;        resourceFlow: Flow&lt;Resource&lt;T&gt;&gt;,&#10;        transform: (T) -&gt; LoginViewModelState,&#10;        errorTransform: (String) -&gt; LoginViewModelState,&#10;        loadingTransform: () -&gt; LoginViewModelState&#10;    ) = resourceFlow.onEach { resource -&gt;&#10;        when (resource) {&#10;            is Resource.Loading -&gt; _state.value = loadingTransform()&#10;            is Resource.Success -&gt; _state.value = resource.data?.let { transform(it) }!!&#10;            is Resource.Error -&gt; _state.value = errorTransform(resource.message ?: &quot;Error&quot;)&#10;        }&#10;    }.launchIn(viewModelScope)&#10;&#10;&#10;&#10;    private suspend fun signInWithGoogle(googleCredential: AuthCredential) {&#10;        Logger.d { &quot;signInWithGoogle() called in LoginViewModel with credential=$googleCredential&quot; }&#10;         handleResource(&#10;             resourceFlow = repo.firebaseSignInWithGoogle(googleCredential),&#10;             transform = {&#10;                Logger.d { &quot;LoginViewModel: firebaseSignInWithGoogle emitted success result, starting transfer/updates&quot; }&#10;                 viewModelScope.launch {&#10;                     try{&#10;                         if (it.second != null &amp;&amp; it.second != &quot;&quot;){&#10;                            Logger.d { &quot;Transferring dreams from anon=${it.second} to new user=${it.first.user?.uid}&quot; }&#10;                             repo.transferDreamsFromAnonymousToPermanent(&#10;                                 it.first.user?.uid ?: &quot;&quot;, it.second ?: &quot;&quot;&#10;                             )&#10;                         }&#10;                     } catch (_: Exception) {&#10;                        Logger.e(&quot;LoginViewModel&quot;) { &quot;transferDreamsFromAnonymousToPermanent failed&quot; }&#10;                     }&#10;                 }&#10;                 // Update the state to reflect the newly-signed in user and stop loading&#10;                 // Immediately update the state so UI observers react without waiting.&#10;                 _state.update { current -&gt;&#10;                     current.copy(&#10;                         user = it.first.user,&#10;                         isEmailVerified = it.first.user?.isEmailVerified ?: false,&#10;                         isLoggedIn = true,&#10;                         isUserAnonymous = it.first.user?.isAnonymous ?: false,&#10;                         isUserExist = it.first.user != null,&#10;                         isLoading = false,&#10;                         signInWithGoogleResponse = MutableStateFlow(Resource.Success(it))&#10;                     )&#10;                 }&#10;&#10;                 // Reload user and ensure auth state listener is active. Do this after the immediate update.&#10;                 viewModelScope.launch {&#10;                     try {&#10;                        Logger.d { &quot;LoginViewModel: reloading firebase user&quot; }&#10;                         repo.reloadFirebaseUser()&#10;                     } catch (_: Exception) {&#10;                        Logger.e(&quot;LoginViewModel&quot;) { &quot;reloadFirebaseUser failed&quot; }&#10;                     }&#10;&#10;                     val refreshedUser = Firebase.auth.currentUser&#10;                     Logger.d { &quot;LoginViewModel: refreshedUser=${refreshedUser?.uid}, isAnonymous=${refreshedUser?.isAnonymous}&quot; }&#10;                     _state.update { current -&gt;&#10;                         current.copy(&#10;                             user = refreshedUser,&#10;                             isEmailVerified = refreshedUser?.isEmailVerified ?: false,&#10;                             isLoggedIn = refreshedUser != null,&#10;                             isUserAnonymous = refreshedUser?.isAnonymous ?: false,&#10;                             isUserExist = repo.isUserExist.value,&#10;                             isLoading = false&#10;                         )&#10;                     }&#10;&#10;                     // Ensure auth state listener is active so other parts of the app see the change&#10;                    beginAuthStateListener()&#10;                 }&#10;&#10;                 // Return the updated state to the handler&#10;                 _state.value&#10;              },&#10;             errorTransform = { error -&gt;&#10;                Logger.e(&quot;LoginViewModel&quot;) { &quot;signInWithGoogle error: $error&quot; }&#10;                 viewModelScope.launch {&#10;                     _state.value.snackBarHostState.value.showSnackbar(&#10;                         error, duration = SnackbarDuration.Long, actionLabel = &quot;Dismiss&quot;&#10;                     )&#10;                 }&#10;                 _state.value.copy(&#10;                     isLoading = false,&#10;                     error = error,&#10;                     signInWithGoogleResponse = MutableStateFlow(Resource.Error(error))&#10;                 )&#10;             },&#10;             loadingTransform = {&#10;                Logger.d { &quot;signInWithGoogle loadingTransform: setting loading=true&quot; }&#10;                 _state.value.copy(&#10;                     isLoading = true,&#10;                     signInWithGoogleResponse = MutableStateFlow(Resource.Loading())&#10;                 )&#10;             }&#10;         )&#10;     }&#10;&#10;&#10;    private suspend fun loginWithEmailAndPassword(email: String, password: String) {&#10;        handleResource(&#10;            resourceFlow = repo.firebaseSignInWithEmailAndPassword(email, password),&#10;            transform = {&#10;                _state.value.copy(&#10;                    isLoggedIn = true,&#10;                    isUserExist = true,&#10;                    isEmailVerified = true&#10;                )&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        error,&#10;                        duration = SnackbarDuration.Long,&#10;                        actionLabel = &quot;dismiss&quot;&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    isLoading = false,&#10;                    error = error&#10;                )&#10;            },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private fun sendPasswordResetEmail(email: String) = viewModelScope.launch {&#10;        _state.value =&#10;            _state.value.copy(sendPasswordResetEmailResponse = mutableStateOf(Resource.Loading()))&#10;        _state.value = _state.value.copy(&#10;            sendPasswordResetEmailResponse = mutableStateOf(&#10;                repo.sendPasswordResetEmail(email)&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun reloadUser() = viewModelScope.launch {&#10;        _state.value = _state.value.copy(reloadUserResponse = mutableStateOf(Resource.Loading()))&#10;        _state.value =&#10;            _state.value.copy(reloadUserResponse = mutableStateOf(Resource.Success(repo.reloadFirebaseUser())))&#10;    }&#10;&#10;    private fun signOut() = viewModelScope.launch {&#10;        repo.signOut()&#10;        _state.value = _state.value.copy(isLoggedIn = false)&#10;    }&#10;&#10;    private suspend fun revokeAccess(password: String?) {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess start passwordProvided=${password?.isNotBlank() == true}&quot; }&#10;        handleResource(&#10;            resourceFlow = repo.revokeAccess(password),&#10;            transform = {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess success -&gt; isRevoked=true, isLoggedIn=false&quot; }&#10;                viewModelScope.launch {&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        message = &quot;Account deleted successfully&quot;,&#10;                        duration = SnackbarDuration.Short&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    revokeAccess = MutableStateFlow(&#10;                        RevokeAccessState(isRevoked = true)&#10;                    ),&#10;                    isLoggedIn = false,&#10;                )&#10;            },&#10;            errorTransform = { error -&gt;&#10;                Logger.withTag(&quot;LoginVM&quot;).e { &quot;revokeAccess error: $error&quot; }&#10;                viewModelScope.launch {&#10;                    val lower = error.lowercase()&#10;                    val needsRecent = listOf(&#10;                        &quot;requires-recent-login&quot;,&#10;                        &quot;recent login&quot;,&#10;                        &quot;requires recent&quot;,&#10;                        &quot;recently&quot;,&#10;                        &quot;reauth&quot;,&#10;                        &quot;sensitive and requires&quot;&#10;                    ).any { lower.contains(it) }&#10;                    val msg = if (needsRecent)&#10;                        &quot;Please sign in again, then try deleting your account.&quot;&#10;                    else error&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        message = msg,&#10;                        duration = SnackbarDuration.Long,&#10;                        actionLabel = &quot;Dismiss&quot;&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    revokeAccess = MutableStateFlow(&#10;                        RevokeAccessState(error = error)&#10;                    )&#10;                )&#10;            },&#10;            loadingTransform = {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess loading&quot; }&#10;                _state.value.copy(&#10;                    revokeAccess = MutableStateFlow(&#10;                        RevokeAccessState(&#10;                            isLoading = true&#10;                        )&#10;                    )&#10;                )&#10;            }&#10;        )&#10;    }&#10;&#10;    private suspend fun reauthWithGoogleAndDelete(googleCredential: AuthCredential) {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthWithGoogleAndDelete start&quot; }&#10;        try {&#10;            // Reauthenticate current user with provided Google credential&#10;            val user = Firebase.auth.currentUser&#10;            if (user == null) {&#10;                Logger.withTag(&quot;LoginVM&quot;).e { &quot;reauthWithGoogleAndDelete: no current user&quot; }&#10;                _state.value.snackBarHostState.value.showSnackbar(&#10;                    message = &quot;No authenticated user&quot;,&#10;                    duration = SnackbarDuration.Short&#10;                )&#10;                return&#10;            }&#10;            Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthenticating with Google credential&quot; }&#10;            user.reauthenticate(googleCredential)&#10;            Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthenticate success, proceeding to delete&quot; }&#10;            revokeAccess(null)&#10;        } catch (e: Exception) {&#10;            Logger.withTag(&quot;LoginVM&quot;).e { &quot;reauthWithGoogleAndDelete error: ${e.message}&quot; }&#10;            _state.value.snackBarHostState.value.showSnackbar(&#10;                message = e.message ?: &quot;Reauthentication failed&quot;,&#10;                duration = SnackbarDuration.Long,&#10;                actionLabel = &quot;Dismiss&quot;&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class LoginViewModelState(&#10;    val loginEmail: String = &quot;&quot;,&#10;    val loginPassword: String = &quot;&quot;,&#10;    val forgotPasswordEmail: String = &quot;&quot;,&#10;    val signInWithGoogleResponse: MutableStateFlow&lt;Resource&lt;Pair&lt;AuthResult, String?&gt;&gt;&gt; = MutableStateFlow(&#10;        Resource.Loading()&#10;    ),&#10;    val isLoginLayout: MutableState&lt;Boolean&gt; = mutableStateOf(true),&#10;    val isSignUpLayout: MutableState&lt;Boolean&gt; = mutableStateOf(false),&#10;    val isForgotPasswordLayout: MutableState&lt;Boolean&gt; = mutableStateOf(false),&#10;    val signInResponse: MutableState&lt;Resource&lt;SignInResponse&gt;&gt; = mutableStateOf(Resource.Success()),&#10;    val sendPasswordResetEmailResponse: MutableState&lt;SendPasswordResetEmailResponse&gt; = mutableStateOf(&#10;        Resource.Success()&#10;    ),&#10;    val reloadUserResponse: MutableState&lt;Resource&lt;ReloadUserResponse&gt;&gt; = mutableStateOf(Resource.Success()),&#10;    val revokeAccess: StateFlow&lt;RevokeAccessState&gt; = MutableStateFlow(RevokeAccessState()),&#10;    val user: FirebaseUser? = null,&#10;    val isUserExist: Boolean = false,&#10;    val isEmailVerified: Boolean = false,&#10;    val isLoggedIn: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;,&#10;    val isUserAnonymous: Boolean = false,&#10;    val snackBarHostState: MutableState&lt;SnackbarHostState&gt; = mutableStateOf(SnackbarHostState()),&#10;)&#10;&#10;data class RevokeAccessState(&#10;    val isRevoked: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;&#10;)&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel&#10;&#10;import androidx.compose.runtime.Immutable&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;import dev.gitlive.firebase.auth.auth&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.ReloadUserResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SendPasswordResetEmailResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SignInResponse&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;&#10;class LoginViewModel(&#10;    private val repo: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(LoginViewModelState())&#10;    val state: StateFlow&lt;LoginViewModelState&gt; = _state.asStateFlow()&#10;&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        // Initialize some basic state with the current user (if any)&#10;        val user = Firebase.auth.currentUser&#10;        _state.update {&#10;            it.copy(&#10;                isLoggedIn     = user != null,&#10;                isEmailVerified = user?.isEmailVerified == true,&#10;                isUserAnonymous = user?.isAnonymous == true,&#10;                isUserExist     = repo.isUserExist.value&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start observing auth changes. If already started, do nothing.&#10;     */&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) {&#10;            // Already listening, no need to start again&#10;            return&#10;        }&#10;&#10;        authStateJob = viewModelScope.launch {&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                _state.update { currentState -&gt;&#10;                    currentState.copy(&#10;                        isLoggedIn     = user != null,&#10;                        isEmailVerified = user?.isEmailVerified == true,&#10;                        isUserAnonymous = user?.isAnonymous == true,&#10;                        isUserExist     = repo.isUserExist.value&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optional function to stop observing auth changes if needed.&#10;     */&#10;    private fun stopAuthStateListener() {&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;&#10;    fun onEvent(event: LoginEvent) = viewModelScope.launch {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;onEvent received: ${event::class.simpleName}&quot; }&#10;&#10;         when (event) {&#10;            is LoginEvent.SignInWithGoogle -&gt; {&#10;                signInWithGoogle(event.googleCredential)&#10;            }&#10;&#10;            is LoginEvent.LoginWithEmailAndPassword -&gt; {&#10;                loginWithEmailAndPassword(event.email, event.password)&#10;            }&#10;&#10;            is LoginEvent.SendPasswordResetEmail -&gt; {&#10;                sendPasswordResetEmail(event.email)&#10;            }&#10;&#10;            is LoginEvent.EnteredLoginEmail -&gt; {&#10;                _state.update { it.copy(loginEmail = event.email) }&#10;            }&#10;&#10;            is LoginEvent.EnteredLoginPassword -&gt; {&#10;                _state.update { it.copy(loginPassword = event.password) }&#10;            }&#10;&#10;            is LoginEvent.EnteredForgotPasswordEmail -&gt; {&#10;                _state.update { it.copy(forgotPasswordEmail = event.email) }&#10;            }&#10;&#10;            is LoginEvent.ReloadUser -&gt; {&#10;                reloadUser()&#10;            }&#10;&#10;            is LoginEvent.SignOut -&gt; {&#10;                signOut()&#10;            }&#10;&#10;            is LoginEvent.RevokeAccess -&gt; {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;RevokeAccess event passwordProvided=${event.password?.isNotBlank() == true}&quot; }&#10;                revokeAccess(event.password)&#10;            }&#10;&#10;            is LoginEvent.ToggleLoading -&gt; {&#10;                _state.update { it.copy(isLoading = event.isLoading) }&#10;            }&#10;            is LoginEvent.BeginAuthStateListener -&gt; {&#10;                beginAuthStateListener()&#10;            }&#10;&#10;            is LoginEvent.ReauthAndDelete -&gt; {&#10;                reauthWithGoogleAndDelete(event.googleCredential)&#10;            }&#10;&#10;            // handle layout control events by updating plain boolean flags&#10;            is LoginEvent.ShowLoginLayout -&gt; {&#10;                _state.update { it.copy(isLoginLayout = true, isSignUpLayout = false, isForgotPasswordLayout = false) }&#10;            }&#10;            is LoginEvent.ShowSignUpLayout -&gt; {&#10;                _state.update { it.copy(isLoginLayout = false, isSignUpLayout = true, isForgotPasswordLayout = false) }&#10;            }&#10;            is LoginEvent.ShowForgotPasswordLayout -&gt; {&#10;                _state.update { it.copy(isLoginLayout = false, isSignUpLayout = false, isForgotPasswordLayout = true) }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    private fun &lt;T&gt; handleResource(&#10;        resourceFlow: Flow&lt;Resource&lt;T&gt;&gt;,&#10;        transform: (T) -&gt; LoginViewModelState,&#10;        errorTransform: (String) -&gt; LoginViewModelState,&#10;        loadingTransform: () -&gt; LoginViewModelState&#10;    ) = resourceFlow.onEach { resource -&gt;&#10;        when (resource) {&#10;            is Resource.Loading -&gt; _state.value = loadingTransform()&#10;            is Resource.Success -&gt; _state.value = resource.data?.let { transform(it) }!!&#10;            is Resource.Error -&gt; _state.value = errorTransform(resource.message ?: &quot;Error&quot;)&#10;        }&#10;    }.launchIn(viewModelScope)&#10;&#10;&#10;&#10;    private suspend fun signInWithGoogle(googleCredential: AuthCredential) {&#10;        Logger.d { &quot;signInWithGoogle() called in LoginViewModel with credential=$googleCredential&quot; }&#10;         handleResource(&#10;             resourceFlow = repo.firebaseSignInWithGoogle(googleCredential),&#10;             transform = {&#10;                Logger.d { &quot;LoginViewModel: firebaseSignInWithGoogle emitted success result, starting transfer/updates&quot; }&#10;                 viewModelScope.launch {&#10;                     try{&#10;                         if (it.second != null &amp;&amp; it.second != &quot;&quot;){&#10;                            Logger.d { &quot;Transferring dreams from anon=${it.second} to new user=${it.first.user?.uid}&quot; }&#10;                             repo.transferDreamsFromAnonymousToPermanent(&#10;                                 it.first.user?.uid ?: &quot;&quot;, it.second ?: &quot;&quot;&#10;                             )&#10;                         }&#10;                     } catch (_: Exception) {&#10;                        Logger.e(&quot;LoginViewModel&quot;) { &quot;transferDreamsFromAnonymousToPermanent failed&quot; }&#10;                     }&#10;                 }&#10;                 // Update the state to reflect the newly-signed in user and stop loading&#10;                 // Immediately update the state so UI observers react without waiting.&#10;                 _state.update { current -&gt;&#10;                     current.copy(&#10;                         user = it.first.user?.let { u -&gt;&#10;                             UserUi(&#10;                                 uid = u.uid,&#10;                                 displayName = u.displayName,&#10;                                 email = u.email,&#10;                                 isAnonymous = u.isAnonymous,&#10;                                 photoUrl = null&#10;                             )&#10;                         },&#10;                         isEmailVerified = it.first.user?.isEmailVerified ?: false,&#10;                         isLoggedIn = true,&#10;                         isUserAnonymous = it.first.user?.isAnonymous ?: false,&#10;                         isUserExist = it.first.user != null,&#10;                         isLoading = false,&#10;                         signInWithGoogleResponse = SignInUiState.Success(&#10;                             SignInResultUi(&#10;                                 userId = it.first.user?.uid,&#10;                                 previousAnonymousId = it.second&#10;                             )&#10;                         )&#10;                     )&#10;                 }&#10;&#10;                 // Reload user and ensure auth state listener is active. Do this after the immediate update.&#10;                 viewModelScope.launch {&#10;                     try {&#10;                        Logger.d { &quot;LoginViewModel: reloading firebase user&quot; }&#10;                         repo.reloadFirebaseUser()&#10;                     } catch (_: Exception) {&#10;                        Logger.e(&quot;LoginViewModel&quot;) { &quot;reloadFirebaseUser failed&quot; }&#10;                     }&#10;&#10;                     val refreshedUser = Firebase.auth.currentUser&#10;                        Logger.d { &quot;LoginViewModel: refreshedUser=${refreshedUser?.uid}, isAnonymous=${refreshedUser?.isAnonymous}&quot; }&#10;                     _state.update { current -&gt;&#10;                         current.copy(&#10;                             user = refreshedUser?.let { u -&gt;&#10;                                 UserUi(&#10;                                     uid = u.uid,&#10;                                     displayName = u.displayName,&#10;                                     email = u.email,&#10;                                     isAnonymous = u.isAnonymous,&#10;                                     photoUrl = null&#10;                                 )&#10;                             },&#10;                             isEmailVerified = refreshedUser?.isEmailVerified ?: false,&#10;                             isLoggedIn = refreshedUser != null,&#10;                             isUserAnonymous = refreshedUser?.isAnonymous ?: false,&#10;                             isUserExist = repo.isUserExist.value,&#10;                             isLoading = false&#10;                         )&#10;                     }&#10;&#10;                     // Ensure auth state listener is active so other parts of the app see the change&#10;                    beginAuthStateListener()&#10;                 }&#10;&#10;                 // Return the updated state to the handler&#10;                 _state.value&#10;              },&#10;             errorTransform = { error -&gt;&#10;                Logger.e(&quot;LoginViewModel&quot;) { &quot;signInWithGoogle error: $error&quot; }&#10;                 viewModelScope.launch {&#10;                     SnackbarController.sendEvent(&#10;                         SnackbarEvent(&#10;                             error,&#10;                             SnackbarAction(&quot;Dismiss&quot;) { }&#10;                         )&#10;                     )&#10;                 }&#10;                 _state.value.copy(&#10;                     isLoading = false,&#10;                     error = error,&#10;                     signInWithGoogleResponse = SignInUiState.Error(error)&#10;                 )&#10;             },&#10;             loadingTransform = {&#10;                Logger.d { &quot;signInWithGoogle loadingTransform: setting loading=true&quot; }&#10;                 _state.value.copy(&#10;                     isLoading = true,&#10;                     signInWithGoogleResponse = SignInUiState.Loading&#10;                 )&#10;             }&#10;         )&#10;     }&#10;&#10;&#10;    private suspend fun loginWithEmailAndPassword(email: String, password: String) {&#10;        handleResource(&#10;            resourceFlow = repo.firebaseSignInWithEmailAndPassword(email, password),&#10;            transform = {&#10;                _state.value.copy(&#10;                    isLoggedIn = true,&#10;                    isUserExist = true,&#10;                    isEmailVerified = true&#10;                )&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            error,&#10;                            SnackbarAction(&quot;dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    isLoading = false,&#10;                    error = error&#10;                )&#10;            },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private fun sendPasswordResetEmail(email: String) = viewModelScope.launch {&#10;        _state.value = _state.value.copy(sendPasswordResetEmailResponse = Resource.Loading())&#10;        _state.value = _state.value.copy(&#10;            sendPasswordResetEmailResponse = repo.sendPasswordResetEmail(email)&#10;        )&#10;    }&#10;&#10;    private fun reloadUser() = viewModelScope.launch {&#10;        _state.value = _state.value.copy(reloadUserResponse = Resource.Loading())&#10;        _state.value =&#10;            _state.value.copy(reloadUserResponse = Resource.Success(repo.reloadFirebaseUser()))&#10;    }&#10;&#10;    private fun signOut() = viewModelScope.launch {&#10;        repo.signOut()&#10;        _state.value = _state.value.copy(isLoggedIn = false)&#10;    }&#10;&#10;    private suspend fun revokeAccess(password: String?) {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess start passwordProvided=${password?.isNotBlank() == true}&quot; }&#10;        handleResource(&#10;            resourceFlow = repo.revokeAccess(password),&#10;            transform = {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess success -&gt; isRevoked=true, isLoggedIn=false&quot; }&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Account deleted successfully&quot;,&#10;                            action = null&#10;                        )&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    revokeAccess = RevokeAccessState(isRevoked = true),&#10;                    isLoggedIn = false,&#10;                )&#10;            },&#10;            errorTransform = { error -&gt;&#10;                Logger.withTag(&quot;LoginVM&quot;).e { &quot;revokeAccess error: $error&quot; }&#10;                viewModelScope.launch {&#10;                    val lower = error.lowercase()&#10;                    val needsRecent = listOf(&#10;                        &quot;requires-recent-login&quot;,&#10;                        &quot;recent login&quot;,&#10;                        &quot;requires recent&quot;,&#10;                        &quot;recently&quot;,&#10;                        &quot;reauth&quot;,&#10;                        &quot;sensitive and requires&quot;&#10;                    ).any { lower.contains(it) }&#10;                    val msg = if (needsRecent)&#10;                        &quot;Please sign in again, then try deleting your account.&quot;&#10;                    else error&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = msg,&#10;                            action = SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    revokeAccess = RevokeAccessState(error = error)&#10;                )&#10;            },&#10;            loadingTransform = {&#10;                Logger.withTag(&quot;LoginVM&quot;).d { &quot;revokeAccess loading&quot; }&#10;                _state.value.copy(&#10;                    revokeAccess = RevokeAccessState(isLoading = true)&#10;                )&#10;            }&#10;        )&#10;    }&#10;&#10;    private suspend fun reauthWithGoogleAndDelete(googleCredential: AuthCredential) {&#10;        Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthWithGoogleAndDelete start&quot; }&#10;        try {&#10;            // Reauthenticate current user with provided Google credential&#10;            val user = Firebase.auth.currentUser&#10;            if (user == null) {&#10;                Logger.withTag(&quot;LoginVM&quot;).e { &quot;reauthWithGoogleAndDelete: no current user&quot; }&#10;                SnackbarController.sendEvent(&#10;                    SnackbarEvent(&#10;                        message = &quot;No authenticated user&quot;,&#10;                        action = null&#10;                    )&#10;                )&#10;                return&#10;            }&#10;            Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthenticating with Google credential&quot; }&#10;            user.reauthenticate(googleCredential)&#10;            Logger.withTag(&quot;LoginVM&quot;).d { &quot;reauthenticate success, proceeding to delete&quot; }&#10;            revokeAccess(null)&#10;        } catch (e: Exception) {&#10;            Logger.withTag(&quot;LoginVM&quot;).e { &quot;reauthWithGoogleAndDelete error: ${e.message}&quot; }&#10;            SnackbarController.sendEvent(&#10;                SnackbarEvent(&#10;                    message = e.message ?: &quot;Reauthentication failed&quot;,&#10;                    action = SnackbarAction(&quot;Dismiss&quot;) { }&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class LoginViewModelState(&#10;     val loginEmail: String = &quot;&quot;,&#10;     val loginPassword: String = &quot;&quot;,&#10;     val forgotPasswordEmail: String = &quot;&quot;,&#10;     val signInWithGoogleResponse: SignInUiState = SignInUiState.Loading,&#10;    // Layout flags replaced with stable booleans&#10;    val isLoginLayout: Boolean = true,&#10;    val isSignUpLayout: Boolean = false,&#10;    val isForgotPasswordLayout: Boolean = false,&#10;    val signInResponse: Resource&lt;SignInResponse&gt; = Resource.Success(),&#10;    val sendPasswordResetEmailResponse: SendPasswordResetEmailResponse = Resource.Success(),&#10;    val reloadUserResponse: Resource&lt;ReloadUserResponse&gt; = Resource.Success(),&#10;    val revokeAccess: RevokeAccessState = RevokeAccessState(),&#10;    val user: UserUi? = null,&#10;    val isUserExist: Boolean = false,&#10;    val isEmailVerified: Boolean = false,&#10;    val isLoggedIn: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;,&#10;    val isUserAnonymous: Boolean = false,&#10; )&#10;&#10;data class RevokeAccessState(&#10;     val isRevoked: Boolean = false,&#10;     val isLoading: Boolean = false,&#10;     val error: String = &quot;&quot;&#10; )&#10; &#10;@Immutable&#10;data class UserUi(&#10;    val uid: String?,&#10;    val displayName: String? = null,&#10;    val email: String? = null,&#10;    val isAnonymous: Boolean = false,&#10;    val photoUrl: String? = null,&#10;)&#10;&#10;@Immutable&#10;data class SignInResultUi(&#10;    val userId: String?,&#10;    val previousAnonymousId: String?&#10;)&#10;&#10;// Concrete, non-generic UI state for the sign-in-with-Google flow.&#10;// Using a concrete sealed type avoids Compose runtime stability checks that happen for generic type parameters.&#10;@Immutable&#10;sealed class SignInUiState {&#10;    @Immutable&#10;    object Loading : SignInUiState()&#10;&#10;    @Immutable&#10;    data class Success(val result: SignInResultUi) : SignInUiState()&#10;&#10;    @Immutable&#10;    data class Error(val message: String) : SignInUiState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/viewmodel/SignupViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/presentation/signup_screen/viewmodel/SignupViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel&#10;&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SignUpResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;&#10;class SignupViewModel(&#10;    private val repo: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(SignupViewModelState())&#10;    val state: StateFlow&lt;SignupViewModelState&gt; = _state.asStateFlow()&#10;&#10;    fun onEvent(event: SignupEvent) = viewModelScope.launch {&#10;        when (event) {&#10;            is SignupEvent.SignUpWithEmailAndPassword -&gt; {&#10;                signUpWithEmailAndPassword(event.email, event.password)&#10;            }&#10;&#10;            is SignupEvent.AnonymousSignIn -&gt; {&#10;                anonymousSignIn()&#10;            }&#10;&#10;            is SignupEvent.EnteredSignUpEmail -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    signUpEmail = event.email&#10;                )&#10;            }&#10;&#10;            is SignupEvent.EnteredSignUpPassword -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    signUpPassword = event.password&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun &lt;T&gt; handleResource(&#10;        resourceFlow: Flow&lt;Resource&lt;T&gt;&gt;,&#10;        transform: (T) -&gt; Job,&#10;        errorTransform: (String) -&gt; SignupViewModelState,&#10;        loadingTransform: () -&gt; SignupViewModelState&#10;    ) = resourceFlow.onEach { resource -&gt;&#10;        when (resource) {&#10;            is Resource.Loading -&gt; _state.value = loadingTransform()&#10;            is Resource.Success -&gt; resource.data?.let { transform(it) }&#10;            is Resource.Error -&gt; _state.value = errorTransform(resource.message ?: &quot;Error&quot;)&#10;        }&#10;    }.launchIn(viewModelScope)&#10;&#10;    private suspend fun signUpWithEmailAndPassword(email: String, password: String) {&#10;        if (!checkSignUpFields()) return&#10;        handleResource(&#10;            resourceFlow = repo.firebaseSignUpWithEmailAndPassword(email, password),&#10;            transform = { result -&gt;&#10;                viewModelScope.launch {&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        result,&#10;                        duration = SnackbarDuration.Long,&#10;                        actionLabel = &quot;dismiss&quot;&#10;                    )&#10;                }&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        error,&#10;                        duration = SnackbarDuration.Short,&#10;                        actionLabel = &quot;dismiss&quot;&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    error = error,&#10;                )&#10;            },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private suspend fun anonymousSignIn() {&#10;        handleResource(&#10;            resourceFlow = repo.anonymousSignIn(),&#10;            transform = { authResult -&gt;&#10;                viewModelScope.launch {&#10;                    _state.update {&#10;                        it.copy(&#10;                            isUserAnonymous = authResult.user?.isAnonymous == true,&#10;                            isLoggedIn = authResult.user != null,&#10;                            isUserExist = authResult.user != null,&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    _state.value.snackBarHostState.value.showSnackbar(&#10;                        error,&#10;                        duration = SnackbarDuration.Short,&#10;                        actionLabel = &quot;dismiss&quot;&#10;                    )&#10;                }&#10;                _state.value.copy(error = error)&#10;                             },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private suspend fun checkSignUpFields(): Boolean {&#10;        _state.value.snackBarHostState.value.currentSnackbarData?.dismiss()&#10;        return when {&#10;            _state.value.signUpEmail.isEmpty() || _state.value.signUpPassword.isEmpty() -&gt; {&#10;                state.value.snackBarHostState.value.showSnackbar(&#10;                    &quot;Email or password is empty&quot;,&#10;                    duration = SnackbarDuration.Short,&#10;                    actionLabel = &quot;dismiss&quot;&#10;                )&#10;                false&#10;            }&#10;&#10;            !_state.value.signUpEmail.contains(&quot;@&quot;) || !_state.value.signUpEmail.contains(&quot;.&quot;) -&gt; {&#10;                state.value.snackBarHostState.value.showSnackbar(&#10;                    &quot;Email is not in correct format&quot;,&#10;                    duration = SnackbarDuration.Short,&#10;                    actionLabel = &quot;dismiss&quot;&#10;                )&#10;                false&#10;            }&#10;&#10;            _state.value.signUpPassword.length &lt; 6 -&gt; {&#10;                state.value.snackBarHostState.value.showSnackbar(&#10;                    &quot;Password must be at least 6 characters&quot;,&#10;                    duration = SnackbarDuration.Short,&#10;                    actionLabel = &quot;dismiss&quot;&#10;                )&#10;                false&#10;            }&#10;&#10;            else -&gt; {&#10;                true&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class SignupViewModelState(&#10;    val loginEmail: String = &quot;&quot;,&#10;    val loginPassword: String = &quot;&quot;,&#10;    val signUpEmail: String = &quot;&quot;,&#10;    val signUpPassword: String = &quot;&quot;,&#10;    val forgotPasswordEmail: String = &quot;&quot;,&#10;    val isLoginLayout: MutableState&lt;Boolean&gt; = mutableStateOf(false),&#10;    val isSignUpLayout: MutableState&lt;Boolean&gt; = mutableStateOf(false),&#10;    val isForgotPasswordLayout: MutableState&lt;Boolean&gt; = mutableStateOf(false),&#10;    val signUpResponse: MutableState&lt;Resource&lt;SignUpResponse&gt;&gt; = mutableStateOf(Resource.Success()),&#10;    val sendEmailVerificationResponse: MutableState&lt;Resource&lt;Boolean&gt;&gt; = mutableStateOf(Resource.Success()),&#10;    val emailVerification: StateFlow&lt;VerifyEmailState&gt; = MutableStateFlow(VerifyEmailState()),&#10;    val revokeAccess: StateFlow&lt;RevokeAccessState&gt; = MutableStateFlow(RevokeAccessState()),&#10;    val isUserExist: Boolean = false,&#10;    val isEmailVerified: Boolean = false,&#10;    val isLoggedIn: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;,&#10;    val isUserAnonymous: Boolean = false,&#10;    val snackBarHostState: MutableState&lt;SnackbarHostState&gt; = mutableStateOf(SnackbarHostState()),&#10;)&#10;&#10;data class VerifyEmailState(&#10;    val verified: Boolean = false,&#10;    val sent: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel&#10;&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SignUpResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;&#10;class SignupViewModel(&#10;    private val repo: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(SignupViewModelState())&#10;    val state: StateFlow&lt;SignupViewModelState&gt; = _state.asStateFlow()&#10;&#10;    fun onEvent(event: SignupEvent) = viewModelScope.launch {&#10;        when (event) {&#10;            is SignupEvent.SignUpWithEmailAndPassword -&gt; {&#10;                signUpWithEmailAndPassword(event.email, event.password)&#10;            }&#10;&#10;            is SignupEvent.AnonymousSignIn -&gt; {&#10;                anonymousSignIn()&#10;            }&#10;&#10;            is SignupEvent.EnteredSignUpEmail -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    signUpEmail = event.email&#10;                )&#10;            }&#10;&#10;            is SignupEvent.EnteredSignUpPassword -&gt; {&#10;                _state.value = _state.value.copy(&#10;                    signUpPassword = event.password&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun &lt;T&gt; handleResource(&#10;        resourceFlow: Flow&lt;Resource&lt;T&gt;&gt;,&#10;        transform: (T) -&gt; Job,&#10;        errorTransform: (String) -&gt; SignupViewModelState,&#10;        loadingTransform: () -&gt; SignupViewModelState&#10;    ) = resourceFlow.onEach { resource -&gt;&#10;        when (resource) {&#10;            is Resource.Loading -&gt; _state.value = loadingTransform()&#10;            is Resource.Success -&gt; resource.data?.let { transform(it) }&#10;            is Resource.Error -&gt; _state.value = errorTransform(resource.message ?: &quot;Error&quot;)&#10;        }&#10;    }.launchIn(viewModelScope)&#10;&#10;    private suspend fun signUpWithEmailAndPassword(email: String, password: String) {&#10;        if (!checkSignUpFields()) return&#10;        handleResource(&#10;            resourceFlow = repo.firebaseSignUpWithEmailAndPassword(email, password),&#10;            transform = { result -&gt;&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            result,&#10;                            SnackbarAction(&quot;dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            error,&#10;                            SnackbarAction(&quot;dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;                _state.value.copy(&#10;                    error = error,&#10;                )&#10;            },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private suspend fun anonymousSignIn() {&#10;        handleResource(&#10;            resourceFlow = repo.anonymousSignIn(),&#10;            transform = { authResult -&gt;&#10;                viewModelScope.launch {&#10;                    _state.update {&#10;                        it.copy(&#10;                            isUserAnonymous = authResult.user?.isAnonymous == true,&#10;                            isLoggedIn = authResult.user != null,&#10;                            isUserExist = authResult.user != null,&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            errorTransform = { error -&gt;&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            error,&#10;                            SnackbarAction(&quot;dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;                _state.value.copy(error = error)&#10;                             },&#10;            loadingTransform = { _state.value.copy(isLoading = true) }&#10;        )&#10;    }&#10;&#10;    private suspend fun checkSignUpFields(): Boolean {&#10;        // currentSnackbarData dismissal is UI-specific; instead emit a snackbar event on invalid fields&#10;        return when {&#10;            _state.value.signUpEmail.isEmpty() || _state.value.signUpPassword.isEmpty() -&gt; {&#10;                SnackbarController.sendEvent(&#10;                    SnackbarEvent(&#10;                        message = &quot;Email or password is empty&quot;,&#10;                        action = SnackbarAction(&quot;dismiss&quot;) { }&#10;                    )&#10;                )&#10;                false&#10;            }&#10;&#10;            !_state.value.signUpEmail.contains(&quot;@&quot;) || !_state.value.signUpEmail.contains(&quot;.&quot;) -&gt; {&#10;                SnackbarController.sendEvent(&#10;                    SnackbarEvent(&#10;                        message = &quot;Email is not in correct format&quot;,&#10;                        action = SnackbarAction(&quot;dismiss&quot;) { }&#10;                    )&#10;                )&#10;                false&#10;            }&#10;&#10;            _state.value.signUpPassword.length &lt; 6 -&gt; {&#10;                SnackbarController.sendEvent(&#10;                    SnackbarEvent(&#10;                        message = &quot;Password must be at least 6 characters&quot;,&#10;                        action = SnackbarAction(&quot;dismiss&quot;) { }&#10;                    )&#10;                )&#10;                false&#10;            }&#10;&#10;            else -&gt; {&#10;                true&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;data class SignupViewModelState(&#10;    val loginEmail: String = &quot;&quot;,&#10;    val loginPassword: String = &quot;&quot;,&#10;    val signUpEmail: String = &quot;&quot;,&#10;    val signUpPassword: String = &quot;&quot;,&#10;    val forgotPasswordEmail: String = &quot;&quot;,&#10;    // layout flags removed to keep state stable; use LoginViewModel to control UI layout&#10;    val signUpResponse: Resource&lt;SignUpResponse&gt; = Resource.Success(),&#10;    val sendEmailVerificationResponse: Resource&lt;Boolean&gt; = Resource.Success(),&#10;    val emailVerification: VerifyEmailState = VerifyEmailState(),&#10;    val revokeAccess: RevokeAccessState = RevokeAccessState(),&#10;     val isUserExist: Boolean = false,&#10;     val isEmailVerified: Boolean = false,&#10;     val isLoggedIn: Boolean = false,&#10;     val isLoading: Boolean = false,&#10;     val error: String = &quot;&quot;,&#10;     val isUserAnonymous: Boolean = false,&#10;)&#10;&#10;data class VerifyEmailState(&#10;    val verified: Boolean = false,&#10;    val sent: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String = &quot;&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/DreamFavoriteScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/DreamFavoriteScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.domain.FavoriteEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components.DreamFavoriteScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamFavoriteScreen(&#10;    dreamFavoriteScreenState: DreamFavoriteScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit // Add onMainEvent parameter&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load dreams once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(FavoriteEvent.LoadDreams)&#10;    }&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamFavoriteScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;                    val snackResult =&#10;                        mainScreenViewModelState.scaffoldState.snackBarHostState.value.showSnackbar(&#10;                    SnackbarController.sendEvent(&#10;                            actionLabel = &quot;Undo&quot;,&#10;                            duration = SnackbarDuration.Long&#10;                            message = &quot;Dream deleted&quot;,&#10;&#10;                    mainScreenViewModelState.scaffoldState.snackBarHostState.value.currentSnackbarData?.dismiss()&#10;&#10;                    if (snackResult == SnackbarResult.ActionPerformed) {&#10;                        onEvent(FavoriteEvent.RestoreDream)&#10;                    } else {&#10;                        dreamFavoriteScreenState.dreamToDelete?.let { FavoriteEvent.DeleteDream(it) }&#10;                            ?.let { onEvent(it) }&#10;                    }&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;            DreamFavoriteScreenTopBar(mainScreenViewModelState = mainScreenViewModelState)&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { paddingValues -&gt;&#10;        if (dreamFavoriteScreenState.dreamFavoriteList.isEmpty()) {&#10;            // Show an empty state&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(&#10;                        top = paddingValues.calculateTopPadding(),&#10;                        bottom = bottomPaddingValue&#10;                    )&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no favorites. Add some!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, show the favorites list&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize(),&#10;            contentPadding = PaddingValues(bottom = 16.dp)&#10;        ) {&#10;            // 1) Parse and sort by LocalDate, descending, like DreamJournalListScreen&#10;            val sortedGroupedDreams = dreamFavoriteScreenState.dreamFavoriteList&#10;                .mapNotNull { dream -&gt;&#10;                    // parseCustomDate(...) might throw an exception if invalid&#10;                    // or return null if you wrap it in a try/catch&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        // Return a pair (LocalDate, Dream)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                // Sort descending by date, then descending by dream.timestamp&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                // Group by the parsed LocalDate&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, display a sticky header + items&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        scope = scope,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(FavoriteEvent.DreamToDelete(dream))&#10;                            onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.domain.FavoriteEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components.DreamFavoriteScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamFavoriteScreen(&#10;    dreamFavoriteScreenState: DreamFavoriteScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (FavoriteEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit // Add onMainEvent parameter&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load dreams once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(FavoriteEvent.LoadDreams)&#10;    }&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamFavoriteScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                scope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { onEvent(FavoriteEvent.RestoreDream) }&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamFavoriteScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { paddingValues -&gt;&#10;        if (dreamFavoriteScreenState.dreamFavoriteList.isEmpty()) {&#10;            // Show an empty state&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(&#10;                        top = paddingValues.calculateTopPadding(),&#10;                        bottom = bottomPaddingValue&#10;                    )&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no favorites. Add some!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, show the favorites list&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize(),&#10;            contentPadding = PaddingValues(bottom = 16.dp)&#10;        ) {&#10;            // 1) Parse and sort by LocalDate, descending, like DreamJournalListScreen&#10;            val sortedGroupedDreams = dreamFavoriteScreenState.dreamFavoriteList&#10;                .mapNotNull { dream -&gt;&#10;                    // parseCustomDate(...) might throw an exception if invalid&#10;                    // or return null if you wrap it in a try/catch&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        // Return a pair (LocalDate, Dream)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                // Sort descending by date, then descending by dream.timestamp&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                // Group by the parsed LocalDate&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, display a sticky header + items&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(FavoriteEvent.DreamToDelete(dream))&#10;                            onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/components/DreamFavoriteScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/components/DreamFavoriteScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamFavoriteScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Favorites&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamFavoriteScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Favorites&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;Favorites: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamJournalListScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val dreamState by rememberUpdatedState(dreamJournalListState.dreams)&#10;    val dreamCount = dreamJournalListState.dreams.size&#10;    val isRecentlySaved = mainScreenViewModelState.isDreamRecentlySaved&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;        onMainEvent(MainScreenEvent.SetFloatingActionButtonState(true))&#10;        onMainEvent(MainScreenEvent.SetDrawerState(true))&#10;    }&#10;&#10;//    // The key part: trigger in-app review from the VM if conditions are met&#10;//    LaunchedEffect(isRecentlySaved) {&#10;//        if (dreamCount &gt;= 2 &amp;&amp; isRecentlySaved) {&#10;//            delay(1000)&#10;//            // Dispatch the &quot;TriggerReview&quot; event to the VM&#10;//            onDreamListEvent(DreamListEvent.TriggerReview)&#10;//        }&#10;//    }&#10;&#10;    if (dreamJournalListState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            modifier = Modifier.padding(),&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;                onDreamListEvent(DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!))&#10;                    val result =&#10;                        mainScreenViewModelState.scaffoldState.snackBarHostState.value.showSnackbar(&#10;                        SnackbarEvent(&#10;                            actionLabel = &quot;Undo&quot;,&#10;                            duration = SnackbarDuration.Long&#10;                        )&#10;&#10;                    if (result == SnackbarResult.ActionPerformed) {&#10;                        onDreamListEvent(DreamListEvent.RestoreDream)&#10;                    }&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamListScreenTopBar(&#10;                dreamJournalListState = dreamJournalListState,&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onDreamListEvent = onDreamListEvent&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) },&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { innerPadding -&gt;&#10;&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .dynamicBottomNavigationPadding()&#10;                .padding(top = topPadding, bottom = bottomPaddingValue),&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        ) {&#10;            // Step 1: Parse and Sort Dreams&#10;            val sortedGroupedDreams = dreamJournalListState.dreams&#10;                .mapNotNull { dream -&gt;&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        Pair(parsedDate, dream)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // Step 2: Iterate Through Groups&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;                // Sticky Header for the Date&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;                }&#10;&#10;                // Items for Each Dream in the Date Group&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 20.dp),&#10;                        scope = scope,&#10;                        onClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onDreamListEvent(&#10;                                DreamListEvent.DreamToDelete(dream)&#10;                            )&#10;                            onDreamListEvent(&#10;                                DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                            )&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamJournalListScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val dreamState by rememberUpdatedState(dreamJournalListState.dreams)&#10;    val dreamCount = dreamJournalListState.dreams.size&#10;    val isRecentlySaved = mainScreenViewModelState.isDreamRecentlySaved&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;        onMainEvent(MainScreenEvent.SetFloatingActionButtonState(true))&#10;        onMainEvent(MainScreenEvent.SetDrawerState(true))&#10;    }&#10;&#10;//    // The key part: trigger in-app review from the VM if conditions are met&#10;//    LaunchedEffect(isRecentlySaved) {&#10;//        if (dreamCount &gt;= 2 &amp;&amp; isRecentlySaved) {&#10;//            delay(1000)&#10;//            // Dispatch the &quot;TriggerReview&quot; event to the VM&#10;//            onDreamListEvent(DreamListEvent.TriggerReview)&#10;//        }&#10;//    }&#10;&#10;    if (dreamJournalListState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            modifier = Modifier.padding(),&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;                onDreamListEvent(DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!))&#10;                scope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) {&#10;                                onDreamListEvent(DreamListEvent.RestoreDream)&#10;                            },&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamListScreenTopBar(&#10;                dreamJournalListState = dreamJournalListState,&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                searchTextFieldState = searchTextFieldState,&#10;                onDreamListEvent = onDreamListEvent,&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) },&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { innerPadding -&gt;&#10;&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .dynamicBottomNavigationPadding()&#10;                .padding(top = topPadding, bottom = bottomPaddingValue),&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        ) {&#10;            // Step 1: Parse and Sort Dreams&#10;            val sortedGroupedDreams = dreamJournalListState.dreams&#10;                .mapNotNull { dream -&gt;&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        Pair(parsedDate, dream)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // Step 2: Iterate Through Groups&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;                // Sticky Header for the Date&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;                }&#10;&#10;                // Items for Each Dream in the Date Group&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 20.dp),&#10;                        onClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onDreamListEvent(&#10;                                DreamListEvent.DreamToDelete(dream)&#10;                            )&#10;                            onDreamListEvent(&#10;                                DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                            )&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.InfiniteTransition&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.AsyncImagePainter&#10;import coil3.compose.rememberAsyncImagePainter&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    scope: CoroutineScope,&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;    val borderThickness = infiniteTransition.animateFloat(&#10;        initialValue = 4f,&#10;        targetValue = 6f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Reverse&#10;        ), label = &quot;&quot;&#10;    )&#10;        )&#10;    val shimmerBrush = shimmerBrush(infiniteTransition)&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush(rememberInfiniteTransition(label = &quot;borderBrush&quot;)) else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            width = borderThickness.value.dp,&#10;            brush = shimmerBrush,&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                    scope.launch {&#10;                        if (isLongPressTriggered) {&#10;                            onDeleteClick()&#10;                        }&#10;                        isLongPressTriggered = false // Reset after handling&#10;                    }&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    // Use painter + state to control shimmer only while loading&#10;                    val painter = rememberAsyncImagePainter(model = generatedImage)&#10;                    val painterState = painter.state&#10;                    Box(Modifier.fillMaxSize()) {&#10;                        Image(&#10;                            painter = painter,&#10;                            contentDescription = &quot;Dream Image&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                        if (painterState.value is AsyncImagePainter.State.Loading) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .shimmerEffect()&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    Image(&#10;                        painter = painterResource(chosenBackground),&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop,&#10;                        contentDescription = &quot;Dream Image&quot;&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(transition: InfiniteTransition): Brush {&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.InfiniteTransition&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.AsyncImagePainter&#10;import coil3.compose.SubcomposeAsyncImage&#10;import coil3.compose.SubcomposeAsyncImageContent&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;        }&#10;&#10;    // Only run border/shimmer animations if hasBorder is true to avoid unnecessary redraws&#10;    val borderThickness = if (hasBorder) {&#10;        val t = rememberInfiniteTransition(label = &quot;border&quot;)&#10;        t.animateFloat(&#10;            initialValue = 4f,&#10;            targetValue = 6f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;borderThickness&quot;&#10;        )&#10;    } else null&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush() else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            )&#10;            .border(&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                onLongClick = {&#10;                    isLongPressTriggered = true&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    SubcomposeAsyncImage(&#10;                        model = generatedImage,&#10;                        contentDescription = &quot;Dream Image&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop,&#10;                        loading = {&#10;                            // Fallback + shimmer while loading/empty&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Placeholder&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .shimmerEffect()&#10;                            )&#10;                        },&#10;                        error = {&#10;                            // Fallback on error&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Fallback&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                        },&#10;                        success = {&#10;                            SubcomposeAsyncImageContent()&#10;                        }&#10;                    )&#10;                } else {&#10;                     Image(&#10;                         painter = painterResource(chosenBackground),&#10;                         modifier = Modifier.fillMaxSize(),&#10;                         contentScale = ContentScale.Crop,&#10;                         contentDescription = &quot;Dream Image&quot;&#10;                     )&#10;                 }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(): Brush {&#10;    val transition = rememberInfiniteTransition(label = &quot;borderBrush&quot;)&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamListScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamListScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.foundation.text.input.clearText&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamListScreenTopBar(&#10;    dreamJournalListState: DreamJournalListState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;            ) {&#10;                if (!dreamJournalListState.isSearching) {&#10;                    Text(&#10;                        text = &quot;Dream Journal AI&quot;,&#10;                        color = White,&#10;                        modifier = Modifier&#10;                            .align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                AnimatedVisibility(&#10;                    visible = dreamJournalListState.isSearching,&#10;                    //slide from left to right&#10;                    enter = slideInHorizontally(&#10;                        initialOffsetX = { it },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    exit = slideOutHorizontally(&#10;                        targetOffsetX = { -it - 400 },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;&#10;                ) {&#10;                    TransparentHintTextField(&#10;                        textFieldState = searchTextFieldState,&#10;                        hint = &quot;Search dream...&quot;,&#10;                        isHintVisible = searchTextFieldState.text.isBlank(),&#10;                        singleLine = true,&#10;                        textStyle = MaterialTheme.typography.headlineSmall.copy(White),&#10;                        modifier = Modifier&#10;                            .clip(RoundedCornerShape(10.dp))&#10;                            .background(&#10;                                color = White.copy(&#10;                                    alpha = 0.2f&#10;                                )&#10;                            )&#10;                            .padding(4.dp, 2.dp, 0.dp, 2.dp)&#10;                            .fillMaxWidth()&#10;                            .padding(4.dp)&#10;                            .focusable(),&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(Icons.Filled.Menu, contentDescription = &quot;Menu&quot;, tint = White)&#10;            }&#10;        },&#10;        actions = {&#10;            if (!dreamJournalListState.isSearching) {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                        onDreamListEvent(DreamListEvent.SetSearchingState(true))&#10;                    },&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.Search,&#10;                        contentDescription = &quot;Search&quot;,&#10;                        tint = White&#10;                    )&#10;                }&#10;            } else {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                        keyboardController?.hide()&#10;                        searchTextFieldState.clearText()&#10;                        onDreamListEvent(DreamListEvent.SetSearchingState(false))&#10;                    },&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.Close,&#10;                        contentDescription = &quot;Close&quot;,&#10;                        tint = White&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.foundation.text.input.clearText&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamListScreenTopBar(&#10;    dreamJournalListState: DreamJournalListState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;            ) {&#10;                if (!dreamJournalListState.isSearching) {&#10;                    Text(&#10;                        text = &quot;Dream Journal AI&quot;,&#10;                        color = White,&#10;                        modifier = Modifier&#10;                            .align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                AnimatedVisibility(&#10;                    visible = dreamJournalListState.isSearching,&#10;                    //slide from left to right&#10;                    enter = slideInHorizontally(&#10;                        initialOffsetX = { it },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    exit = slideOutHorizontally(&#10;                        targetOffsetX = { -it - 400 },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;&#10;                ) {&#10;                    TransparentHintTextField(&#10;                        textFieldState = searchTextFieldState,&#10;                        hint = &quot;Search dream...&quot;,&#10;                        isHintVisible = searchTextFieldState.text.isBlank(),&#10;                        singleLine = true,&#10;                        textStyle = MaterialTheme.typography.headlineSmall.copy(White),&#10;                        modifier = Modifier&#10;                            .clip(RoundedCornerShape(10.dp))&#10;                            .background(&#10;                                color = White.copy(&#10;                                    alpha = 0.2f&#10;                                )&#10;                            )&#10;                            .padding(4.dp, 2.dp, 0.dp, 2.dp)&#10;                            .fillMaxWidth()&#10;                            .padding(4.dp)&#10;                            .focusable(),&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                Logger.d(&quot;TopBar&quot;) { &quot;DreamList: Menu icon clicked -&gt; request open drawer&quot; }&#10;                scope.launch { DrawerController.send(DrawerCommand.Open) }&#10;            }) {&#10;                Icon(Icons.Filled.Menu, contentDescription = &quot;Menu&quot;, tint = White)&#10;            }&#10;        },&#10;        actions = {&#10;            if (!dreamJournalListState.isSearching) {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                        onDreamListEvent(DreamListEvent.SetSearchingState(true))&#10;                    },&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.Search,&#10;                        contentDescription = &quot;Search&quot;,&#10;                        tint = White&#10;                    )&#10;                }&#10;            } else {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                        keyboardController?.hide()&#10;                        searchTextFieldState.clearText()&#10;                        onDreamListEvent(DreamListEvent.SetSearchingState(false))&#10;                    },&#10;                ) {&#10;                    Icon(&#10;                        Icons.Filled.Close,&#10;                        contentDescription = &quot;Close&quot;,&#10;                        tint = White&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import co.touchlab.kermit.Logger&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                    // Request the permission&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (deniedAlways: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Don’t ask again).&#10;                    // Handle your fallback scenario here — e.g., show a dialog explaining&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (denied: DeniedException) {&#10;                    // The user has denied the permission (but not “don’t ask again”).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;        drawerState = mainScreenViewModelState.drawerMain,&#10;        drawerState = drawerState,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            //AnimatedHeartIcon()&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        coroutineScope.launch {&#10;                                            mainScreenViewModelState.drawerMain.close()&#10;                                        }&#10;                                        selectedItem.value = item&#10;                                         selectedItem.value = item&#10;                                             onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                            onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                        } else {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(DrawerNavigation.DreamJournalScreen.route) {&#10;                                                    saveState = true&#10;                                                }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;                    }&#10;                }&#10;                    SnackbarHost(mainScreenViewModelState.scaffoldState.snackBarHostState.value)&#10;&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(snackbarHostState)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            BottomNavigation(&#10;                                navController = navController,&#10;                                modifier = Modifier.align(Alignment.BottomCenter),&#10;                                onMainEvent = onMainEvent,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        // Temporarily disable bottom navigation to avoid rapid taps navigating elsewhere&#10;                                        onMainEvent(MainScreenEvent.SetBottomBarEnabledState(false))&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                        // Re-enable bottom bar shortly after navigation starts&#10;                                        coroutineScope.launch {&#10;                                            delay(700)&#10;                                            onMainEvent(MainScreenEvent.SetBottomBarEnabledState(true))&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;&#10;                    ScreenGraph(&#10;                        navController = navController,&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon() {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;    val size by infiniteTransition.animateFloat(&#10;        initialValue = 24f,&#10;        targetValue = 28f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 800),  // Slower animation&#10;            repeatMode = RepeatMode.Reverse&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    Icon(&#10;        imageVector = Icons.Default.Favorite,&#10;        contentDescription = &quot;Animated Heart&quot;,&#10;        tint = Color.Red,&#10;        modifier = Modifier.size(size.dp)&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberDrawerState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import co.touchlab.kermit.Logger&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.Permission&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import dev.icerock.moko.permissions.compose.PermissionsControllerFactory&#10;import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.navigation.DrawerNavigation&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                    // Request the permission&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (deniedAlways: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Don’t ask again).&#10;                    // Handle your fallback scenario here — e.g., show a dialog explaining&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (denied: DeniedException) {&#10;                    // The user has denied the permission (but not “don’t ask again”).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;    // Local drawer state owned by the composable for Compose stability. The ViewModel exposes&#10;    // an intent flag `isDrawerOpen`; we react to it below.&#10;    val drawerState = rememberDrawerState(DrawerValue.Closed)&#10;&#10;    // Track when we're driving the drawer programmatically to avoid echo-loops&#10;    var programmaticChangeInProgress = remember { mutableStateOf(false) }&#10;&#10;    // Drive the drawer from a simple controller to avoid VM&lt;-&gt;UI races&#10;    ObserveAsEvents(DrawerController.events, key1 = drawerState) { cmd -&gt;&#10;        Logger.d(&quot;MainScreen&quot;) { &quot;DrawerCommand: $cmd | current=${drawerState.currentValue} anim=${drawerState.isAnimationRunning}&quot; }&#10;        programmaticChangeInProgress.value = true&#10;        coroutineScope.launch {&#10;            try {&#10;                when (cmd) {&#10;                    is DrawerCommand.Open -&gt; if (drawerState.currentValue != DrawerValue.Open) drawerState.open()&#10;                    is DrawerCommand.Close -&gt; if (drawerState.currentValue != DrawerValue.Closed) drawerState.close()&#10;                    is DrawerCommand.Toggle -&gt; if (drawerState.currentValue == DrawerValue.Open) drawerState.close() else drawerState.open()&#10;                }&#10;            } finally {&#10;                programmaticChangeInProgress.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(drawerState) {&#10;        snapshotFlow { drawerState.currentValue }&#10;            .collectLatest { current -&gt;&#10;                Logger.d(&quot;MainScreen&quot;) { &quot;Drawer currentValue=$current | anim=${drawerState.isAnimationRunning} | programmatic=${programmaticChangeInProgress.value}&quot; }&#10;            }&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            AnimatedHeartIcon(animate = drawerState.currentValue == DrawerValue.Open)&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                    onClick = {&#10;                                         onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                         coroutineScope.launch {&#10;                                             drawerState.close()&#10;                                         }&#10;                                     selectedItem.value = item&#10;&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                             onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                         } else {&#10;                                             navController.navigate(item.route) {&#10;                                                 popUpTo(DrawerNavigation.DreamJournalScreen.route) {&#10;                                                     saveState = true&#10;                                                 }&#10;                                                 launchSingleTop = true&#10;                                                 restoreState = true&#10;                                             }&#10;                                         }&#10;                                     },&#10;                                    modifier = Modifier&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        content = {&#10;            // Local snackbar host state — main view model no longer holds snackbar UI state.&#10;            val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;            // Observe events from the centralized controller and show them on the local host.&#10;            ObserveAsEvents(SnackbarController.events) { event -&gt;&#10;                coroutineScope.launch {&#10;                    snackbarHostState.currentSnackbarData?.dismiss()&#10;                    val result = snackbarHostState.showSnackbar(&#10;                        message = event.message,&#10;                        actionLabel = event.action?.name,&#10;                        duration = SnackbarDuration.Long&#10;                    )&#10;                    if (result == SnackbarResult.ActionPerformed) {&#10;                        event.action?.action?.invoke()&#10;                    }&#10;                }&#10;            }&#10;&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(snackbarHostState)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                            val currentRoute = navBackStackEntry?.destination?.route&#10;                            BottomNavigation(&#10;                                currentRoute = currentRoute,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState,&#10;                                onMainEvent = onMainEvent,&#10;                                onNavigate = { route -&gt;&#10;                                    navController.navigate(route) {&#10;                                        popUpTo(org.ballistic.dreamjournalai.shared.navigation.Route.DreamJournalScreen) {&#10;                                            saveState = true&#10;                                        }&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.align(Alignment.BottomCenter)&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        // Temporarily disable bottom navigation to avoid rapid taps navigating elsewhere&#10;                                        onMainEvent(MainScreenEvent.SetBottomBarEnabledState(false))&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                        // Re-enable bottom bar shortly after navigation starts&#10;                                        coroutineScope.launch {&#10;                                            delay(700)&#10;                                            onMainEvent(MainScreenEvent.SetBottomBarEnabledState(true))&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;&#10;                    ScreenGraph(&#10;                        navController = navController,&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon(animate: Boolean = true) {&#10;    if (animate) {&#10;        val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;        val size by infiniteTransition.animateFloat(&#10;            initialValue = 24f,&#10;            targetValue = 28f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 800),  // Slower animation&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;&quot;&#10;        )&#10;&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Animated Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(size.dp)&#10;        )&#10;    } else {&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/components/BottomNavigationBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/components/BottomNavigationBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateColorAsState&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.NavigationBarItemDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.drawWithCache&#10;import androidx.compose.ui.graphics.BlendMode&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.navigation.BottomNavigationRoutes&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@Composable&#10;fun BottomNavigation(&#10;    navController: NavController,&#10;    isNavigationEnabled: Boolean,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit,&#10;    modifier: Modifier&#10;) {&#10;    NavigationBar(&#10;        containerColor = Color.Transparent,&#10;        contentColor = Color.Black,&#10;        modifier = modifier&#10;    ) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;        val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;        BottomNavigationRoutes.entries.forEachIndexed { index, item -&gt;&#10;            val isSelected by remember(currentRoute) {&#10;                mutableStateOf(&#10;                    derivedStateOf { currentRoute == item.route::class.qualifiedName }&#10;                )&#10;            }&#10;&#10;            // Setup for on-click and selection-based scaling&#10;            val targetScale = if (isSelected.value) 1.25f else 1.1f&#10;            val scale = remember { Animatable(targetScale) }&#10;&#10;            // Continuous floating effect setup&#10;            val floatingScale by infiniteTransition.animateFloat(&#10;                initialValue = 1f,&#10;                targetValue = 1.05f,&#10;                animationSpec = infiniteRepeatable(&#10;                    animation = tween(durationMillis = 2000, easing = LinearEasing),&#10;                    repeatMode = RepeatMode.Reverse&#10;                ), label = &quot;&quot;&#10;            )&#10;            val rotation by infiniteTransition.animateFloat(&#10;                initialValue = -2f,&#10;                targetValue = 2f,&#10;                animationSpec = infiniteRepeatable(&#10;                    animation = tween(durationMillis = 3000, easing = LinearEasing),&#10;                    repeatMode = RepeatMode.Reverse&#10;                ), label = &quot;&quot;&#10;            )&#10;&#10;            // Apply immediate scale change on selection&#10;            LaunchedEffect(isSelected) {&#10;                scale.animateTo(&#10;                    targetValue = targetScale,&#10;                    animationSpec = tween(durationMillis = 400)&#10;                )&#10;            }&#10;&#10;            NavigationBarItem(&#10;                icon = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Box(&#10;                            modifier = Modifier.graphicsLayer {&#10;                                val finalScale = if (isSelected.value) floatingScale * scale.value else scale.value&#10;                                scaleX = finalScale&#10;                                scaleY = finalScale&#10;                                rotationZ = if (isSelected.value) rotation else 0f&#10;                            }&#10;                        ) {&#10;                            // Gold highlight icon (bottom layer)&#10;                            if (isSelected.value) {&#10;                                Icon(&#10;                                    imageVector = item.icon,&#10;                                    contentDescription = null, // decorative&#10;                                    modifier = Modifier&#10;                                        .offset(y = 1.5.dp, x = (-.8).dp)&#10;                                        .size(24.dp),&#10;                                    tint = Color(0xFFFAB4A6) // Soft Peachy-Pink Highlight&#10;                                )&#10;                            }&#10;&#10;                            // Main icon (top layer)&#10;                            Icon(&#10;                                imageVector = item.icon,&#10;                                contentDescription = item.title,&#10;                                modifier = Modifier&#10;                                    .size(24.dp)&#10;                                    .graphicsLayer(alpha = 0.99f)&#10;                                    .drawWithCache {&#10;                                        onDrawWithContent {&#10;                                            drawContent()&#10;                                            if (isSelected.value) {&#10;                                                drawRect(&#10;                                                    brush = Brush.verticalGradient(&#10;                                                        listOf(&#10;                                                            Color(0xFFF48FB1), // Softer Pink&#10;                                                            Color(0xFFF06292)  // Soft Pink&#10;                                                        )&#10;                                                    ),&#10;                                                    blendMode = BlendMode.SrcIn&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                tint = if (isSelected.value) Color.Unspecified else Color.LightGray&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(&#10;                            visible = isSelected.value,&#10;                            modifier = Modifier.padding(start = 4.dp),&#10;                        ) {&#10;                            Text(&#10;                                text = item.title!!,&#10;                                color = White,&#10;                                style = typography.titleSmall,&#10;                                modifier = Modifier.padding(vertical = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                selected = isSelected.value,&#10;                onClick = {&#10;                    onMainEvent(MainScreenEvent.TriggerVibration)&#10;                    if (currentRoute != item.route.toString()) {&#10;                        navController.navigate(item.route) {&#10;                            // Ensure we pop to a real destination ID, not a label&#10;                            popUpTo(navController.graph.findStartDestination().id) {&#10;                                saveState = true&#10;                            }&#10;                            launchSingleTop = true&#10;                            restoreState = true&#10;                        }&#10;                    }&#10;                },&#10;                colors = NavigationBarItemDefaults.colors(&#10;                    indicatorColor = LightBlack.copy(alpha = 0.2f),&#10;                ),&#10;                alwaysShowLabel = true,&#10;                enabled = isNavigationEnabled&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.NavigationBarItemDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.drawWithCache&#10;import androidx.compose.ui.graphics.BlendMode&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.navigation.BottomNavigationRoutes&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@Composable&#10;fun BottomNavigation(&#10;    currentRoute: String?,&#10;    isNavigationEnabled: Boolean,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit,&#10;    onNavigate: (Route) -&gt; Unit,&#10;    modifier: Modifier&#10;) {&#10;    NavigationBar(&#10;        containerColor = Color.Transparent,&#10;        contentColor = Color.Black,&#10;        modifier = modifier&#10;    ) {&#10;        val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;        BottomNavigationRoutes.entries.forEachIndexed { index, item -&gt;&#10;            val qualified = item.route::class.qualifiedName&#10;            val simple = item.route::class.simpleName&#10;            val isSelected = when {&#10;                currentRoute == qualified -&gt; true&#10;                currentRoute == item.route.toString() -&gt; true&#10;                simple != null &amp;&amp; (currentRoute?.endsWith(&quot;.$simple&quot;) == true) -&gt; true&#10;                simple != null &amp;&amp; (currentRoute?.contains(simple) == true) -&gt; true&#10;                else -&gt; false&#10;            }&#10;&#10;            // Setup for on-click and selection-based scaling&#10;            val targetScale = if (isSelected) 1.25f else 1.1f&#10;            val scale = remember { Animatable(targetScale) }&#10;&#10;            // Continuous floating effect setup&#10;            val floatingScale by infiniteTransition.animateFloat(&#10;                initialValue = 1f,&#10;                targetValue = 1.05f,&#10;                animationSpec = infiniteRepeatable(&#10;                    animation = tween(durationMillis = 2000, easing = LinearEasing),&#10;                    repeatMode = RepeatMode.Reverse&#10;                ), label = &quot;&quot;&#10;            )&#10;            val rotation by infiniteTransition.animateFloat(&#10;                initialValue = -2f,&#10;                targetValue = 2f,&#10;                animationSpec = infiniteRepeatable(&#10;                    animation = tween(durationMillis = 3000, easing = LinearEasing),&#10;                    repeatMode = RepeatMode.Reverse&#10;                ), label = &quot;&quot;&#10;            )&#10;&#10;            // Apply immediate scale change on selection&#10;            LaunchedEffect(isSelected) {&#10;                scale.animateTo(&#10;                    targetValue = targetScale,&#10;                    animationSpec = tween(durationMillis = 400)&#10;                )&#10;            }&#10;&#10;            NavigationBarItem(&#10;                icon = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Box(&#10;                            modifier = Modifier.graphicsLayer {&#10;                                val finalScale = if (isSelected) floatingScale * scale.value else scale.value&#10;                                scaleX = finalScale&#10;                                scaleY = finalScale&#10;                                rotationZ = if (isSelected) rotation else 0f&#10;                            }&#10;                        ) {&#10;                            // Gold highlight icon (bottom layer)&#10;                            if (isSelected) {&#10;                                Icon(&#10;                                    imageVector = item.icon,&#10;                                    contentDescription = null, // decorative&#10;                                    modifier = Modifier&#10;                                        .offset(y = 1.5.dp, x = (-.8).dp)&#10;                                        .size(24.dp),&#10;                                    tint = Color(0xFFFAB4A6) // Soft Peachy-Pink Highlight&#10;                                )&#10;                            }&#10;&#10;                            // Main icon (top layer)&#10;                            Icon(&#10;                                imageVector = item.icon,&#10;                                contentDescription = item.title,&#10;                                modifier = Modifier&#10;                                    .size(24.dp)&#10;                                    .graphicsLayer(alpha = 0.99f)&#10;                                    .drawWithCache {&#10;                                        onDrawWithContent {&#10;                                            drawContent()&#10;                                            if (isSelected) {&#10;                                                drawRect(&#10;                                                    brush = Brush.verticalGradient(&#10;                                                        listOf(&#10;                                                            Color(0xFFF48FB1), // Softer Pink&#10;                                                            Color(0xFFF06292)  // Soft Pink&#10;                                                        )&#10;                                                    ),&#10;                                                    blendMode = BlendMode.SrcIn&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                tint = if (isSelected) Color.Unspecified else Color.LightGray&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(&#10;                            visible = isSelected,&#10;                            modifier = Modifier.padding(start = 4.dp),&#10;                        ) {&#10;                            Text(&#10;                                text = item.title!!,&#10;                                color = White,&#10;                                style = typography.titleSmall,&#10;                                modifier = Modifier.padding(vertical = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                selected = isSelected,&#10;                onClick = {&#10;                    onMainEvent(MainScreenEvent.TriggerVibration)&#10;                    if (!isSelected) {&#10;                        onNavigate(item.route)&#10;                    }&#10;                },&#10;                colors = NavigationBarItemDefaults.colors(&#10;                    indicatorColor = LightBlack.copy(alpha = 0.2f),&#10;                ),&#10;                alwaysShowLabel = true,&#10;                enabled = isNavigationEnabled&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState(authRepo = repo))&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;MainScreenViewModel initialized&quot; }&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;        when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                mainScreenViewModelState.value.searchedText.value = event.query&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let {&#10;                        _mainScreenViewModelState.value.scaffoldState.snackBarHostState.value.showSnackbar(&#10;                            message = it&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value.scaffoldState.snackBarHostState.value.showSnackbar(&#10;                        message = event.message,&#10;                        duration = SnackbarDuration.Short,&#10;                        actionLabel = &quot;Dismiss&quot;&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    if(event.drawerValue == DrawerValue.Closed) {&#10;                        _mainScreenViewModelState.value.drawerMain.close()&#10;                    } else {&#10;                        _mainScreenViewModelState.value.drawerMain.open()&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    val drawerMain: DrawerState = DrawerState(DrawerValue.Closed),&#10;    val authRepo: AuthRepository,&#10;    val searchedText: MutableStateFlow&lt;String&gt; = MutableStateFlow(&quot;&quot;),&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;    val snackBarHostState: MutableState&lt;SnackbarHostState&gt; = mutableStateOf(SnackbarHostState()),&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState(authRepo = repo))&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;MainScreenViewModel initialized&quot; }&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;onEvent: $event&quot; }&#10;        when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                // store plain string in state; composables should handle text input and emit events&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    searchedText = event.query&#10;                )&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let { msg -&gt;&#10;                        viewModelScope.launch {&#10;                            org.ballistic.dreamjournalai.shared.SnackbarController.sendEvent(&#10;                                org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                                    message = msg,&#10;                                    action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                            message = event.message,&#10;                            action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                // ViewModel does not own a DrawerState (Compose UI object). Instead, store intent as a boolean.&#10;                Logger.d(&quot;MainScreenViewModel&quot;) { &quot;ToggleDrawerState -&gt; ${event.drawerValue}&quot; }&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isDrawerOpen = (event.drawerValue != DrawerValue.Closed)&#10;                )&#10;            }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    // ViewModel no longer holds a Compose DrawerState; instead expose a simple boolean intent&#10;    val isDrawerOpen: Boolean = false,&#10;    val authRepo: AuthRepository,&#10;    // Keep search text as a plain String for stability; composables handle input&#10;    val searchedText: String = &quot;&quot;,&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/DreamNightmareScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/DreamNightmareScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.domain.NightmareEvent&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components.DreamNightmareScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenState&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamNightmareScreen(&#10;    dreamNightmareScreenState: DreamNightmareScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (NightmareEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamNightmareScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            onClick = {&#10;                dreamNightmareScreenState.dreamToDelete?.let { NightmareEvent.DeleteDream(it) }&#10;                    ?.let { onEvent(it) }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    // Load the nightmares once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(NightmareEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamNightmareScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) { paddingValues -&gt;&#10;&#10;        // If we have no nightmares, show an empty-state message&#10;        if (dreamNightmareScreenState.dreamNightmareList.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no nightmares. Hopefully you never do!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, display them in a LazyColumn&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding(),&#10;            contentPadding = PaddingValues(bottom = 40.dp),&#10;        ) {&#10;            // 1) Parse and sort by LocalDate (descending), then by dream.timestamp (descending)&#10;            val sortedGroupedNightmares = dreamNightmareScreenState.dreamNightmareList&#10;                .mapNotNull { dream -&gt;&#10;                    // Try to parse the dream.date using your custom parser&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        // If parse fails, skip this dream or handle differently&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, show a sticky header, then items&#10;            sortedGroupedNightmares.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        scope = scope,&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(NightmareEvent.DreamToDelete(dream))&#10;                            onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.domain.NightmareEvent&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components.DreamNightmareScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenState&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamNightmareScreen(&#10;    dreamNightmareScreenState: DreamNightmareScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (NightmareEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamNightmareScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            onClick = {&#10;                dreamNightmareScreenState.dreamToDelete?.let { NightmareEvent.DeleteDream(it) }&#10;                    ?.let { onEvent(it) }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    // Load the nightmares once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(NightmareEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamNightmareScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) { paddingValues -&gt;&#10;&#10;        // If we have no nightmares, show an empty-state message&#10;        if (dreamNightmareScreenState.dreamNightmareList.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no nightmares. Hopefully you never do!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, display them in a LazyColumn&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding(),&#10;            contentPadding = PaddingValues(bottom = 40.dp),&#10;        ) {&#10;            // 1) Parse and sort by LocalDate (descending), then by dream.timestamp (descending)&#10;            val sortedGroupedNightmares = dreamNightmareScreenState.dreamNightmareList&#10;                .mapNotNull { dream -&gt;&#10;                    // Try to parse the dream.date using your custom parser&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        // If parse fails, skip this dream or handle differently&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, show a sticky header, then items&#10;            sortedGroupedNightmares.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(NightmareEvent.DreamToDelete(dream))&#10;                            onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/components/DreamNightmareScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/components/DreamNightmareScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamNightmareScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Nightmares&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamNightmareScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Nightmares&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;Nightmares: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_onboarding/presentation/OnboardingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_onboarding/presentation/OnboardingScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_onboarding.presentation&#10;&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.animateColor&#10;import androidx.compose.animation.core.updateTransition&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_account.MyGoogleSignInButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.AnonymousButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserveLoginState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.SignupLoginLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.jetbrains.compose.resources.painterResource&#10;import kotlin.uuid.ExperimentalUuidApi&#10;&#10;&#10;@OptIn(ExperimentalUuidApi::class)&#10;@ExperimentalAnimationApi&#10;@Composable&#10;fun OnboardingScreen(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    navigateToDreamJournalScreen: () -&gt; Unit,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit,&#10;    onSignupEvent: (SignupEvent) -&gt; Unit,&#10;    onDataLoaded: () -&gt; Unit,&#10;) {&#10;    val isUserAnonymous = loginViewModelState.isUserAnonymous&#10;    val isUserLoggedIn = loginViewModelState.isLoggedIn&#10;    val isEmailVerified = loginViewModelState.isEmailVerified&#10;    val showLoginLayout = remember { mutableStateOf(false) }&#10;    val isSplashScreenClosed = remember { mutableStateOf(false) }&#10;    val titleText = remember { mutableStateOf(&quot;Welcome Dreamer!&quot;) }&#10;    val visible = remember { mutableStateOf(true) }&#10;    val transition = updateTransition(visible.value, label = &quot;&quot;)&#10;    val showSubheader = remember { mutableStateOf(false) }&#10;    val isLoading = loginViewModelState.isLoading&#10;    val scope = CoroutineScope(Dispatchers.Main)&#10;    val snackbarHostState = remember {&#10;        SnackbarHostState()&#10;    }&#10;    ObserveAsEvents(&#10;        flow = SnackbarController.events,&#10;        snackbarHostState&#10;    ) { event -&gt;&#10;        scope.launch {&#10;            snackbarHostState.currentSnackbarData?.dismiss()&#10;            val result  = snackbarHostState.showSnackbar(&#10;                message = event.message,&#10;                duration = SnackbarDuration.Long&#10;            )&#10;            if (result == SnackbarResult.ActionPerformed) {&#10;                event.action?.action?.invoke()&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        delay(1000)&#10;        onDataLoaded()&#10;        isSplashScreenClosed.value = true&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onLoginEvent(LoginEvent.BeginAuthStateListener)&#10;    }&#10;&#10;&#10;    ObserveLoginState(&#10;        isLoggedIn = isUserLoggedIn,&#10;        isEmailVerified = isEmailVerified,&#10;        isUserAnonymous = isUserAnonymous,&#10;        navigateToDreamJournalScreen = navigateToDreamJournalScreen,&#10;    )&#10;&#10;    Box {&#10;        Image(&#10;            painter = painterResource(Res.drawable.blue_lighthouse),&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop,&#10;            contentDescription = &quot;Dream Journal AI&quot;,&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = {&#10;            SnackbarHost(&#10;                hostState = snackbarHostState,&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { it -&gt;&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .fillMaxSize()&#10;                .navigationBarsPadding(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;&#10;            Box(&#10;                contentAlignment = Alignment.Center,&#10;                modifier = Modifier&#10;                    .padding(top = 64.dp, bottom = 16.dp, start = 8.dp, end = 8.dp)&#10;                    .fillMaxWidth()&#10;                    .verticalScroll(rememberScrollState())&#10;                    .background(&#10;                        color = LightBlack.copy(alpha = 0.7f),&#10;                        shape = RoundedCornerShape(16.dp)&#10;                    )&#10;            ) {&#10;                //invisible text font 32.sp and 16 padding filler&#10;                Text(&#10;                    text = &quot;Dream Journal AI&quot;,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    style = TextStyle(&#10;                        color = Color.Transparent,&#10;                        fontSize = 32.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                if (isSplashScreenClosed.value){&#10;                    TypewriterText(&#10;                        text = if (visible.value) titleText.value else &quot;Dream Journal AI&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        style = TextStyle(&#10;                            color = transition.animateColor(label = &quot;&quot;) { if (it) Color.White else Color.Transparent }.value,&#10;                            fontSize = 32.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        ),&#10;                        textAlign = TextAlign.Center,&#10;                        animationDuration = 5000,&#10;                        onAnimationComplete = {&#10;                            scope.launch {&#10;                                if (!showLoginLayout.value) {&#10;                                    loginViewModelState.isLoginLayout.value = true&#10;                                }&#10;                                showLoginLayout.value = true&#10;                                delay(1000)  // Delay for 1 second&#10;                                visible.value = !visible.value&#10;                                if (visible.value) {&#10;                                    titleText.value = &quot;Dream Journal AI&quot;&#10;                                    showSubheader.value = true&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            if (showLoginLayout.value) {&#10;                SignupLoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    onLoginEvent = { onLoginEvent(it) },&#10;                    onSignupEvent = { onSignupEvent(it) },&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            MyGoogleSignInButton(&#10;                { account -&gt;&#10;                    val googleCredential = dev.gitlive.firebase.auth.GoogleAuthProvider.credential(&#10;                        idToken = account.idToken,&#10;                        accessToken = account.accessTokenOrNonce&#10;                    )&#10;                    onLoginEvent(LoginEvent.SignInWithGoogle(googleCredential))&#10;                },&#10;                {&#10;                    onLoginEvent(LoginEvent.ToggleLoading(false))&#10;                    println(&quot;Google sign-in error: $it&quot;)&#10;                },&#10;                isLoading&#10;            )&#10;&#10;            if (!isUserAnonymous) {&#10;                AnonymousButton(&#10;                    modifier = Modifier&#10;                        .padding(bottom = 8.dp, top = 8.dp, start = 16.dp, end = 16.dp),&#10;                    isVisible = true,&#10;                    onClick = {&#10;                        onSignupEvent(SignupEvent.AnonymousSignIn)&#10;                    },&#10;                    isEnabled = !isLoading&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.padding(16.dp))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_onboarding.presentation&#10;&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.animateColor&#10;import androidx.compose.animation.core.updateTransition&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.dream_account.MyGoogleSignInButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.AnonymousButton&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.ObserveLoginState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.components.SignupLoginLayout&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.LoginEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.events.SignupEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModelState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.jetbrains.compose.resources.painterResource&#10;import kotlin.uuid.ExperimentalUuidApi&#10;&#10;&#10;@OptIn(ExperimentalUuidApi::class)&#10;@ExperimentalAnimationApi&#10;@Composable&#10;fun OnboardingScreen(&#10;    loginViewModelState: LoginViewModelState,&#10;    signupViewModelState: SignupViewModelState,&#10;    navigateToDreamJournalScreen: () -&gt; Unit,&#10;    onLoginEvent: (LoginEvent) -&gt; Unit,&#10;    onSignupEvent: (SignupEvent) -&gt; Unit,&#10;    onDataLoaded: () -&gt; Unit,&#10;) {&#10;    val isUserAnonymous = loginViewModelState.isUserAnonymous&#10;    val isUserLoggedIn = loginViewModelState.isLoggedIn&#10;    val isEmailVerified = loginViewModelState.isEmailVerified&#10;    val showLoginLayout = remember { mutableStateOf(false) }&#10;    val isSplashScreenClosed = remember { mutableStateOf(false) }&#10;    val titleText = remember { mutableStateOf(&quot;Welcome Dreamer!&quot;) }&#10;    val visible = remember { mutableStateOf(true) }&#10;    val transition = updateTransition(visible.value, label = &quot;&quot;)&#10;    val showSubheader = remember { mutableStateOf(false) }&#10;    val isLoading = loginViewModelState.isLoading&#10;    val scope = rememberCoroutineScope()&#10;    val snackbarHostState = remember {&#10;        SnackbarHostState()&#10;    }&#10;    ObserveAsEvents(&#10;        flow = SnackbarController.events,&#10;        snackbarHostState&#10;    ) { event -&gt;&#10;        scope.launch {&#10;            snackbarHostState.currentSnackbarData?.dismiss()&#10;            val result  = snackbarHostState.showSnackbar(&#10;                message = event.message,&#10;                duration = SnackbarDuration.Long&#10;            )&#10;            if (result == SnackbarResult.ActionPerformed) {&#10;                event.action?.action?.invoke()&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        delay(1000)&#10;        onDataLoaded()&#10;        isSplashScreenClosed.value = true&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onLoginEvent(LoginEvent.BeginAuthStateListener)&#10;    }&#10;&#10;&#10;    ObserveLoginState(&#10;        isLoggedIn = isUserLoggedIn,&#10;        isEmailVerified = isEmailVerified,&#10;        isUserAnonymous = isUserAnonymous,&#10;        navigateToDreamJournalScreen = navigateToDreamJournalScreen,&#10;    )&#10;&#10;    Box {&#10;        Image(&#10;            painter = painterResource(Res.drawable.blue_lighthouse),&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop,&#10;            contentDescription = &quot;Dream Journal AI&quot;,&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = {&#10;            SnackbarHost(&#10;                hostState = snackbarHostState,&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { it -&gt;&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .fillMaxSize()&#10;                .navigationBarsPadding(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;&#10;            Box(&#10;                contentAlignment = Alignment.Center,&#10;                modifier = Modifier&#10;                    .padding(top = 64.dp, bottom = 16.dp, start = 8.dp, end = 8.dp)&#10;                    .fillMaxWidth()&#10;                    .verticalScroll(rememberScrollState())&#10;                    .background(&#10;                        color = LightBlack.copy(alpha = 0.7f),&#10;                        shape = RoundedCornerShape(16.dp)&#10;                    )&#10;            ) {&#10;                //invisible text font 32.sp and 16 padding filler&#10;                Text(&#10;                    text = &quot;Dream Journal AI&quot;,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    style = TextStyle(&#10;                        color = Color.Transparent,&#10;                        fontSize = 32.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    ),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                if (isSplashScreenClosed.value){&#10;                    TypewriterText(&#10;                        text = if (visible.value) titleText.value else &quot;Dream Journal AI&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        style = TextStyle(&#10;                            color = transition.animateColor(label = &quot;&quot;) { if (it) Color.White else Color.Transparent }.value,&#10;                            fontSize = 32.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        ),&#10;                        textAlign = TextAlign.Center,&#10;                        animationDuration = 5000,&#10;                        onAnimationComplete = {&#10;                            scope.launch {&#10;                                if (!showLoginLayout.value) {&#10;                                    onLoginEvent(LoginEvent.ShowLoginLayout)&#10;                                }&#10;                                showLoginLayout.value = true&#10;                                delay(1000)  // Delay for 1 second&#10;                                visible.value = !visible.value&#10;                                if (visible.value) {&#10;                                    titleText.value = &quot;Dream Journal AI&quot;&#10;                                    showSubheader.value = true&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            if (showLoginLayout.value) {&#10;                SignupLoginLayout(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    onLoginEvent = { onLoginEvent(it) },&#10;                    onSignupEvent = { onSignupEvent(it) },&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            MyGoogleSignInButton(&#10;                { account -&gt;&#10;                    val googleCredential = dev.gitlive.firebase.auth.GoogleAuthProvider.credential(&#10;                        idToken = account.idToken,&#10;                        accessToken = account.accessTokenOrNonce&#10;                    )&#10;                    onLoginEvent(LoginEvent.SignInWithGoogle(googleCredential))&#10;                },&#10;                {&#10;                    onLoginEvent(LoginEvent.ToggleLoading(false))&#10;                    println(&quot;Google sign-in error: $it&quot;)&#10;                },&#10;                isLoading&#10;            )&#10;&#10;            if (!isUserAnonymous) {&#10;                AnonymousButton(&#10;                    modifier = Modifier&#10;                        .padding(bottom = 8.dp, top = 8.dp, start = 16.dp, end = 16.dp),&#10;                    isVisible = true,&#10;                    onClick = {&#10;                        onSignupEvent(SignupEvent.AnonymousSignIn)&#10;                    },&#10;                    isEnabled = !isLoading&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.padding(16.dp))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_statistics/presentation/DreamStatisticScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_statistics/presentation/DreamStatisticScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_statistics.presentation&#10;&#10;&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.StatisticEvent&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.DreamChartBarChart&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.DreamStatisticScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.TopSixDreamWordPieChart&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.ArcRotationAnimation&#10;&#10;@Composable&#10;fun DreamStatisticScreen(&#10;    dreamStatisticScreenState: DreamStatisticScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (StatisticEvent) -&gt; Unit&#10;) {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    LaunchedEffect(key1 = Unit) {&#10;        onEvent(StatisticEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamStatisticScreenTopBar(mainScreenViewModelState = mainScreenViewModelState)&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        if (dreamStatisticScreenState.dreams.isEmpty() ||&#10;            dreamStatisticScreenState.isDreamWordFilterLoading&#10;        ) {&#10;            Box(&#10;                contentAlignment = Alignment.Center,&#10;                modifier = Modifier&#10;                    .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                    .dynamicBottomNavigationPadding()&#10;                    .fillMaxSize()&#10;            ){&#10;                ArcRotationAnimation(infiniteTransition)&#10;            }&#10;        } else {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                    .dynamicBottomNavigationPadding()&#10;                    .verticalScroll(rememberScrollState())&#10;            ) {&#10;                Spacer(modifier = Modifier.height(0.dp))&#10;                TopSixDreamWordPieChart(dreamStatisticScreenState = dreamStatisticScreenState)&#10;                DreamChartBarChart(dreamStatisticScreenState = dreamStatisticScreenState)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_statistics.presentation&#10;&#10;&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.StatisticEvent&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.DreamChartBarChart&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.DreamStatisticScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components.TopSixDreamWordPieChart&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.ArcRotationAnimation&#10;&#10;@Composable&#10;fun DreamStatisticScreen(&#10;    dreamStatisticScreenState: DreamStatisticScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (StatisticEvent) -&gt; Unit,&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    LaunchedEffect(key1 = Unit) {&#10;        onEvent(StatisticEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamStatisticScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        if (dreamStatisticScreenState.dreams.isEmpty() ||&#10;            dreamStatisticScreenState.isDreamWordFilterLoading&#10;        ) {&#10;            Box(&#10;                contentAlignment = Alignment.Center,&#10;                modifier = Modifier&#10;                    .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                    .dynamicBottomNavigationPadding()&#10;                    .fillMaxSize()&#10;            ){&#10;                ArcRotationAnimation(infiniteTransition)&#10;            }&#10;        } else {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                    .dynamicBottomNavigationPadding()&#10;                    .verticalScroll(rememberScrollState())&#10;            ) {&#10;                Spacer(modifier = Modifier.height(0.dp))&#10;                TopSixDreamWordPieChart(dreamStatisticScreenState = dreamStatisticScreenState)&#10;                DreamChartBarChart(dreamStatisticScreenState = dreamStatisticScreenState)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_statistics/presentation/components/DreamStatisticScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_statistics/presentation/components/DreamStatisticScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamStatisticScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Statistics&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_statistics.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamStatisticScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Statistics&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;Statistics: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        logger.d { &quot;Store products available: ${storeProducts.map { it.id }}&quot; }&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_symbols/presentation/SymbolScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_symbols/presentation/SymbolScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_symbols.presentation&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.lexilabs.basic.ads.DependsOnGoogleMobileAds&#10;import app.lexilabs.basic.ads.composable.RewardedAd&#10;import coil3.compose.LocalPlatformContext&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.domain.SymbolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.BuySymbolBottomSheet&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.DictionaryWordDrawer&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.DictionaryWordItem&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.SymbolScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.SymbolScreenState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;&#10;@OptIn(DependsOnGoogleMobileAds::class)&#10;@Composable&#10;fun SymbolScreen(&#10;    symbolScreenState: SymbolScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    searchTextFieldState: TextFieldState,&#10;    onEvent: (SymbolEvent) -&gt; Unit = {},&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;) {&#10;    val alphabet = remember { ('A'..'Z').toList() }&#10;    var selectedHeader by remember { mutableStateOf('A') }&#10;    val screenWidth = remember { mutableIntStateOf(0) } // to store screen width&#10;    val scope = rememberCoroutineScope()&#10;    val tokens = symbolScreenState.dreamTokens&#10;&#10;    LaunchedEffect(Unit) {&#10;        onEvent(SymbolEvent.GetDreamTokens)&#10;        onEvent(SymbolEvent.LoadWords)&#10;        onEvent(SymbolEvent.GetUnlockedWords)&#10;        onEvent(SymbolEvent.FilterByLetter('A'))&#10;        onMainEvent(MainScreenEvent.SetSearchingState(false))&#10;    }&#10;&#10;&#10;    Scaffold(&#10;        snackbarHost = {&#10;            SnackbarHost(symbolScreenState.snackBarHostState.value)&#10;        },&#10;        topBar = {&#10;            SymbolScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                symbolScreenState = symbolScreenState,&#10;                searchedTextFieldState = searchTextFieldState,&#10;                onDictionaryEvent = onEvent&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        if (!symbolScreenState.isClickedWordUnlocked &amp;&amp; symbolScreenState.bottomSheetState.value) {&#10;            BuySymbolBottomSheet(&#10;                title = symbolScreenState.clickedSymbol.word,&#10;                onAdClick = {&#10;                    scope.launch {&#10;                        onEvent(&#10;                            SymbolEvent.AdSymbolToggle(true)&#10;                        )&#10;                    }&#10;                },&#10;                onDreamTokenClick = {&#10;                    onEvent(&#10;                        SymbolEvent.ClickBuySymbol(&#10;                            dictionaryWord = symbolScreenState.clickedSymbol,&#10;                            isAd = false&#10;                        )&#10;                    )&#10;                },&#10;                onClickOutside = {&#10;                    symbolScreenState.bottomSheetState.value = false&#10;                },&#10;                token = tokens,&#10;                amount = symbolScreenState.clickedSymbol.cost&#10;            )&#10;        } else if (symbolScreenState.isClickedWordUnlocked &amp;&amp; symbolScreenState.bottomSheetState.value) {&#10;            DictionaryWordDrawer(&#10;                title = symbolScreenState.clickedSymbol.word,&#10;                definition = symbolScreenState.clickedSymbol.definition,&#10;                onClickOutside = {&#10;                    symbolScreenState.bottomSheetState.value = false&#10;                },&#10;            )&#10;        }&#10;        if(symbolScreenState.isAdSymbol){&#10;            RewardedAd(&#10;                activity = LocalPlatformContext.current,&#10;                adUnitId = &quot;ca-app-pub-8710979310678386/8178296701&quot;,&#10;                onRewardEarned = {&#10;                    onEvent(&#10;                        SymbolEvent.ClickBuySymbol(&#10;                            dictionaryWord = symbolScreenState.clickedSymbol,&#10;                            isAd = true&#10;                        )&#10;                    )&#10;                    onEvent(SymbolEvent.AdSymbolToggle(false))&#10;                },&#10;                onDismissed = {&#10;                    onEvent(SymbolEvent.AdSymbolToggle(false))&#10;                }&#10;            )&#10;        }&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize()&#10;        ) {&#10;            val processedWords = symbolScreenState.filteredWordsByLetter.map { wordItem -&gt;&#10;                wordItem.copy(&#10;                    isUnlocked = wordItem.isUnlocked || symbolScreenState.unlockedWords.contains(&#10;                        wordItem.word&#10;                    ),&#10;                    cost = if (symbolScreenState.unlockedWords.contains(wordItem.word)) 0 else wordItem.cost&#10;                )&#10;            }&#10;            if (symbolScreenState.isSearching) {&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    contentPadding = PaddingValues(bottom = 32.dp, top = 8.dp)&#10;                ) {&#10;                    items(symbolScreenState.filteredSearchedWords) { wordItem -&gt;&#10;                        DictionaryWordItem(&#10;                            wordItem = wordItem,&#10;                            onWordClick = { onEvent(SymbolEvent.ClickWord(wordItem)) }&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .background(color = DarkBlue.copy(alpha = 0.5f))&#10;                        .onGloballyPositioned { layoutCoordinates -&gt;&#10;                            screenWidth.intValue = layoutCoordinates.size.width // Store the width&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            detectHorizontalDragGestures { change, _ -&gt;&#10;                                val positionX = change.position.x&#10;                                val letterWidth = screenWidth.intValue / alphabet.size.toFloat()&#10;                                val index =&#10;                                    (positionX / letterWidth).coerceIn(&#10;                                        0f,&#10;                                        (alphabet.size - 1).toFloat()&#10;                                    )&#10;                                val letter = alphabet[index.toInt()]&#10;                                if (selectedHeader != letter) {&#10;                                    selectedHeader = letter&#10;                                    onEvent(SymbolEvent.FilterByLetter(letter))&#10;                                    onEvent(SymbolEvent.CancelVibration)&#10;                                    onEvent(SymbolEvent.TriggerVibration)&#10;                                }&#10;                            }&#10;                        }&#10;                        .padding(horizontal = 2.dp)&#10;                ) {&#10;                    alphabet.forEach { letter -&gt;&#10;                        Text(&#10;                            text = letter.toString(),&#10;                            modifier = Modifier&#10;                                .animateContentSize { _, _ -&gt; }&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    onEvent(SymbolEvent.TriggerVibration)&#10;                                    selectedHeader = letter&#10;                                    onEvent(SymbolEvent.FilterByLetter(letter))&#10;                                }&#10;                                .scale(if (letter == selectedHeader) 1.5f else 1f) // Slightly scale up the selected letter&#10;                                .align(Alignment.CenterVertically),&#10;                            textAlign = TextAlign.Center,&#10;                            fontSize = 10.sp,&#10;                            fontWeight = if (letter == selectedHeader) FontWeight.SemiBold else FontWeight.Normal,&#10;                            color = if (letter == selectedHeader) Color.White else Color.White.copy(&#10;                                alpha = 0.5f&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    contentPadding = PaddingValues(bottom = 32.dp, top = 8.dp)&#10;                ) {&#10;                    items(processedWords) { wordItem -&gt;&#10;                        DictionaryWordItem(&#10;                            wordItem = wordItem,&#10;                            onWordClick = { onEvent(SymbolEvent.ClickWord(wordItem)) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_symbols.presentation&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.lexilabs.basic.ads.DependsOnGoogleMobileAds&#10;import app.lexilabs.basic.ads.composable.RewardedAd&#10;import coil3.compose.LocalPlatformContext&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.domain.SymbolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.BuySymbolBottomSheet&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.DictionaryWordDrawer&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.DictionaryWordItem&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components.SymbolScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.SymbolScreenState&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;&#10;@OptIn(DependsOnGoogleMobileAds::class)&#10;@Composable&#10;fun SymbolScreen(&#10;    symbolScreenState: SymbolScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    searchTextFieldState: TextFieldState,&#10;    onEvent: (SymbolEvent) -&gt; Unit = {},&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;) {&#10;    val alphabet = remember { ('A'..'Z').toList() }&#10;    var selectedHeader by remember { mutableStateOf('A') }&#10;    val screenWidth = remember { mutableIntStateOf(0) } // to store screen width&#10;    val scope = rememberCoroutineScope()&#10;    val tokens = symbolScreenState.dreamTokens&#10;&#10;    LaunchedEffect(Unit) {&#10;        onEvent(SymbolEvent.GetDreamTokens)&#10;        onEvent(SymbolEvent.LoadWords)&#10;        onEvent(SymbolEvent.GetUnlockedWords)&#10;        onEvent(SymbolEvent.FilterByLetter('A'))&#10;        onMainEvent(MainScreenEvent.SetSearchingState(false))&#10;    }&#10;&#10;&#10;    Scaffold(&#10;        snackbarHost = {&#10;            SnackbarHost(symbolScreenState.snackBarHostState.value)&#10;        },&#10;        topBar = {&#10;            SymbolScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                symbolScreenState = symbolScreenState,&#10;                searchedTextFieldState = searchTextFieldState,&#10;                onDictionaryEvent = onEvent,&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        if (!symbolScreenState.isClickedWordUnlocked &amp;&amp; symbolScreenState.bottomSheetState.value) {&#10;            BuySymbolBottomSheet(&#10;                title = symbolScreenState.clickedSymbol.word,&#10;                onAdClick = {&#10;                    scope.launch {&#10;                        onEvent(&#10;                            SymbolEvent.AdSymbolToggle(true)&#10;                        )&#10;                    }&#10;                },&#10;                onDreamTokenClick = {&#10;                    onEvent(&#10;                        SymbolEvent.ClickBuySymbol(&#10;                            dictionaryWord = symbolScreenState.clickedSymbol,&#10;                            isAd = false&#10;                        )&#10;                    )&#10;                },&#10;                onClickOutside = {&#10;                    symbolScreenState.bottomSheetState.value = false&#10;                },&#10;                token = tokens,&#10;                amount = symbolScreenState.clickedSymbol.cost&#10;            )&#10;        } else if (symbolScreenState.isClickedWordUnlocked &amp;&amp; symbolScreenState.bottomSheetState.value) {&#10;            DictionaryWordDrawer(&#10;                title = symbolScreenState.clickedSymbol.word,&#10;                definition = symbolScreenState.clickedSymbol.definition,&#10;                onClickOutside = {&#10;                    symbolScreenState.bottomSheetState.value = false&#10;                },&#10;            )&#10;        }&#10;        if(symbolScreenState.isAdSymbol){&#10;            RewardedAd(&#10;                activity = LocalPlatformContext.current,&#10;                adUnitId = &quot;ca-app-pub-8710979310678386/8178296701&quot;,&#10;                onRewardEarned = {&#10;                    onEvent(&#10;                        SymbolEvent.ClickBuySymbol(&#10;                            dictionaryWord = symbolScreenState.clickedSymbol,&#10;                            isAd = true&#10;                        )&#10;                    )&#10;                    onEvent(SymbolEvent.AdSymbolToggle(false))&#10;                },&#10;                onDismissed = {&#10;                    onEvent(SymbolEvent.AdSymbolToggle(false))&#10;                }&#10;            )&#10;        }&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(top = it.calculateTopPadding(), bottom = bottomPaddingValue)&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize()&#10;        ) {&#10;            val processedWords = symbolScreenState.filteredWordsByLetter.map { wordItem -&gt;&#10;                wordItem.copy(&#10;                    isUnlocked = wordItem.isUnlocked || symbolScreenState.unlockedWords.contains(&#10;                        wordItem.word&#10;                    ),&#10;                    cost = if (symbolScreenState.unlockedWords.contains(wordItem.word)) 0 else wordItem.cost&#10;                )&#10;            }&#10;            if (symbolScreenState.isSearching) {&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    contentPadding = PaddingValues(bottom = 32.dp, top = 8.dp)&#10;                ) {&#10;                    items(symbolScreenState.filteredSearchedWords) { wordItem -&gt;&#10;                        DictionaryWordItem(&#10;                            wordItem = wordItem,&#10;                            onWordClick = { onEvent(SymbolEvent.ClickWord(wordItem)) }&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .background(color = DarkBlue.copy(alpha = 0.5f))&#10;                        .onGloballyPositioned { layoutCoordinates -&gt;&#10;                            screenWidth.intValue = layoutCoordinates.size.width // Store the width&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            detectHorizontalDragGestures { change, _ -&gt;&#10;                                val positionX = change.position.x&#10;                                val letterWidth = screenWidth.intValue / alphabet.size.toFloat()&#10;                                val index =&#10;                                    (positionX / letterWidth).coerceIn(&#10;                                        0f,&#10;                                        (alphabet.size - 1).toFloat()&#10;                                    )&#10;                                val letter = alphabet[index.toInt()]&#10;                                if (selectedHeader != letter) {&#10;                                    selectedHeader = letter&#10;                                    onEvent(SymbolEvent.FilterByLetter(letter))&#10;                                    onEvent(SymbolEvent.CancelVibration)&#10;                                    onEvent(SymbolEvent.TriggerVibration)&#10;                                }&#10;                            }&#10;                        }&#10;                        .padding(horizontal = 2.dp)&#10;                ) {&#10;                    alphabet.forEach { letter -&gt;&#10;                        Text(&#10;                            text = letter.toString(),&#10;                            modifier = Modifier&#10;                                .animateContentSize { _, _ -&gt; }&#10;                                .weight(1f)&#10;                                .clickable {&#10;                                    onEvent(SymbolEvent.TriggerVibration)&#10;                                    selectedHeader = letter&#10;                                    onEvent(SymbolEvent.FilterByLetter(letter))&#10;                                }&#10;                                .scale(if (letter == selectedHeader) 1.5f else 1f) // Slightly scale up the selected letter&#10;                                .align(Alignment.CenterVertically),&#10;                            textAlign = TextAlign.Center,&#10;                            fontSize = 10.sp,&#10;                            fontWeight = if (letter == selectedHeader) FontWeight.SemiBold else FontWeight.Normal,&#10;                            color = if (letter == selectedHeader) Color.White else Color.White.copy(&#10;                                alpha = 0.5f&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                LazyColumn(&#10;                    modifier = Modifier.weight(1f),&#10;                    contentPadding = PaddingValues(bottom = 32.dp, top = 8.dp)&#10;                ) {&#10;                    items(processedWords) { wordItem -&gt;&#10;                        DictionaryWordItem(&#10;                            wordItem = wordItem,&#10;                            onWordClick = { onEvent(SymbolEvent.ClickWord(wordItem)) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_symbols/presentation/components/SymbolScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_symbols/presentation/components/SymbolScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.domain.SymbolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.SymbolScreenState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SymbolScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    symbolScreenState: SymbolScreenState,&#10;    searchedTextFieldState: TextFieldState,&#10;    onDictionaryEvent: (SymbolEvent) -&gt; Unit = {},&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (!symbolScreenState.isSearching) {&#10;                    Text(&#10;                        text = &quot;Symbols&quot;,&#10;                        color = White,&#10;                        modifier = Modifier&#10;                            .align(Alignment.Center)&#10;                    )&#10;                }&#10;                AnimatedVisibility(&#10;                    visible = symbolScreenState.isSearching,&#10;                    //slide from left to right&#10;                    enter = slideInHorizontally(&#10;                        initialOffsetX = { it },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    exit = slideOutHorizontally(&#10;                        targetOffsetX = { -it - 400 },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;&#10;                ) {&#10;                    TransparentHintTextField(&#10;                        textFieldState = searchedTextFieldState,&#10;                        hint = &quot;Search symbol...&quot;,&#10;                        isHintVisible = searchedTextFieldState.text.toString().isEmpty(),&#10;                        singleLine = true,&#10;                        textStyle = MaterialTheme.typography.headlineSmall.copy(White),&#10;                        modifier = Modifier&#10;                            .clip(RoundedCornerShape(10.dp))&#10;                            .background(&#10;                                color = White.copy(&#10;                                    alpha = 0.2f&#10;                                )&#10;                            )&#10;                            .padding(4.dp, 2.dp, 0.dp, 2.dp)&#10;                            .fillMaxWidth()&#10;                            .padding(4.dp)&#10;                            .focusable(),&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            if (!symbolScreenState.isSearching) {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDictionaryEvent(SymbolEvent.ListenForSearchChange)&#10;                        onDictionaryEvent(SymbolEvent.SetSearchingState(true))&#10;                    },&#10;                    content = {&#10;                        Icon(&#10;                            Icons.Filled.Search,&#10;                            contentDescription = &quot;Search&quot;,&#10;                            tint = White&#10;                        )&#10;                    }&#10;                )&#10;            } else {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDictionaryEvent(SymbolEvent.SetSearchingState(false))&#10;                    },&#10;                    content = {&#10;                        Icon(&#10;                            Icons.Filled.Close,&#10;                            contentDescription = &quot;Close&quot;,&#10;                            tint = White&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_symbols.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.focusable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.domain.SymbolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.SymbolScreenState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SymbolScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    symbolScreenState: SymbolScreenState,&#10;    searchedTextFieldState: TextFieldState,&#10;    onDictionaryEvent: (SymbolEvent) -&gt; Unit = {},&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (!symbolScreenState.isSearching) {&#10;                    Text(&#10;                        text = &quot;Symbols&quot;,&#10;                        color = White,&#10;                        modifier = Modifier&#10;                            .align(Alignment.Center)&#10;                    )&#10;                }&#10;                AnimatedVisibility(&#10;                    visible = symbolScreenState.isSearching,&#10;                    //slide from left to right&#10;                    enter = slideInHorizontally(&#10;                        initialOffsetX = { it },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    exit = slideOutHorizontally(&#10;                        targetOffsetX = { -it - 400 },&#10;                        animationSpec = tween(500)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;&#10;                ) {&#10;                    TransparentHintTextField(&#10;                        textFieldState = searchedTextFieldState,&#10;                        hint = &quot;Search symbol...&quot;,&#10;                        isHintVisible = searchedTextFieldState.text.toString().isEmpty(),&#10;                        singleLine = true,&#10;                        textStyle = MaterialTheme.typography.headlineSmall.copy(White),&#10;                        modifier = Modifier&#10;                            .clip(RoundedCornerShape(10.dp))&#10;                            .background(&#10;                                color = White.copy(&#10;                                    alpha = 0.2f&#10;                                )&#10;                            )&#10;                            .padding(4.dp, 2.dp, 0.dp, 2.dp)&#10;                            .fillMaxWidth()&#10;                            .padding(4.dp)&#10;                            .focusable(),&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;Symbols: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            if (!symbolScreenState.isSearching) {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDictionaryEvent(SymbolEvent.ListenForSearchChange)&#10;                        onDictionaryEvent(SymbolEvent.SetSearchingState(true))&#10;                    },&#10;                    content = {&#10;                        Icon(&#10;                            Icons.Filled.Search,&#10;                            contentDescription = &quot;Search&quot;,&#10;                            tint = White&#10;                        )&#10;                    }&#10;                )&#10;            } else {&#10;                IconButton(&#10;                    onClick = {&#10;                        onDictionaryEvent(SymbolEvent.SetSearchingState(false))&#10;                    },&#10;                    content = {&#10;                        Icon(&#10;                            Icons.Filled.Close,&#10;                            contentDescription = &quot;Close&quot;,&#10;                            tint = White&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;        modifier = Modifier.dynamicBottomNavigationPadding()&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/components/DreamToolsScreenTopBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/components/DreamToolsScreenTopBar.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamToolsScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Tools&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    mainScreenViewModelState.drawerMain.open()&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.CenterAlignedTopAppBar&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DreamToolsScreenTopBar(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onOpenDrawer: () -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    CenterAlignedTopAppBar(&#10;        title = {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Tools&quot;,&#10;                    color = White,&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                )&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = {&#10;                scope.launch {&#10;                    Logger.d(&quot;TopBar&quot;) { &quot;Tools: Menu icon clicked -&gt; request open drawer&quot; }&#10;                    DrawerController.send(DrawerCommand.Open)&#10;                }&#10;            }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = White&#10;                )&#10;            }&#10;        },&#10;        actions = {&#10;            IconButton(onClick = { /*TODO*/ }) {&#10;                Icon(&#10;                    Icons.Filled.Menu,&#10;                    contentDescription = &quot;Menu&quot;,&#10;                    tint = Color.Transparent&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = DarkBlue.copy(alpha = 0.5f),&#10;            navigationIconContentColor = Color.Black,&#10;            titleContentColor = Color.Black,&#10;            actionIconContentColor = Color.Black&#10;        ),&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/dream_tools_screen/DreamToolsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/dream_tools_screen/DreamToolsScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.dream_tools_screen&#10;&#10;import androidx.compose.animation.AnimatedVisibilityScope&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionScope&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import org.ballistic.dreamjournalai.shared.navigation.ToolRoute&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.components.DreamToolsGrid&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.components.DreamToolsScreenTopBar&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun SharedTransitionScope.DreamToolsScreen(&#10;    animatedVisibilityScope: AnimatedVisibilityScope,&#10;    onNavigate: (ToolRoute) -&gt; Unit,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;) {&#10;    Scaffold(&#10;        topBar = {&#10;            DreamToolsScreenTopBar(mainScreenViewModelState = mainScreenViewModelState)&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        DreamToolsGrid(&#10;            onNavigate = onNavigate,&#10;            animatedVisibilityScope = animatedVisibilityScope,&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize()&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.dream_tools_screen&#10;&#10;import androidx.compose.animation.AnimatedVisibilityScope&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionScope&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import org.ballistic.dreamjournalai.shared.navigation.ToolRoute&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.components.DreamToolsGrid&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.components.DreamToolsScreenTopBar&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun SharedTransitionScope.DreamToolsScreen(&#10;    animatedVisibilityScope: AnimatedVisibilityScope,&#10;    onNavigate: (ToolRoute) -&gt; Unit,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;    Scaffold(&#10;        topBar = {&#10;            DreamToolsScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) {&#10;        DreamToolsGrid(&#10;            onNavigate = onNavigate,&#10;            animatedVisibilityScope = animatedVisibilityScope,&#10;            modifier = Modifier&#10;                .padding(it)&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize()&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/interpret_dreams_screen/components/SelectDreamsPage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_tools/presentation/interpret_dreams_screen/components/SelectDreamsPage.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.interpret_dreams_screen.components&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_tools.domain.event.InterpretDreamsToolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.interpret_dreams_screen.viewmodel.InterpretDreamsScreenState&#10;import kotlin.collections.component1&#10;import kotlin.collections.component2&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun SelectDreamsPage(&#10;    interpretDreamsScreenState: InterpretDreamsScreenState,&#10;    snackbarHostState: SnackbarHostState,&#10;    scope: CoroutineScope,&#10;    chosenDreams: List&lt;Dream&gt;,&#10;    modifier: Modifier = Modifier,&#10;    onEvent: (InterpretDreamsToolEvent) -&gt; Unit&#10;) {&#10;&#10;    LazyColumn(&#10;        modifier = modifier,&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;    ) {&#10;        // Step 1: Parse and Sort Dreams&#10;        val sortedGroupedDreams = interpretDreamsScreenState.dreams&#10;            .mapNotNull { dream -&gt;&#10;                try {&#10;                    val parsedDate = parseCustomDate(dream.date)&#10;                    Pair(parsedDate, dream)&#10;                } catch (e: IllegalArgumentException) {&#10;                    null&#10;                }&#10;            }&#10;            .sortedWith(&#10;                compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                    .thenByDescending { it.second.timestamp }&#10;            )&#10;            .groupBy { it.first }&#10;&#10;        // Step 2: Iterate Through Groups&#10;        sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;            // Sticky Header for the Date&#10;            stickyHeader {&#10;                DateHeader(dateString = formatCustomDate(date))&#10;            }&#10;&#10;&#10;            items(dreams) { (_, dream) -&gt;&#10;                val isDreamChosen = chosenDreams.contains(dream)&#10;                DreamItem(&#10;                    dream = dream,&#10;                    hasBorder = isDreamChosen,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 10.dp)&#10;                        .padding(horizontal = 12.dp),&#10;                    scope = scope,&#10;                    onClick = {&#10;                        onEvent(InterpretDreamsToolEvent.TriggerVibration)&#10;                        val chosenDreamSizeLimit = 15&#10;                        if (chosenDreams.size &gt;= chosenDreamSizeLimit &amp;&amp; !chosenDreams.contains(&#10;                                dream&#10;                            )&#10;                        ) {&#10;                            scope.launch {&#10;                                snackbarHostState.showSnackbar(&#10;                                    &quot;Only 15 dreams can be selected&quot;,&#10;                                    &quot;Dismiss&quot;,&#10;                                    duration = SnackbarDuration.Short&#10;                                )&#10;                            }&#10;                        } else {&#10;                            onEvent(&#10;                                InterpretDreamsToolEvent.ToggleDreamToInterpretationList(&#10;                                    dream&#10;                                )&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_tools.presentation.interpret_dreams_screen.components&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_tools.domain.event.InterpretDreamsToolEvent&#10;import org.ballistic.dreamjournalai.shared.dream_tools.presentation.interpret_dreams_screen.viewmodel.InterpretDreamsScreenState&#10;import kotlin.collections.component1&#10;import kotlin.collections.component2&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun SelectDreamsPage(&#10;    interpretDreamsScreenState: InterpretDreamsScreenState,&#10;    snackbarHostState: SnackbarHostState,&#10;    scope: CoroutineScope,&#10;    chosenDreams: List&lt;Dream&gt;,&#10;    modifier: Modifier = Modifier,&#10;    onEvent: (InterpretDreamsToolEvent) -&gt; Unit&#10;) {&#10;&#10;    LazyColumn(&#10;        modifier = modifier,&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;    ) {&#10;        // Step 1: Parse and Sort Dreams&#10;        val sortedGroupedDreams = interpretDreamsScreenState.dreams&#10;            .mapNotNull { dream -&gt;&#10;                try {&#10;                    val parsedDate = parseCustomDate(dream.date)&#10;                    Pair(parsedDate, dream)&#10;                } catch (e: IllegalArgumentException) {&#10;                    null&#10;                }&#10;            }&#10;            .sortedWith(&#10;                compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                    .thenByDescending { it.second.timestamp }&#10;            )&#10;            .groupBy { it.first }&#10;&#10;        // Step 2: Iterate Through Groups&#10;        sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;            // Sticky Header for the Date&#10;            stickyHeader {&#10;                DateHeader(dateString = formatCustomDate(date))&#10;            }&#10;&#10;&#10;            items(dreams) { (_, dream) -&gt;&#10;                val isDreamChosen = chosenDreams.contains(dream)&#10;                DreamItem(&#10;                    dream = dream,&#10;                    hasBorder = isDreamChosen,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 10.dp)&#10;                        .padding(horizontal = 12.dp),&#10;                    onClick = {&#10;                        onEvent(InterpretDreamsToolEvent.TriggerVibration)&#10;                        val chosenDreamSizeLimit = 15&#10;                        if (chosenDreams.size &gt;= chosenDreamSizeLimit &amp;&amp; !chosenDreams.contains(&#10;                                dream&#10;                            )&#10;                        ) {&#10;                            scope.launch {&#10;                                snackbarHostState.showSnackbar(&#10;                                    &quot;Only 15 dreams can be selected&quot;,&#10;                                    &quot;Dismiss&quot;,&#10;                                    duration = SnackbarDuration.Short&#10;                                )&#10;                            }&#10;                        } else {&#10;                            onEvent(&#10;                                InterpretDreamsToolEvent.ToggleDreamToInterpretationList(&#10;                                    dream&#10;                                )&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/navigation/ScreenGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/navigation/ScreenGraph.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.navigation&#10;&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionLayout&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.toRoute&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.dream_account.AccountSettingsScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.AddEditDreamScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel.AddEditDreamViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.DreamFavoriteScreen&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenImageScreen&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.DreamJournalListScreen&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_maintenance.MaintenanceScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.DreamNightmareScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.DreamStatisticScreen&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.StoreScreen&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel.StoreScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.SymbolScreen&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryScreenViewModel&#10;import org.koin.compose.viewmodel.koinViewModel&#10;import org.koin.core.parameter.parametersOf&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun ScreenGraph(&#10;    navController: NavHostController,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;) {&#10;&#10;    SharedTransitionLayout{&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = Route.DreamJournalScreen,&#10;            modifier = Modifier.fillMaxSize(),&#10;            enterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            exitTransition = { fadeOut(animationSpec = tween(500)) },&#10;            popEnterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            popExitTransition = { fadeOut(animationSpec = tween(500)) }&#10;        ) {&#10;            composable&lt;Route.DreamJournalScreen&gt; {&#10;                val dreamJournalListViewModel = koinViewModel&lt;DreamJournalListViewModel&gt;()&#10;                val searchTextFieldState =&#10;                    dreamJournalListViewModel.searchTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamJournalListState =&#10;                    dreamJournalListViewModel.dreamJournalListState.collectAsStateWithLifecycle().value&#10;                DreamJournalListScreen(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState,&#10;                    dreamJournalListState = dreamJournalListState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onDreamListEvent = { dreamJournalListViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            //store&#10;            composable&lt;Route.StoreScreen&gt; {&#10;                val storeScreenViewModel = koinViewModel&lt;StoreScreenViewModel&gt;()&#10;                val storeScreenViewModelState = storeScreenViewModel.storeScreenViewModelState&#10;                    .collectAsStateWithLifecycle().value&#10;                StoreScreen(&#10;                    storeScreenViewModelState = storeScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onStoreEvent = { storeScreenViewModel.onEvent(it) },&#10;                    navigateToAccountScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.AccountSettings)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AddEditDreamScreen&gt; { backStackEntry -&gt;&#10;                val args = backStackEntry.toRoute&lt;Route.AddEditDreamScreen&gt;()&#10;                val image = args.backgroundID&#10;&#10;                backStackEntry.savedStateHandle[&quot;dreamID&quot;] = args.dreamID&#10;&#10;                val addEditDreamViewModel = koinViewModel&lt;AddEditDreamViewModel&gt;(&#10;                    parameters = { parametersOf(backStackEntry.savedStateHandle) }&#10;                )&#10;&#10;&#10;&#10;                Box(Modifier.fillMaxSize()) {&#10;                    Text(&#10;                        text = &quot;Dream ID: ${backStackEntry.savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;,&#10;                        fontSize = 24.sp,&#10;                        color = Color.Black,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                val addEditDreamState =&#10;                    addEditDreamViewModel.addEditDreamState.collectAsStateWithLifecycle().value&#10;                val dreamTitle =&#10;                    addEditDreamViewModel.titleTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamContent =&#10;                    addEditDreamViewModel.contentTextFieldState.collectAsStateWithLifecycle().value&#10;&#10;                //println(&quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;)&#10;                Logger.d(&quot;ScreenGraph&quot;) { &quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot; }&#10;                AddEditDreamScreen(&#10;                    dreamImage = image,&#10;                    dreamTitleState = dreamTitle,&#10;                    dreamContentState = dreamContent,&#10;                    addEditDreamState = addEditDreamState,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onAddEditDreamEvent = { addEditDreamViewModel.onEvent(it) },&#10;                    animateVisibilityScope = this,&#10;                    onNavigateToDreamJournalScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.DreamJournalScreen)&#10;                    },&#10;                    onImageClick = { imageID -&gt;&#10;                        navController.navigate(&#10;                            Route.FullScreenImageScreen(imageID)&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.FullScreenImageScreen&gt;{ it -&gt;&#10;                val args = it.toRoute&lt;Route.FullScreenImageScreen&gt;()&#10;                val fullScreenViewModel = koinViewModel&lt;FullScreenViewModel&gt;()&#10;&#10;                FullScreenImageScreen(&#10;                    imageID = args.imageID,&#10;                    animatedVisibilityScope = this,&#10;                    onBackPress = {&#10;                        navController.navigateUp()&#10;                    },&#10;                    onFullScreenEvent = {&#10;                        fullScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = { onMainEvent(it) }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Favorites&gt; {&#10;                val dreamFavoriteScreenViewModel = koinViewModel&lt;DreamFavoriteScreenViewModel&gt;()&#10;                val dreamFavoriteScreenState = dreamFavoriteScreenViewModel.dreamFavoriteScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                DreamFavoriteScreen(&#10;                    dreamFavoriteScreenState = dreamFavoriteScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamFavoriteScreenViewModel.onEvent(it) },&#10;                    onMainEvent = onMainEvent,&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AccountSettings&gt; {&#10;                val loginViewModel = koinViewModel&lt;LoginViewModel&gt;()&#10;                val signupViewModel = koinViewModel&lt;SignupViewModel&gt;()&#10;&#10;                val loginViewModelState = loginViewModel.state.collectAsStateWithLifecycle().value&#10;                val signupViewModelState = signupViewModel.state.collectAsStateWithLifecycle().value&#10;&#10;                AccountSettingsScreen(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    navigateToOnboardingScreen = onNavigateToOnboardingScreen,&#10;                    onLoginEvent = { loginViewModel.onEvent(it) },&#10;                    onSignupEvent = { signupViewModel.onEvent(it) },&#10;                    navigateToDreamJournalScreen = {&#10;                        navController.navigate(Route.DreamJournalScreen) {&#10;                            // Clear up to DreamJournalScreen so it becomes the root after login&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                inclusive = true&#10;                            }&#10;                            launchSingleTop = true&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.DreamToolGraphScreen&gt; {&#10;                DreamToolsGraph(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = onMainEvent,&#10;                    onNavigate = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(dreamID = dreamID, backgroundID = backgroundID)&#10;                        ) {&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                saveState = true&#10;                                inclusive = true&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Statistics&gt; {&#10;                val dreamStatisticScreenViewModel = koinViewModel&lt;DreamStatisticScreenViewModel&gt;()&#10;                val dreamStatisticScreenState = dreamStatisticScreenViewModel.dreamStatisticScreen&#10;                    .collectAsStateWithLifecycle()&#10;&#10;                DreamStatisticScreen(&#10;                    dreamStatisticScreenState = dreamStatisticScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = {&#10;                        dreamStatisticScreenViewModel.onEvent(it)&#10;                    }&#10;                )&#10;            }&#10;&#10;            //TODO: This is for notifications&#10;            composable&lt;Route.AboutMeScreen&gt; {&#10;//                val dreamNotificationScreenViewModel = koinViewModel&lt;NotificationScreenViewModel&gt;()&#10;//                val dreamNotificationScreenState =&#10;//                    dreamNotificationScreenViewModel.notificationScreenState&#10;//                        .collectAsStateWithLifecycle()&#10;//&#10;//                DreamNotificationSettingScreen(&#10;//                    mainScreenViewModelState = mainScreenViewModelState,&#10;//                    notificationScreenState = dreamNotificationScreenState.value,&#10;//                    bottomPaddingValue = bottomPaddingValue,&#10;//                ) {&#10;//                    dreamNotificationScreenViewModel.onEvent(it)&#10;//                }&#10;                //TODO implement notifications&#10;                MaintenanceScreen()&#10;            }&#10;&#10;            composable&lt;Route.Nightmares&gt; {&#10;                val dreamNightmareScreenViewModel = koinViewModel&lt;DreamNightmareScreenViewModel&gt;()&#10;                val dreamNightmareScreenState =&#10;                    dreamNightmareScreenViewModel.dreamNightmareScreenState&#10;                        .collectAsStateWithLifecycle()&#10;                DreamNightmareScreen(&#10;                    dreamNightmareScreenState = dreamNightmareScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamNightmareScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Symbol&gt; {&#10;                val dictionaryScreenViewModel = koinViewModel&lt;DictionaryScreenViewModel&gt;()&#10;                val dictionaryScreenState = dictionaryScreenViewModel.symbolScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                val searchTextFieldState = dictionaryScreenViewModel.searchTextFieldState&#10;                    .collectAsStateWithLifecycle()&#10;                SymbolScreen(&#10;                    symbolScreenState = dictionaryScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onEvent = { dictionaryScreenViewModel.onEvent(it) },&#10;                )&#10;            }&#10;&#10;//        composable(route = Screens.DreamSettings.route) {&#10;//            FeatureComingSoonScreen(&#10;//                onNavigateToAboutMeScreen = {&#10;//                    navController.popBackStack()&#10;//                    navController.navigate(Screens.AboutMe.route)&#10;//                }&#10;//            )&#10;//        }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.navigation&#10;&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionLayout&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.toRoute&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.dream_account.AccountSettingsScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.AddEditDreamScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel.AddEditDreamViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.DreamFavoriteScreen&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenImageScreen&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.DreamJournalListScreen&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_maintenance.MaintenanceScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.DreamNightmareScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.DreamStatisticScreen&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.StoreScreen&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel.StoreScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.SymbolScreen&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryScreenViewModel&#10;import org.koin.compose.viewmodel.koinViewModel&#10;import org.koin.core.parameter.parametersOf&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun ScreenGraph(&#10;    navController: NavHostController,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;) {&#10;&#10;    SharedTransitionLayout{&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = Route.DreamJournalScreen,&#10;            modifier = Modifier.fillMaxSize(),&#10;            enterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            exitTransition = { fadeOut(animationSpec = tween(500)) },&#10;            popEnterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            popExitTransition = { fadeOut(animationSpec = tween(500)) }&#10;        ) {&#10;            composable&lt;Route.DreamJournalScreen&gt; {&#10;                val dreamJournalListViewModel = koinViewModel&lt;DreamJournalListViewModel&gt;()&#10;                val searchTextFieldState =&#10;                    dreamJournalListViewModel.searchTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamJournalListState =&#10;                    dreamJournalListViewModel.dreamJournalListState.collectAsStateWithLifecycle().value&#10;                DreamJournalListScreen(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState,&#10;                    dreamJournalListState = dreamJournalListState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onDreamListEvent = { dreamJournalListViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            //store&#10;            composable&lt;Route.StoreScreen&gt; {&#10;                val storeScreenViewModel = koinViewModel&lt;StoreScreenViewModel&gt;()&#10;                val storeScreenViewModelState = storeScreenViewModel.storeScreenViewModelState&#10;                    .collectAsStateWithLifecycle().value&#10;                StoreScreen(&#10;                    storeScreenViewModelState = storeScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onStoreEvent = { storeScreenViewModel.onEvent(it) },&#10;                    navigateToAccountScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.AccountSettings)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AddEditDreamScreen&gt; { backStackEntry -&gt;&#10;                val args = backStackEntry.toRoute&lt;Route.AddEditDreamScreen&gt;()&#10;                val image = args.backgroundID&#10;&#10;                backStackEntry.savedStateHandle[&quot;dreamID&quot;] = args.dreamID&#10;&#10;                val addEditDreamViewModel = koinViewModel&lt;AddEditDreamViewModel&gt;(&#10;                    parameters = { parametersOf(backStackEntry.savedStateHandle) }&#10;                )&#10;&#10;&#10;&#10;                Box(Modifier.fillMaxSize()) {&#10;                    Text(&#10;                        text = &quot;Dream ID: ${backStackEntry.savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;,&#10;                        fontSize = 24.sp,&#10;                        color = Color.Black,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                val addEditDreamState =&#10;                    addEditDreamViewModel.addEditDreamState.collectAsStateWithLifecycle().value&#10;                val dreamTitle =&#10;                    addEditDreamViewModel.titleTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamContent =&#10;                    addEditDreamViewModel.contentTextFieldState.collectAsStateWithLifecycle().value&#10;&#10;                //println(&quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;)&#10;                Logger.d(&quot;ScreenGraph&quot;) { &quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot; }&#10;                AddEditDreamScreen(&#10;                    dreamImage = image,&#10;                    dreamTitleState = dreamTitle,&#10;                    dreamContentState = dreamContent,&#10;                    addEditDreamState = addEditDreamState,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onAddEditDreamEvent = { addEditDreamViewModel.onEvent(it) },&#10;                    animateVisibilityScope = this,&#10;                    onNavigateToDreamJournalScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.DreamJournalScreen)&#10;                    },&#10;                    onImageClick = { imageID -&gt;&#10;                        navController.navigate(&#10;                            Route.FullScreenImageScreen(imageID)&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.FullScreenImageScreen&gt;{ it -&gt;&#10;                val args = it.toRoute&lt;Route.FullScreenImageScreen&gt;()&#10;                val fullScreenViewModel = koinViewModel&lt;FullScreenViewModel&gt;()&#10;&#10;                FullScreenImageScreen(&#10;                    imageID = args.imageID,&#10;                    animatedVisibilityScope = this,&#10;                    onBackPress = {&#10;                        navController.navigateUp()&#10;                    },&#10;                    onFullScreenEvent = {&#10;                        fullScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = { onMainEvent(it) }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Favorites&gt; {&#10;                val dreamFavoriteScreenViewModel = koinViewModel&lt;DreamFavoriteScreenViewModel&gt;()&#10;                val dreamFavoriteScreenState = dreamFavoriteScreenViewModel.dreamFavoriteScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                DreamFavoriteScreen(&#10;                    dreamFavoriteScreenState = dreamFavoriteScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamFavoriteScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AccountSettings&gt; {&#10;                val loginViewModel = koinViewModel&lt;LoginViewModel&gt;()&#10;                val signupViewModel = koinViewModel&lt;SignupViewModel&gt;()&#10;&#10;                val loginViewModelState = loginViewModel.state.collectAsStateWithLifecycle().value&#10;                val signupViewModelState = signupViewModel.state.collectAsStateWithLifecycle().value&#10;&#10;                AccountSettingsScreen(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    navigateToOnboardingScreen = onNavigateToOnboardingScreen,&#10;                    onLoginEvent = { loginViewModel.onEvent(it) },&#10;                    onSignupEvent = { signupViewModel.onEvent(it) },&#10;                    navigateToDreamJournalScreen = {&#10;                        navController.navigate(Route.DreamJournalScreen) {&#10;                            // Clear up to DreamJournalScreen so it becomes the root after login&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                inclusive = true&#10;                            }&#10;                            launchSingleTop = true&#10;                        }&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.DreamToolGraphScreen&gt; {&#10;                DreamToolsGraph(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = onMainEvent,&#10;                    onNavigate = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(dreamID = dreamID, backgroundID = backgroundID)&#10;                        ) {&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                saveState = true&#10;                                inclusive = true&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Statistics&gt; {&#10;                val dreamStatisticScreenViewModel = koinViewModel&lt;DreamStatisticScreenViewModel&gt;()&#10;                val dreamStatisticScreenState = dreamStatisticScreenViewModel.dreamStatisticScreen&#10;                    .collectAsStateWithLifecycle()&#10;&#10;                DreamStatisticScreen(&#10;                    dreamStatisticScreenState = dreamStatisticScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = {&#10;                        dreamStatisticScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            //TODO: This is for notifications&#10;            composable&lt;Route.AboutMeScreen&gt; {&#10;//                val dreamNotificationScreenViewModel = koinViewModel&lt;NotificationScreenViewModel&gt;()&#10;//                val dreamNotificationScreenState =&#10;//                    dreamNotificationScreenViewModel.notificationScreenState&#10;//                        .collectAsStateWithLifecycle()&#10;//&#10;//                DreamNotificationSettingScreen(&#10;//                    mainScreenViewModelState = mainScreenViewModelState,&#10;//                    notificationScreenState = dreamNotificationScreenState.value,&#10;//                    bottomPaddingValue = bottomPaddingValue,&#10;//                ) {&#10;//                    dreamNotificationScreenViewModel.onEvent(it)&#10;//                }&#10;                //TODO implement notifications&#10;                MaintenanceScreen()&#10;            }&#10;&#10;            composable&lt;Route.Nightmares&gt; {&#10;                val dreamNightmareScreenViewModel = koinViewModel&lt;DreamNightmareScreenViewModel&gt;()&#10;                val dreamNightmareScreenState =&#10;                    dreamNightmareScreenViewModel.dreamNightmareScreenState&#10;                        .collectAsStateWithLifecycle()&#10;                DreamNightmareScreen(&#10;                    dreamNightmareScreenState = dreamNightmareScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamNightmareScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Symbol&gt; {&#10;                val dictionaryScreenViewModel = koinViewModel&lt;DictionaryScreenViewModel&gt;()&#10;                val dictionaryScreenState = dictionaryScreenViewModel.symbolScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                val searchTextFieldState = dictionaryScreenViewModel.searchTextFieldState&#10;                    .collectAsStateWithLifecycle()&#10;                SymbolScreen(&#10;                    symbolScreenState = dictionaryScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onEvent = { dictionaryScreenViewModel.onEvent(it) },&#10;                )&#10;            }&#10;&#10;//        composable(route = Screens.DreamSettings.route) {&#10;//            FeatureComingSoonScreen(&#10;//                onNavigateToAboutMeScreen = {&#10;//                    navController.popBackStack()&#10;//                    navController.navigate(Screens.AboutMe.route)&#10;//                }&#10;//            )&#10;//        }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>