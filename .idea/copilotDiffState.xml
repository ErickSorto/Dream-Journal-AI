<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/components/TransparentHintField.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/components/TransparentHintField.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.text.input.InputTransformation&#10;import androidx.compose.foundation.text.input.KeyboardActionHandler&#10;import androidx.compose.foundation.text.input.TextFieldBuffer&#10;import androidx.compose.foundation.text.input.TextFieldLineLimits&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.input.key.key&#10;import androidx.compose.ui.input.key.onPreInterceptKeyBeforeSoftKeyboard&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import co.touchlab.kermit.Logger&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@Composable&#10;fun TransparentHintTextField(&#10;    hint: String,&#10;    modifier: Modifier = Modifier,&#10;    modifier2: Modifier = Modifier,&#10;    onEvent: (AddEditDreamEvent) -&gt; Unit = {},&#10;    isHintVisible: Boolean = true,&#10;    textStyle: TextStyle = TextStyle(),&#10;    singleLine: Boolean = false,&#10;    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,&#10;    keyboardActions: KeyboardActionHandler? = null,&#10;    textFieldState: TextFieldState&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    Logger.d(&quot;TransparentHintTextField&quot;) { &quot;TransparentHintTextField check&quot; }&#10;    Box(modifier = modifier)&#10;    {&#10;        BasicTextField(&#10;            state = textFieldState,&#10;            textStyle = textStyle,&#10;            lineLimits = if (singleLine) TextFieldLineLimits.SingleLine else TextFieldLineLimits.Default,&#10;            scrollState = rememberScrollState(),&#10;            keyboardOptions = keyboardOptions,&#10;            onKeyboardAction = keyboardActions,&#10;            modifier = modifier2&#10;                .fillMaxWidth(),&#10;            inputTransformation = EventTriggeringTransformation { event -&gt;&#10;                Logger.d(&quot;TransparentHintTextField&quot;) { &quot;EventTriggeringTransformation is actually called&quot; }&#10;                scope.launch {&#10;                    onEvent(event)&#10;                }&#10;            },&#10;            cursorBrush = Brush.verticalGradient(&#10;                colors = listOf(&#10;                    White,&#10;                    White&#10;                )&#10;            ),&#10;        )&#10;&#10;        if (isHintVisible) {&#10;            Text(text = hint, style = textStyle, color = White)&#10;        }&#10;    }&#10;}/**&#10; * Provides a callback when a text field has focus and the back button is pressed.&#10; *&#10; * This is currently useful to work around this bug: https://issuetracker.google.com/issues/312895384&#10; *&#10; * https://stackoverflow.com/a/77043957/2191796&#10; */&#10;fun Modifier.onKeyboardDismiss(handleOnBackPressed: () -&gt; Unit): Modifier =&#10;    @OptIn(ExperimentalComposeUiApi::class)&#10;    this.onPreInterceptKeyBeforeSoftKeyboard {&#10;        if (it.key.keyCode == 17179869184) {&#10;            handleOnBackPressed.invoke()&#10;        }&#10;        true&#10;    }&#10;&#10;class EventTriggeringTransformation(&#10;    private val onEvent: (AddEditDreamEvent) -&gt; Unit&#10;) : InputTransformation {&#10;    override fun TextFieldBuffer.transformInput() {&#10;        Logger.d(&quot;EventTriggeringTransformation&quot;) { &quot;transformInput&quot; }&#10;        onEvent(AddEditDreamEvent.ContentHasChanged)&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.text.input.InputTransformation&#10;import androidx.compose.foundation.text.input.KeyboardActionHandler&#10;import androidx.compose.foundation.text.input.TextFieldBuffer&#10;import androidx.compose.foundation.text.input.TextFieldLineLimits&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.input.key.key&#10;import androidx.compose.ui.input.key.onPreInterceptKeyBeforeSoftKeyboard&#10;import androidx.compose.ui.text.TextStyle&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;&#10;@Composable&#10;fun TransparentHintTextField(&#10;    hint: String,&#10;    modifier: Modifier = Modifier,&#10;    modifier2: Modifier = Modifier,&#10;    onEvent: (AddEditDreamEvent) -&gt; Unit = {},&#10;    isHintVisible: Boolean = true,&#10;    textStyle: TextStyle = TextStyle(),&#10;    singleLine: Boolean = false,&#10;    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,&#10;    keyboardActions: KeyboardActionHandler? = null,&#10;    textFieldState: TextFieldState&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    Box(modifier = modifier)&#10;    {&#10;        BasicTextField(&#10;            state = textFieldState,&#10;            textStyle = textStyle,&#10;            lineLimits = if (singleLine) TextFieldLineLimits.SingleLine else TextFieldLineLimits.Default,&#10;            scrollState = rememberScrollState(),&#10;            keyboardOptions = keyboardOptions,&#10;            onKeyboardAction = keyboardActions,&#10;            modifier = modifier2&#10;                .fillMaxWidth(),&#10;            inputTransformation = EventTriggeringTransformation { event -&gt;&#10;                scope.launch { onEvent(event) }&#10;            },&#10;            cursorBrush = Brush.verticalGradient(&#10;                colors = listOf(&#10;                    White,&#10;                    White&#10;                )&#10;            ),&#10;        )&#10;&#10;        if (isHintVisible) {&#10;            Text(text = hint, style = textStyle, color = White)&#10;        }&#10;    }&#10;}&#10;/**&#10; * Provides a callback when a text field has focus and the back button is pressed.&#10; *&#10; * This is currently useful to work around this bug: https://issuetracker.google.com/issues/312895384&#10; *&#10; * https://stackoverflow.com/a/77043957/2191796&#10; */&#10;fun Modifier.onKeyboardDismiss(handleOnBackPressed: () -&gt; Unit): Modifier =&#10;    @OptIn(ExperimentalComposeUiApi::class)&#10;    this.onPreInterceptKeyBeforeSoftKeyboard {&#10;        if (it.key.keyCode == 17179869184) {&#10;            handleOnBackPressed.invoke()&#10;        }&#10;        true&#10;    }&#10;&#10;class EventTriggeringTransformation(&#10;    private val onEvent: (AddEditDreamEvent) -&gt; Unit&#10;) : InputTransformation {&#10;    override fun TextFieldBuffer.transformInput() {&#10;        onEvent(AddEditDreamEvent.ContentHasChanged)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/pages/DreamPage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/pages/DreamPage.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.pages&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.consumeWindowInsets&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.imePadding&#10;import androidx.compose.foundation.layout.navigationBars&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.unit.dp&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.hint_description&#10;import dreamjournalai.composeapp.shared.generated.resources.hint_title&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.GenerateButtonsLayout&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.onKeyboardDismiss&#10;import org.jetbrains.compose.resources.stringResource&#10;&#10;@Composable&#10;fun DreamPage(&#10;    titleTextFieldState: TextFieldState,&#10;    contentTextFieldState: TextFieldState,&#10;    onAddEditDreamEvent: (AddEditDreamEvent) -&gt; Unit,&#10;    animateToPage: (Int) -&gt; Unit,&#10;    snackBarState: () -&gt; Unit&#10;) {&#10;    val focusManager = LocalFocusManager.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .background(color = Color.Transparent)&#10;            .padding(bottom = 16.dp, start = 16.dp, end = 16.dp, top = 16.dp)&#10;    ) {&#10;        Logger.d(&quot;DreamPage&quot;) { &quot;focusManager: $focusManager&quot; }&#10;        //make content disappear and reappear super quickly&#10;        TransparentHintTextField(&#10;            hint = stringResource(Res.string.hint_title),&#10;            isHintVisible = titleTextFieldState.text.isBlank(),&#10;            singleLine = true,&#10;            textStyle = typography.headlineMedium.copy(color = White),&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(&#10;                    LightBlack.copy(.7f)&#10;                )&#10;                .padding(16.dp)&#10;                .onKeyboardDismiss {&#10;                    focusManager.clearFocus()&#10;                },&#10;            textFieldState = titleTextFieldState,&#10;            onEvent = {&#10;                Logger.d(&quot;DreamPage&quot;) { &quot;onAddEditDreamEvent: $it&quot; }&#10;                onAddEditDreamEvent(it)&#10;            }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(&#10;                    LightBlack.copy(.7f)&#10;                ),&#10;        ) {&#10;            TransparentHintTextField(&#10;                hint = stringResource(Res.string.hint_description),&#10;                isHintVisible = contentTextFieldState.text.isBlank(),&#10;                textStyle = typography.bodyMedium.copy(&#10;                    color = White&#10;                ),&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(8.dp, 8.dp))&#10;                    .padding(12.dp, 16.dp, 12.dp, 0.dp)&#10;                    .weight(1f)&#10;                    .background(&#10;                        Color.Transparent&#10;                    )&#10;                    .onKeyboardDismiss {&#10;                        focusManager.clearFocus()&#10;                    },&#10;                modifier2 = Modifier.fillMaxSize(),&#10;                textFieldState = contentTextFieldState,&#10;                onEvent = {&#10;                    onAddEditDreamEvent(it)&#10;                }&#10;            )&#10;&#10;            GenerateButtonsLayout(&#10;                onAddEditEvent = onAddEditDreamEvent,&#10;                textFieldState = contentTextFieldState,&#10;                snackBarState = {&#10;                    snackBarState()&#10;                },&#10;                animateToPage = { index -&gt;&#10;                    animateToPage(index)&#10;                }&#10;            )&#10;        }&#10;&#10;        //animate slowly&#10;        Spacer(modifier = Modifier.consumeWindowInsets(WindowInsets.navigationBars).imePadding())&#10;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.pages&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.consumeWindowInsets&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.imePadding&#10;import androidx.compose.foundation.layout.navigationBars&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.unit.dp&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.hint_description&#10;import dreamjournalai.composeapp.shared.generated.resources.hint_title&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.GenerateButtonsLayout&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.TransparentHintTextField&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.components.onKeyboardDismiss&#10;import org.jetbrains.compose.resources.stringResource&#10;&#10;@Composable&#10;fun DreamPage(&#10;    titleTextFieldState: TextFieldState,&#10;    contentTextFieldState: TextFieldState,&#10;    onAddEditDreamEvent: (AddEditDreamEvent) -&gt; Unit,&#10;    animateToPage: (Int) -&gt; Unit,&#10;    snackBarState: () -&gt; Unit&#10;) {&#10;    val focusManager = LocalFocusManager.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .background(color = Color.Transparent)&#10;            .padding(bottom = 16.dp, start = 16.dp, end = 16.dp, top = 16.dp)&#10;    ) {&#10;        // reduce log noise&#10;        TransparentHintTextField(&#10;            hint = stringResource(Res.string.hint_title),&#10;            isHintVisible = titleTextFieldState.text.isBlank(),&#10;            singleLine = true,&#10;            textStyle = typography.headlineMedium.copy(color = White),&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(&#10;                    LightBlack.copy(.7f)&#10;                )&#10;                .padding(16.dp)&#10;                .onKeyboardDismiss {&#10;                    focusManager.clearFocus()&#10;                },&#10;            textFieldState = titleTextFieldState,&#10;            onEvent = {&#10;                onAddEditDreamEvent(it)&#10;            }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(&#10;                    LightBlack.copy(.7f)&#10;                ),&#10;        ) {&#10;            TransparentHintTextField(&#10;                hint = stringResource(Res.string.hint_description),&#10;                isHintVisible = contentTextFieldState.text.isBlank(),&#10;                textStyle = typography.bodyMedium.copy(&#10;                    color = White&#10;                ),&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(8.dp, 8.dp))&#10;                    .padding(12.dp, 16.dp, 12.dp, 0.dp)&#10;                    .weight(1f)&#10;                    .background(&#10;                        Color.Transparent&#10;                    )&#10;                    .onKeyboardDismiss {&#10;                        focusManager.clearFocus()&#10;                    },&#10;                modifier2 = Modifier.fillMaxSize(),&#10;                textFieldState = contentTextFieldState,&#10;                onEvent = {&#10;                    onAddEditDreamEvent(it)&#10;                }&#10;            )&#10;&#10;            GenerateButtonsLayout(&#10;                onAddEditEvent = onAddEditDreamEvent,&#10;                textFieldState = contentTextFieldState,&#10;                snackBarState = {&#10;                    snackBarState()&#10;                },&#10;                animateToPage = { index -&gt;&#10;                    animateToPage(index)&#10;                }&#10;            )&#10;        }&#10;&#10;        //animate slowly&#10;        Spacer(modifier = Modifier.consumeWindowInsets(WindowInsets.navigationBars).imePadding())&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/viewmodel/AddEditDreamViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_add_edit/presentation/viewmodel/AddEditDreamViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.ui.text.intl.Locale&#10;import androidx.lifecycle.SavedStateHandle&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.aallam.openai.api.chat.ChatCompletion&#10;import com.aallam.openai.api.chat.ChatCompletionRequest&#10;import com.aallam.openai.api.chat.ChatMessage&#10;import com.aallam.openai.api.chat.ChatRole&#10;import com.aallam.openai.api.image.ImageCreation&#10;import com.aallam.openai.api.image.ImageSize&#10;import com.aallam.openai.api.model.ModelId&#10;import com.aallam.openai.client.OpenAI&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.LocalTime&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import kotlinx.serialization.json.Json&#10;import kotlinx.serialization.json.JsonArray&#10;import org.ballistic.dreamjournalai.shared.core.domain.DictionaryRepository&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.OpenAIApiKeyUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.formatLocalDate&#10;import org.ballistic.dreamjournalai.shared.core.util.formatLocalTime&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.InvalidDreamException&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryWord&#10;import kotlin.time.ExperimentalTime&#10;import kotlin.uuid.ExperimentalUuidApi&#10;import kotlin.uuid.Uuid&#10;&#10;// Get current date&#10;@OptIn(ExperimentalTime::class)&#10;private val now = kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())&#10;private val currentDate = now.date&#10;&#10;// Static sleep and wake times&#10;private val sleepTime = LocalTime(23, 0) // 11 PM&#10;private val wakeTime = LocalTime(7, 0)   // 7 A&#10;private val logger = Logger.withTag(&quot;AddEditViewModel&quot;)&#10;&#10;class AddEditDreamViewModel(&#10;    savedStateHandle: SavedStateHandle,&#10;    private val dreamUseCases: DreamUseCases,&#10;    private val authRepository: AuthRepository,&#10;    private val dictionaryRepository: DictionaryRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;) : ViewModel() {&#10;&#10;     // Lightweight Ktor client for direct OpenAI calls (multiplatform)&#10;        AddEditDreamState(&#10;            authRepository = authRepository&#10;        )&#10;    )&#10;    val addEditDreamState: StateFlow&lt;AddEditDreamState&gt; = _addEditDreamState.asStateFlow()&#10;&#10;    private val _titleTextFieldState = MutableStateFlow(TextFieldState())&#10;    val titleTextFieldState: StateFlow&lt;TextFieldState&gt; = _titleTextFieldState.asStateFlow()&#10;&#10;    private val _contentTextFieldState = MutableStateFlow(TextFieldState())&#10;    val contentTextFieldState: StateFlow&lt;TextFieldState&gt; = _contentTextFieldState.asStateFlow()&#10;&#10;    val flow = Unit&#10;&#10;    // Runtime flag: if GPT Image model calls are failing for this session, skip them and use DALL·E fallback immediately&#10;    private var gptImageTemporarilyDisabled: Boolean = false&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        onEvent(AddEditDreamEvent.OnCleared)&#10;    }&#10;&#10;    init {&#10;        savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)?.let { dreamId -&gt;&#10;            Logger.d(&quot;AddEditDreamViewModel&quot;) { &quot;Dream ID: $dreamId&quot; }&#10;            if (dreamId.isNotEmpty()) {&#10;                viewModelScope.launch {&#10;                    _addEditDreamState.value = addEditDreamState.value.copy(isLoading = true)&#10;                    when (val resource = dreamUseCases.getDream(dreamId)) {&#10;                        is Resource.Success&lt;*&gt; -&gt; {&#10;                            resource.data?.let { dream: Dream -&gt;&#10;                                _titleTextFieldState.value = TextFieldState(&#10;                                    initialText = resource.data.title&#10;                                )&#10;                                _contentTextFieldState.value = TextFieldState(&#10;                                    initialText = resource.data.content&#10;                                )&#10;                                _addEditDreamState.value = AddEditDreamState(&#10;                                    dreamInfo = DreamInfo(&#10;                                        dreamId = dream.id,&#10;                                        dreamUID = dream.uid,&#10;                                        dreamBackgroundImage = dream.isLucid.hashCode(),&#10;                                        dreamIsLucid = dream.isLucid,&#10;                                        dreamIsFavorite = dream.isFavorite,&#10;                                        dreamIsNightmare = dream.isNightmare,&#10;                                        dreamIsRecurring = dream.isRecurring,&#10;                                        dreamIsFalseAwakening = dream.falseAwakening,&#10;                                        dreamSleepTime = dream.sleepTime,&#10;                                        dreamWakeTime = dream.wakeTime,&#10;                                        dreamDate = dream.date,&#10;                                        dreamTimeOfDay = dream.timeOfDay,&#10;                                        dreamLucidity = dream.lucidityRating,&#10;                                        dreamVividness = dream.vividnessRating,&#10;                                        dreamEmotion = dream.moodRating&#10;                                    ),&#10;                                    dreamAIExplanation = DreamAIExplanation(&#10;                                        response = dream.AIResponse,&#10;                                    ),&#10;                                    dreamAIImage = DreamAIImage(&#10;                                        response = dream.generatedImage,&#10;                                    ),&#10;                                    dreamAIQuestionAnswer = DreamQuestionAIAnswer(&#10;                                        response = dream.dreamAIQuestionAnswer,&#10;                                        question = dream.dreamQuestion&#10;                                    ),&#10;                                    dreamAIAdvice = DreamAIAdvice(&#10;                                        response = dream.dreamAIAdvice&#10;                                    ),&#10;                                    dreamAIMoodAnalyser = DreamMoodAIAnalyser(&#10;                                        response = dream.dreamAIMood&#10;                                    ),&#10;                                    dreamAIStory = DreamStoryGeneration(&#10;                                        response = dream.dreamAIStory&#10;                                    ),&#10;                                    dreamGeneratedDetails = DreamAIGeneratedDetails(&#10;                                        response = dream.generatedDetails,&#10;                                    ),&#10;                                    isLoading = false,&#10;                                    authRepository = authRepository&#10;                                )&#10;                            }&#10;                            onEvent(&#10;                                AddEditDreamEvent.ToggleDreamHasChanged(false)&#10;                            )&#10;                            onEvent(AddEditDreamEvent.GetUnlockedWords)&#10;                            onEvent(AddEditDreamEvent.LoadWords)&#10;                            onEvent(AddEditDreamEvent.GetDreamTokens)&#10;                        }&#10;&#10;                        is Resource.Error&lt;*&gt; -&gt; {&#10;                            Logger.e(&quot;AddEditDreamViewModel&quot;) { resource.message.toString() }&#10;&#10;                            viewModelScope.launch{&#10;                                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                    message = &quot;Couldn't get dream :(&quot;,&#10;                                    actionLabel = &quot;Dismiss&quot;&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        is Resource.Loading&lt;*&gt; -&gt; {&#10;                            // handle loading&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                onEvent(AddEditDreamEvent.GetUnlockedWords)&#10;                onEvent(AddEditDreamEvent.LoadWords)&#10;                onEvent(AddEditDreamEvent.GetDreamTokens)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalUuidApi::class, ExperimentalTime::class)&#10;    fun onEvent(event: AddEditDreamEvent) {&#10;        when (event) {&#10;            is AddEditDreamEvent.ChangeDreamBackgroundImage -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamBackgroundImage = event.dreamBackGroundImage&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIResponse -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;&quot;&quot;&#10;            Please interpret the following dream:&#10;            &#10;            ${contentTextFieldState.value.text}&#10;            &#10;            Markdown is supported. Use the following style guidelines:&#10;            - Begin with an introductory paragraph to provide context.&#10;            - Use bullet points (`-`) for key elements.&#10;            - Start each bullet point with a **bolded title** (e.g., `**Title**:`).&#10;            - The title and body text should touch (no blank line between them).&#10;            - Ensure the body text is concise and directly follows the title.&#10;            - Titles should use the same size as the body text but be bold for emphasis.&#10;            - Use short paragraphs to maintain readability on mobile devices.&#10;            - Avoid excessive formatting or long paragraphs for better readability.&#10;        &quot;&quot;&quot;.trimIndent(),&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIExplanation = addEditDreamState.value.dreamAIExplanation.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { response -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIExplanation = addEditDreamState.value.dreamAIExplanation.copy(&#10;                                response = response&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIResponseToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdResponse = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIAdvice -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please give advice that can be obtained or for this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    } &quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.copy(isLoading = isLoading)&#10;                        )&#10;                    },&#10;                    updateResponseState = { advice -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.copy(response = advice)&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIAdviceToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdAdvice = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateMood -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please describe the mood of this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    }&quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIMoodAnalyser = addEditDreamState.value.dreamAIMoodAnalyser.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { mood -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIMoodAnalyser = addEditDreamState.value.dreamAIMoodAnalyser.copy(&#10;                                response = mood&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdMoodToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdMood = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateStory -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please generate a very short story based on this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    } &quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { story -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.copy(&#10;                                response = story&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdStoryToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdStory = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateFromQuestion -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please answer the following question: ${&#10;                        addEditDreamState.value.dreamAIQuestionAnswer.question&#10;                    }&quot; + &quot;as it relates to this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    }&quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { answer -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.copy(&#10;                                response = answer&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdQuestionToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdQuestion = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIImage -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = true)&#10;                viewModelScope.launch {&#10;&#10;                    onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                    getAIDetailsResponse(event.cost).await()&#10;                    getOpenAIImageResponse(event.cost).await()&#10;                    onEvent(AddEditDreamEvent.SaveDream {&#10;                        onEvent(AddEditDreamEvent.ToggleDreamHasChanged(false))&#10;                    })&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIImageToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdImage = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeLucidity -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamLucidity = event.lucidity&#10;                    )&#10;                )&#10;                Logger.d(&quot;AddEditViewModel&quot;) { &quot;Lucidity updated to ${event.lucidity}&quot; }&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeVividness -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamVividness = event.vividness&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeMood -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamEmotion = event.mood&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeNightmare -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsNightmare = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeRecurrence -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsRecurring = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeIsLucid -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsLucid = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeFavorite -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsFavorite = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeFalseAwakening -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsFalseAwakening = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeTimeOfDay -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamTimeOfDay = event.timeOfDay&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateFromDescription -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIImage = DreamAIImage(&#10;                        isLoading = true&#10;                    )&#10;                )&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIExplanation = DreamAIExplanation(&#10;                        isLoading = true&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDetailsOfDream -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamGeneratedDetails = DreamAIGeneratedDetails(&#10;                        response = event.value&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.DeleteDream -&gt; {&#10;                viewModelScope.launch {&#10;                    dreamUseCases.deleteDream(SavedStateHandle()[&quot;dreamId&quot;]!!)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamDate -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedDate = formatLocalDate(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamDate = formattedDate&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamWakeTime -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedWakeTime = formatLocalTime(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamWakeTime = formattedWakeTime&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamSleepTime -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedSleepTime = formatLocalTime(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamSleepTime = formattedSleepTime&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeQuestionOfDream -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIQuestionAnswer = DreamQuestionAIAnswer(&#10;                        question = event.value&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickWord -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    bottomSheetState = true,&#10;                    isClickedWordUnlocked = event.word.cost == 0,&#10;                    clickedWord = event.word&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.FilterDreamWordInDictionary -&gt; {&#10;                viewModelScope.launch(Dispatchers.IO) {&#10;                    val content = contentTextFieldState.value.text.toString()&#10;                    val dictionaryList = addEditDreamState.value.dictionaryWordMutableList&#10;&#10;                    // Call your repository’s filter function&#10;                    val filteredWords = dictionaryRepository.dictionaryWordsInDreamFilterList(&#10;                        dreamContent = content,&#10;                        dictionaryWordList = dictionaryList&#10;                    )&#10;&#10;                    _addEditDreamState.update { state -&gt;&#10;                        state.copy(&#10;                            dreamFilteredDictionaryWords = filteredWords,&#10;                            dreamContentChanged = false&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.LoadWords -&gt; {&#10;                viewModelScope.launch {&#10;                    loadWords()&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ContentHasChanged -&gt; {&#10;                Logger.d(&quot;AddEditDreamViewModel&quot;) { &quot;Content updated succesfully)&quot; }&#10;                _addEditDreamState.update {&#10;                    it.copy(dreamContentChanged = true, dreamHasChanged = true)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.GetUnlockedWords -&gt; {&#10;                viewModelScope.launch {&#10;                    authRepository.getUnlockedWords().collect { result -&gt;&#10;                        when (result) {&#10;                            is Resource.Loading -&gt; {&#10;                                // Handle loading state if needed&#10;                            }&#10;&#10;                            is Resource.Success -&gt; {&#10;                                _addEditDreamState.update { state -&gt;&#10;                                    state.copy(&#10;                                        unlockedWords = result.data?.toMutableList()&#10;                                            ?: mutableListOf()&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            is Resource.Error -&gt; {&#10;                                Logger.e(&quot;AddEditDreamViewModel&quot;) { result.message.toString() }&#10;                                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                    message = &quot;Couldn't get unlocked words :(&quot;,&#10;                                    actionLabel = &quot;Dismiss&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickBuyWord -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isDreamExitOff = true&#10;                )&#10;                viewModelScope.launch {&#10;                    handleUnlockWord(event)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamImageGenerationPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamImageGenerationPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamInterpretationPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamInterpretationPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamAdvicePopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamAdvicePopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamQuestionPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamQuestionPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamStoryPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamStoryPopupState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamMoodPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamMoodPopupState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDialogState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(dialogState = event.value)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleBottomSheetState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(bottomSheetState = event.value)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.SaveDream -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(dreamIsSavingLoading = true)&#10;                }&#10;&#10;                viewModelScope.launch {&#10;                    if (titleTextFieldState.value.text.isBlank() &amp;&amp; contentTextFieldState.value.text.isNotEmpty()) {&#10;                        makeAIRequest(&#10;                            command = &quot;Please generate a title for this dream with only 1 to 4 words no quotes. Don't include the word dream: ${contentTextFieldState.value.text}&quot;,&#10;                            cost = 0,&#10;                            updateResponseState = { title -&gt;&#10;                                _titleTextFieldState.value = TextFieldState(initialText = title)&#10;                            },&#10;                            updateLoadingState = {}&#10;                        )&#10;                    }&#10;&#10;                    if (_addEditDreamState.value.dreamInfo.dreamId.isNullOrEmpty()) {&#10;                        _addEditDreamState.update {&#10;                            it.copy(&#10;                                dreamInfo = it.dreamInfo.copy(&#10;                                    dreamId = Uuid.random().toString()&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    try {&#10;                        val preImage = addEditDreamState.value.dreamAIImage.response&#10;                            id = addEditDreamState.value.dreamInfo.dreamId,&#10;                            uid = addEditDreamState.value.dreamInfo.dreamUID,&#10;                            title = titleTextFieldState.value.text.toString(),&#10;                            content = contentTextFieldState.value.text.toString(),&#10;                            timestamp = kotlin.time.Clock.System.now().toEpochMilliseconds(),&#10;                            date = addEditDreamState.value.dreamInfo.dreamDate,&#10;                            sleepTime = addEditDreamState.value.dreamInfo.dreamSleepTime,&#10;                            wakeTime = addEditDreamState.value.dreamInfo.dreamWakeTime,&#10;                            AIResponse = addEditDreamState.value.dreamAIExplanation.response,&#10;                            isFavorite = addEditDreamState.value.dreamInfo.dreamIsFavorite,&#10;                            isLucid = addEditDreamState.value.dreamInfo.dreamIsLucid,&#10;                            isNightmare = addEditDreamState.value.dreamInfo.dreamIsNightmare,&#10;                            isRecurring = addEditDreamState.value.dreamInfo.dreamIsRecurring,&#10;                            falseAwakening = addEditDreamState.value.dreamInfo.dreamIsFalseAwakening,&#10;                            lucidityRating = addEditDreamState.value.dreamInfo.dreamLucidity,&#10;                            moodRating = addEditDreamState.value.dreamInfo.dreamEmotion,&#10;                            vividnessRating = addEditDreamState.value.dreamInfo.dreamVividness,&#10;                            timeOfDay = addEditDreamState.value.dreamInfo.dreamTimeOfDay,&#10;                            backgroundImage = addEditDreamState.value.dreamInfo.dreamBackgroundImage,&#10;                            generatedImage = addEditDreamState.value.dreamAIImage.response,&#10;                            generatedDetails = addEditDreamState.value.dreamGeneratedDetails.response,&#10;                            dreamQuestion = addEditDreamState.value.dreamAIQuestionAnswer.question,&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.response,&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.response,&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.response,&#10;                            dreamAIMood = addEditDreamState.value.dreamAIMoodAnalyser.response&#10;                        )&#10;                        logger.d { &quot;Saving Dream: $dreamToSave&quot; }&#10;                        dreamUseCases.addDream(dreamToSave)&#10;                        logger.d { &quot;SaveDream: addDream returned (write initiated)&quot; }&#10;                        _addEditDreamState.update {&#10;                            it.copy(&#10;                                dreamIsSavingLoading = false,&#10;                                saveSuccess = true&#10;                            )&#10;                        }&#10;                        event.onSaveSuccess()&#10;                    } catch (e: InvalidDreamException) {&#10;                        _addEditDreamState.update {&#10;                            it.copy(dreamIsSavingLoading = false, saveSuccess = false)&#10;                        }&#10;                        addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                            e.message ?: &quot;Couldn't save dream :(&quot;,&#10;                            actionLabel = &quot;Dismiss&quot;,&#10;                            duration = SnackbarDuration.Long&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamHasChanged -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamHasChanged = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.FlagDreamContent -&gt; {&#10;                viewModelScope.launch {&#10;                    val result = dreamUseCases.flagDream(&#10;                        dreamID = addEditDreamState.value.dreamInfo.dreamId,&#10;                        imagePath = addEditDreamState.value.dreamAIImage.response&#10;                    )&#10;&#10;                    when (result) {&#10;                        is Resource.Success&lt;*&gt; -&gt; {&#10;                            addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                message = &quot;Dream flagged successfully&quot;,&#10;                                actionLabel = &quot;Dismiss&quot;&#10;                            )&#10;                        }&#10;&#10;                        is Resource.Error&lt;*&gt; -&gt; {&#10;                            addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                message = &quot;Couldn't flag dream :(&quot;,&#10;                                actionLabel = &quot;Dismiss&quot;&#10;                            )&#10;                        }&#10;&#10;                        is Resource.Loading&lt;*&gt; -&gt; {&#10;                            // Handle loading state if needed&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                _addEditDreamState.update {&#10;                                    it.copy(&#10;                                        dreamTokens = resource.data?.toInt() ?: 0&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            is Resource.Error -&gt; {&#10;                                Logger.e(&quot;AddEditDreamViewModel&quot;) { resource.message.toString() }&#10;                            }&#10;&#10;                            is Resource.Loading -&gt; {&#10;                                // Handle loading state if needed&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.OnCleared -&gt; {&#10;&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleSleepTimePickerDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        sleepTimePickerDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleWakeTimePickerDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        wakeTimePickerDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleCalendarDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        calendarDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;            is AddEditDreamEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch {&#10;                    vibratorUtil.triggerVibration()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleUnlockWord(event: AddEditDreamEvent.ClickBuyWord) {&#10;        if (event.isAd) {&#10;            unlockWordWithAd(event.dictionaryWord)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        } else {&#10;            unlockWordWithTokens(event.dictionaryWord)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun unlockWordWithAd(dictionaryWord: DictionaryWord) {&#10;        viewModelScope.launch {&#10;            processUnlockWordResult(&#10;                result = authRepository.unlockWord(dictionaryWord.word, 0),&#10;                dictionaryWord = dictionaryWord&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun unlockWordWithTokens(dictionaryWord: DictionaryWord) {&#10;        viewModelScope.launch {&#10;            processUnlockWordResult(&#10;                result = authRepository.unlockWord(dictionaryWord.word, dictionaryWord.cost),&#10;                dictionaryWord = dictionaryWord&#10;            )&#10;        }&#10;    }&#10;&#10;    private suspend fun processUnlockWordResult(&#10;        result: Resource&lt;Boolean&gt;, dictionaryWord: DictionaryWord&#10;    ) {&#10;        when (result) {&#10;            is Resource.Error -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        bottomSheetState = false&#10;                    )&#10;                }&#10;                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    message = &quot;${result.message}&quot;, actionLabel = &quot;Dismiss&quot;&#10;                )&#10;            }&#10;&#10;            is Resource.Success -&gt; {&#10;                updateScreenStateForUnlockedWord(dictionaryWord)&#10;            }&#10;&#10;            is Resource.Loading -&gt; {&#10;                // Handle loading state if needed&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateScreenStateForUnlockedWord(dictionaryWord: DictionaryWord) {&#10;        _addEditDreamState.update { state -&gt;&#10;            state.copy(&#10;                isClickedWordUnlocked = true,&#10;                clickedWord = dictionaryWord,&#10;                unlockedWords = state.unlockedWords.apply {&#10;                    add(dictionaryWord.word)&#10;                })&#10;        }&#10;    }&#10;&#10;    private fun getAIResponse(&#10;        command: String,&#10;        cost: Int,&#10;        updateLoadingState: (Boolean) -&gt; Unit,&#10;        updateResponseState: (String) -&gt; Unit&#10;    ) {&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            isDreamExitOff = true&#10;        )&#10;        viewModelScope.launch {&#10;            if (contentTextFieldState.value.text.toString().length &lt;= 20) {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isDreamExitOff = false&#10;                )&#10;                val message =&#10;                    if (contentTextFieldState.value.text.toString().isEmpty()) {&#10;                        &quot;Dream content is empty&quot;&#10;                    } else {&#10;                        &quot;Dream content is too short&quot;&#10;                    }&#10;                addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    message, duration = SnackbarDuration.Short, actionLabel = &quot;Dismiss&quot;&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            updateLoadingState(true)&#10;&#10;            makeAIRequest(command, cost, updateLoadingState, updateResponseState)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;    private suspend fun makeAIRequest(&#10;        command: String,&#10;        cost: Int,&#10;        updateLoadingState: (Boolean) -&gt; Unit,&#10;        updateResponseState: (String) -&gt; Unit&#10;    ) {&#10;        try {&#10;&#10;            val apiKey = OpenAIApiKeyUtil.getOpenAISecretKey()&#10;            Logger.d(&quot;AddEditDreamViewModel&quot;) { &quot;API Key: $apiKey&quot; }&#10;            val openAI = OpenAI(apiKey)&#10;            val currentLocale = Locale.current.language&#10;&#10;            // Use cost-aware models: mini for budget, full for higher quality&#10;            val modelId = if (cost &lt;= 0) &quot;gpt-4.1-mini&quot; else &quot;gpt-4.1&quot;&#10;            val chatCompletionRequest = ChatCompletionRequest(&#10;                model = ModelId(modelId), messages = listOf(&#10;                    ChatMessage(&#10;                        role = ChatRole.User,&#10;                        content = &quot;$command.\n Respond in this language: $currentLocale&quot;&#10;                    )&#10;                ), maxTokens = 750&#10;            )&#10;&#10;            val completion = openAI.chatCompletion(chatCompletionRequest)&#10;            updateResponseState(completion.choices.firstOrNull()?.message?.content ?: &quot;&quot;)&#10;            updateLoadingState(false)&#10;&#10;            if (cost &gt; 0) authRepository.consumeDreamTokens(cost)&#10;        } catch (e: Exception) {&#10;            Logger.e(&quot;AddEditDreamViewModel&quot;) { e.message.toString() }&#10;            updateLoadingState(false)&#10;            _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                &quot;Error getting AI response&quot;, &quot;Dismiss&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun getAIDetailsResponse(&#10;        eventCost: Int&#10;    ): Deferred&lt;Unit&gt; = viewModelScope.async {&#10;        // Indicate loading state&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                isLoading = true&#10;            )&#10;        )&#10;&#10;        val randomStyle =&#10;            &quot;A photograph of the scene, 4k, detailed, with vivid colors&quot; + if (eventCost &lt;= 1) {&#10;                &quot; and a very simple beautiful scene&quot;&#10;            } else {&#10;                &quot;&quot;&#10;            }&#10;&#10;        val imagePrompt = if (eventCost &lt;= 1) {&#10;            &quot;You are a dream environment builder: In the following dream, in third person and one short sentence 8 to 20 words build the visual elements, such as characters, scene, objects that stand out, or setting of the dream that follows. Make it short and straightforward: \n\n${&#10;                contentTextFieldState.value.text&#10;            } \n\nUse vivid imagery and a palette of rich, beautiful colors to highlight key objects or characters. Keep the description straightforward and focused on visuals only&quot;&#10;        } else {&#10;            &quot;You are a dream environment builder: In the following dream, in third person and one short sentence build the visual elements, such as characters, scene, objects that stand out, or setting of the dream that follows. Make it short and straightforward: \n\n${&#10;                contentTextFieldState.value.text&#10;            } \n\nUse vivid imagery and a palette of rich, beautiful colors to highlight key objects or characters.&quot;&#10;        }&#10;&#10;&#10;        val creativity = if (eventCost &lt;= 1) {&#10;            .4&#10;        } else {&#10;            1.1&#10;        }&#10;&#10;        try {&#10;            val apiKey = OpenAIApiKeyUtil.getOpenAISecretKey()&#10;            val openAI = OpenAI(apiKey)&#10;&#10;            // Use mini for budget prompts, full for higher-quality prompt shaping&#10;            val promptModel = if (eventCost &lt;= 1) &quot;gpt-4.1-mini&quot; else &quot;gpt-4.1&quot;&#10;            val chatCompletionRequest = ChatCompletionRequest(&#10;                model = ModelId(promptModel),&#10;                messages = listOf(&#10;                    ChatMessage(&#10;                        role = ChatRole.User,&#10;                        content = imagePrompt,&#10;                    )&#10;                ),&#10;                maxTokens = 175,&#10;                temperature = creativity,&#10;            )&#10;&#10;            val completion: ChatCompletion = openAI.chatCompletion(chatCompletionRequest)&#10;&#10;            // Update state with success&#10;            _addEditDreamState.update { state -&gt;&#10;                state.copy(&#10;                    dreamGeneratedDetails = state.dreamGeneratedDetails.copy(&#10;                        response = (completion.choices.firstOrNull()?.message?.content + &quot; $randomStyle&quot;),&#10;                        isLoading = false&#10;                    )&#10;                )&#10;            }&#10;        } catch (_: Exception) {&#10;            // Handle error state&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                dreamGeneratedDetails = addEditDreamState.value.dreamGeneratedDetails.copy(&#10;                    isLoading = false&#10;                )&#10;            )&#10;            // Optionally, show an error message to the user&#10;        }&#10;    }&#10;&#10;&#10;    private fun getOpenAIImageResponse(&#10;        cost: Int&#10;    ): Deferred&lt;Unit&gt; = viewModelScope.async {&#10;        logger.d { &quot;getOpenAIImageResponse: Starting image generation with cost: $cost&quot; }&#10;&#10;        // Indicate loading state&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                isLoading = true&#10;            )&#10;        )&#10;&#10;        fun Throwable.shouldDisableGptImage(): Boolean {&#10;            val msg = (message ?: &quot;&quot;).lowercase()&#10;            return listOf(&#10;                &quot;unknown parameter: 'response_format'&quot;,&#10;                &quot;unsupported model&quot;,&#10;                &quot;unknown model&quot;,&#10;                &quot;does not exist&quot;,&#10;                &quot;invalid model&quot;&#10;            ).any { it in msg }&#10;        }&#10;&#10;        suspend fun tryGenerate(modelId: String, size: ImageSize, gptSizeString: String): String {&#10;        suspend fun tryGenerate(modelId: String, size: ImageSize): String {&#10;            val openAI = OpenAI(apiKey)&#10;            val prompt = addEditDreamState.value.dreamGeneratedDetails.response&#10;                .ifBlank { contentTextFieldState.value.text.toString().ifBlank { &quot;A beautiful, peaceful dream scene&quot; } }&#10;&#10;            logger.d { &quot;getOpenAIImageResponse: Attempting model=$modelId size=$size (gptEffSize=$gptSizeString)&quot; }&#10;            logger.d { &quot;getOpenAIImageResponse: Attempting model=$modelId size=$size&quot; }&#10;            val imageCreation = ImageCreation(&#10;                prompt = prompt,&#10;                model = ModelId(normalizedModel),&#10;                n = 1,&#10;                size = size&#10;            )&#10;            val images = openAI.imageURL(imageCreation)&#10;            val url = images.firstOrNull()?.url.orEmpty()&#10;            if (url.isBlank()) error(&quot;Empty image URL returned by API&quot;)&#10;            return url&#10;        }&#10;&#10;        val primaryModel = if (cost &lt;= 1) &quot;gpt-image-1-mini&quot; else &quot;gpt-image-1&quot;&#10;        val fallbackModel = if (cost &lt;= 1) &quot;dall-e-2&quot; else &quot;dall-e-3&quot;&#10;        // Keep 512 for DALL·E mini budget to control cost; GPT-Image requires &gt;= 1024&#10;        val size = if (cost &lt;= 1) ImageSize.is512x512 else ImageSize.is1024x1024&#10;        try {&#10;            if (gptImageTemporarilyDisabled) {&#10;                logger.d { &quot;getOpenAIImageResponse: GPT-Image disabled for this session; using fallback=$fallbackModel&quot; }&#10;                throw IllegalStateException(&quot;skip-primary-and-use-fallback&quot;)&#10;            }&#10;            // 1) Try GPT Image first&#10;            val imageUrl = tryGenerate(primaryModel, sdkSize, gptImageSizeString)&#10;            val imageUrl = tryGenerate(primaryModel, size)&#10;&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                    response = imageUrl, isLoading = false&#10;                )&#10;            )&#10;            authRepository.consumeDreamTokens(cost)&#10;            logger.d { &quot;getOpenAIImageResponse: Tokens consumed for cost: $cost&quot; }&#10;            _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = false)&#10;        } catch (primary: Exception) {&#10;            logger.e(primary) { &quot;getOpenAIImageResponse: Primary model failed (${primary.message}).&quot; }&#10;            // Additional diagnostics for visibility in Logcat&#10;            val exClass = primary::class.simpleName ?: primary::class.toString()&#10;            val topTrace = primary.toString()&#10;            logger.d { &quot;getOpenAIImageResponse: Primary failure details -&gt; type=$exClass, msg='${primary.message}', top=$topTrace&quot; }&#10;            val shouldFallback = primary.shouldDisableGptImage() || true // fallback on any failure for robustness&#10;            val shouldFallback = primary.shouldDisableGptImage()&#10;            if (shouldFallback) {&#10;                try {&#10;                    // 2) Fallback to DALL·E&#10;                    val fallbackUrl = tryGenerate(fallbackModel, size)&#10;                    logger.d { &quot;getOpenAIImageResponse: Fallback model succeeded -&gt; $fallbackUrl&quot; }&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    _addEditDreamState.value = addEditDreamState.value.copy(&#10;                        dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                            response = fallbackUrl, isLoading = false&#10;                        )&#10;                    )&#10;                    authRepository.consumeDreamTokens(cost)&#10;                    logger.d { &quot;getOpenAIImageResponse: Tokens consumed for cost: $cost (fallback)&quot; }&#10;                    _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = false)&#10;                } catch (fallback: Exception) {&#10;                    logger.e(fallback) { &quot;getOpenAIImageResponse: Fallback model also failed (${fallback.message}).&quot; }&#10;                    val fbClass = fallback::class.simpleName ?: fallback::class.toString()&#10;                    val fbTop = fallback.toString()&#10;                    logger.d { &quot;getOpenAIImageResponse: Fallback failure details -&gt; type=$fbClass, msg='${fallback.message}', top=$fbTop&quot; }&#10;                    addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                        &quot;Error getting AI image: ${fallback.message ?: &quot;unknown error&quot;}&quot;,&#10;                        duration = SnackbarDuration.Short,&#10;                        actionLabel = &quot;Dismiss&quot;&#10;                    )&#10;                    _addEditDreamState.value = addEditDreamState.value.copy(&#10;                        dreamAIImage = addEditDreamState.value.dreamAIImage.copy(isLoading = false),&#10;                        isDreamExitOff = false&#10;                    )&#10;                }&#10;            } else {&#10;                addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    &quot;Error getting AI image: ${primary.message ?: &quot;unknown error&quot;}&quot;,&#10;                    actionLabel = &quot;Dismiss&quot;&#10;                )&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIImage = addEditDreamState.value.dreamAIImage.copy(isLoading = false),&#10;                    isDreamExitOff = false&#10;                )&#10;            }&#10;         }&#10;        }&#10;    }&#10;    }&#10;                    dictionaryWordMutableList = words.toMutableList()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class AddEditDreamState(&#10;    val dreamInfo: DreamInfo = DreamInfo(&#10;        dreamId = &quot;&quot;,&#10;        dreamUID = &quot;&quot;,&#10;        dreamBackgroundImage = Dream.dreamBackgroundImages.indices.random(),&#10;        dreamIsLucid = false,&#10;        dreamIsFavorite = false,&#10;        dreamIsNightmare = false,&#10;        dreamIsRecurring = false,&#10;        dreamIsFalseAwakening = false,&#10;        dreamSleepTime = formatLocalTime(sleepTime),    // &quot;11:00 PM&quot;&#10;        dreamWakeTime = formatLocalTime(wakeTime),      // &quot;7:00 AM&quot;&#10;        dreamDate = formatLocalDate(currentDate),        // &quot;Jun 3, 2023&quot; for example&#10;        dreamTimeOfDay = &quot;&quot;,&#10;        dreamLucidity = 0,&#10;        dreamVividness = 0,&#10;        dreamEmotion = 0&#10;    ),&#10;    val dreamContentChanged: Boolean = true,&#10;    val dreamAIExplanation: DreamAIExplanation = DreamAIExplanation(&#10;        response = &quot;&quot;,&#10;        isLoading = false,&#10;        error = &quot;&quot;,&#10;    ),&#10;    val dreamAIImage: DreamAIImage = DreamAIImage(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIAdvice: DreamAIAdvice = DreamAIAdvice(&#10;        response = &quot;&quot;,&#10;        isLoading = false,&#10;        error = &quot;&quot;,&#10;    ),&#10;    val dreamGeneratedDetails: DreamAIGeneratedDetails = DreamAIGeneratedDetails(&#10;        response = &quot;&quot;, isLoading = false, isSuccessful = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIQuestionAnswer: DreamQuestionAIAnswer = DreamQuestionAIAnswer(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIStory: DreamStoryGeneration = DreamStoryGeneration(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIMoodAnalyser: DreamMoodAIAnalyser = DreamMoodAIAnalyser(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamIsSavingLoading: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val saveSuccess: Boolean = false,&#10;    val dialogState: Boolean = false,&#10;    val calendarDialogState: Boolean = false,&#10;    val sleepTimePickerDialogState: Boolean = false,&#10;    val wakeTimePickerDialogState: Boolean = false,&#10;    val dreamImageGenerationPopUpState: Boolean = false,&#10;    val dreamInterpretationPopUpState: Boolean = false,&#10;    val dreamAdvicePopUpState: Boolean = false,&#10;    val dreamQuestionPopUpState: Boolean = false,&#10;    val dreamStoryPopupState: Boolean = false,&#10;    val dreamMoodPopupState: Boolean = false,&#10;    val isDreamExitOff: Boolean = false,&#10;    val snackBarHostState: MutableState&lt;SnackbarHostState&gt; = mutableStateOf(SnackbarHostState()),&#10;    val dictionaryWordMutableList: MutableList&lt;DictionaryWord&gt; = mutableListOf(),&#10;    val dreamFilteredDictionaryWords: List&lt;DictionaryWord&gt; = mutableListOf(),&#10;    val unlockedWords: MutableList&lt;String&gt; = mutableListOf(),&#10;    val bottomSheetState: Boolean = false,&#10;    val clickedWord: DictionaryWord = DictionaryWord(&quot;&quot;, &quot;&quot;, false, 0),&#10;    val isClickedWordUnlocked: Boolean = false,&#10;    val isDreamFilterLoading: Boolean = false,&#10;    val authRepository: AuthRepository,&#10;    val dreamTokens: Int = 0,&#10;    val dreamHasChanged: Boolean = false,&#10;    val isAdResponse: Boolean = false,&#10;    val isAdAdvice: Boolean = false,&#10;    val isAdQuestion: Boolean = false,&#10;    val isAdStory: Boolean = false,&#10;    val isAdMood: Boolean = false,&#10;    val isAdImage: Boolean = false&#10;)&#10;&#10;data class DreamAIExplanation(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamAIGeneratedDetails(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    val isSuccessful: Boolean = false, // This remains specific to this class&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamAIImage(&#10;    override val response: String = &quot;&quot;, // Specific to this class&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null&#10;) : AIData&#10;&#10;data class DreamAIAdvice(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamQuestionAIAnswer(&#10;    override val response: String = &quot;&quot;,&#10;    val question: String = &quot;&quot;, // Specific to this class&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamStoryGeneration(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamMoodAIAnalyser(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamInfo(&#10;    val dreamId: String?,&#10;    val dreamUID: String?,&#10;    var dreamBackgroundImage: Int,&#10;    val dreamIsLucid: Boolean,&#10;    val dreamIsFavorite: Boolean,&#10;    val dreamIsNightmare: Boolean,&#10;    val dreamIsRecurring: Boolean,&#10;    val dreamIsFalseAwakening: Boolean,&#10;    val dreamSleepTime: String,&#10;    val dreamWakeTime: String,&#10;    val dreamDate: String,&#10;    val dreamTimeOfDay: String,&#10;    val dreamLucidity: Int,&#10;    val dreamVividness: Int,&#10;    val dreamEmotion: Int,&#10;)&#10;&#10;interface AIData {&#10;    val response: String&#10;    val isLoading: Boolean&#10;    val error: String?&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.runtime.MutableState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.ui.text.intl.Locale&#10;import androidx.lifecycle.SavedStateHandle&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.aallam.openai.api.chat.ChatCompletion&#10;import com.aallam.openai.api.chat.ChatCompletionRequest&#10;import com.aallam.openai.api.chat.ChatMessage&#10;import com.aallam.openai.api.chat.ChatRole&#10;import com.aallam.openai.api.image.ImageCreation&#10;import com.aallam.openai.api.image.ImageSize&#10;import com.aallam.openai.api.model.ModelId&#10;import com.aallam.openai.client.OpenAI&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.plugins.HttpRequestRetry&#10;import io.ktor.client.plugins.HttpTimeout&#10;import io.ktor.client.plugins.HttpRequestTimeoutException&#10;import io.ktor.client.request.post&#10;import io.ktor.client.request.setBody&#10;import io.ktor.client.request.headers&#10;import io.ktor.client.statement.bodyAsText&#10;import io.ktor.http.ContentType&#10;import io.ktor.http.contentType&#10;import io.ktor.client.plugins.timeout&#10;import kotlinx.coroutines.Deferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.LocalTime&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import kotlinx.serialization.json.Json&#10;import kotlinx.serialization.json.JsonArray&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlinx.serialization.json.jsonPrimitive&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.DictionaryRepository&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.OpenAIApiKeyUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.formatLocalDate&#10;import org.ballistic.dreamjournalai.shared.core.util.formatLocalTime&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.domain.AddEditDreamEvent&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.InvalidDreamException&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryWord&#10;import kotlin.time.ExperimentalTime&#10;import kotlin.uuid.ExperimentalUuidApi&#10;import kotlin.uuid.Uuid&#10;&#10;// Get current date&#10;@OptIn(ExperimentalTime::class)&#10;private val now = kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())&#10;private val currentDate = now.date&#10;&#10;// Static sleep and wake times&#10;private val sleepTime = LocalTime(23, 0) // 11 PM&#10;private val wakeTime = LocalTime(7, 0)   // 7 A&#10;private val logger = Logger.withTag(&quot;AddEditViewModel&quot;)&#10;&#10;class AddEditDreamViewModel(&#10;    savedStateHandle: SavedStateHandle,&#10;    private val dreamUseCases: DreamUseCases,&#10;    private val authRepository: AuthRepository,&#10;    private val dictionaryRepository: DictionaryRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;) : ViewModel() {&#10;&#10;     // Lightweight Ktor client for direct OpenAI calls (multiplatform)&#10;     private val httpClient by lazy {&#10;        HttpClient {&#10;            install(HttpTimeout) {&#10;                requestTimeoutMillis = 70_000&#10;                connectTimeoutMillis = 30_000&#10;                socketTimeoutMillis = 70_000&#10;            }&#10;            install(HttpRequestRetry) {&#10;                maxRetries = 1&#10;                retryIf { _, response -&gt; response.status.value in 500..599 }&#10;                retryOnExceptionIf { _, cause -&gt;&#10;                    // Retry once on request timeouts&#10;                    cause is HttpRequestTimeoutException&#10;                }&#10;                exponentialDelay()&#10;            }&#10;        }&#10;     }&#10;&#10;    private val _addEditDreamState = MutableStateFlow(&#10;        AddEditDreamState(&#10;            authRepository = authRepository&#10;        )&#10;    )&#10;    val addEditDreamState: StateFlow&lt;AddEditDreamState&gt; = _addEditDreamState.asStateFlow()&#10;&#10;    private val _titleTextFieldState = MutableStateFlow(TextFieldState())&#10;    val titleTextFieldState: StateFlow&lt;TextFieldState&gt; = _titleTextFieldState.asStateFlow()&#10;&#10;    private val _contentTextFieldState = MutableStateFlow(TextFieldState())&#10;    val contentTextFieldState: StateFlow&lt;TextFieldState&gt; = _contentTextFieldState.asStateFlow()&#10;&#10;    val flow = Unit&#10;&#10;    // Runtime flag: if GPT Image model calls are failing for this session, skip them and use DALL·E fallback immediately&#10;    private var gptImageTemporarilyDisabled: Boolean = false&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        onEvent(AddEditDreamEvent.OnCleared)&#10;    }&#10;&#10;    init {&#10;        savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)?.let { dreamId -&gt;&#10;            if (dreamId.isNotEmpty()) {&#10;                viewModelScope.launch {&#10;                    _addEditDreamState.value = addEditDreamState.value.copy(isLoading = true)&#10;                    when (val resource = dreamUseCases.getDream(dreamId)) {&#10;                        is Resource.Success&lt;*&gt; -&gt; {&#10;                            resource.data?.let { dream: Dream -&gt;&#10;                                _titleTextFieldState.value = TextFieldState(&#10;                                    initialText = resource.data.title&#10;                                )&#10;                                _contentTextFieldState.value = TextFieldState(&#10;                                    initialText = resource.data.content&#10;                                )&#10;                                _addEditDreamState.value = AddEditDreamState(&#10;                                    dreamInfo = DreamInfo(&#10;                                        dreamId = dream.id,&#10;                                        dreamUID = dream.uid,&#10;                                        dreamBackgroundImage = dream.backgroundImage,&#10;                                        dreamIsLucid = dream.isLucid,&#10;                                        dreamIsFavorite = dream.isFavorite,&#10;                                        dreamIsNightmare = dream.isNightmare,&#10;                                        dreamIsRecurring = dream.isRecurring,&#10;                                        dreamIsFalseAwakening = dream.falseAwakening,&#10;                                        dreamSleepTime = dream.sleepTime,&#10;                                        dreamWakeTime = dream.wakeTime,&#10;                                        dreamDate = dream.date,&#10;                                        dreamTimeOfDay = dream.timeOfDay,&#10;                                        dreamLucidity = dream.lucidityRating,&#10;                                        dreamVividness = dream.vividnessRating,&#10;                                        dreamEmotion = dream.moodRating&#10;                                    ),&#10;                                    dreamAIExplanation = DreamAIExplanation(&#10;                                        response = dream.AIResponse,&#10;                                    ),&#10;                                    dreamAIImage = DreamAIImage(&#10;                                        response = dream.generatedImage,&#10;                                    ),&#10;                                    dreamAIQuestionAnswer = DreamQuestionAIAnswer(&#10;                                        response = dream.dreamAIQuestionAnswer,&#10;                                        question = dream.dreamQuestion&#10;                                    ),&#10;                                    dreamAIAdvice = DreamAIAdvice(&#10;                                        response = dream.dreamAIAdvice&#10;                                    ),&#10;                                    dreamAIMoodAnalyser = DreamMoodAIAnalyser(&#10;                                        response = dream.dreamAIMood&#10;                                    ),&#10;                                    dreamAIStory = DreamStoryGeneration(&#10;                                        response = dream.dreamAIStory&#10;                                    ),&#10;                                    dreamGeneratedDetails = DreamAIGeneratedDetails(&#10;                                        response = dream.generatedDetails,&#10;                                    ),&#10;                                    isLoading = false,&#10;                                    authRepository = authRepository&#10;                                )&#10;                            }&#10;                            onEvent(&#10;                                AddEditDreamEvent.ToggleDreamHasChanged(false)&#10;                            )&#10;                            onEvent(AddEditDreamEvent.GetUnlockedWords)&#10;                            onEvent(AddEditDreamEvent.LoadWords)&#10;                            onEvent(AddEditDreamEvent.GetDreamTokens)&#10;                        }&#10;&#10;                        is Resource.Error&lt;*&gt; -&gt; {&#10;                            // single-line error&#10;                            logger.e { &quot;init: load dream failed: ${resource.message}&quot; }&#10;&#10;                            viewModelScope.launch{&#10;                                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                    message = &quot;Couldn't get dream :(&quot;,&#10;                                    actionLabel = &quot;Dismiss&quot;&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        is Resource.Loading&lt;*&gt; -&gt; {&#10;                            // handle loading&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                onEvent(AddEditDreamEvent.GetUnlockedWords)&#10;                onEvent(AddEditDreamEvent.LoadWords)&#10;                onEvent(AddEditDreamEvent.GetDreamTokens)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalUuidApi::class, ExperimentalTime::class)&#10;    fun onEvent(event: AddEditDreamEvent) {&#10;        when (event) {&#10;            is AddEditDreamEvent.ChangeDreamBackgroundImage -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamBackgroundImage = event.dreamBackGroundImage&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIResponse -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;&quot;&quot;&#10;            Please interpret the following dream:&#10;            &#10;            ${contentTextFieldState.value.text}&#10;            &#10;            Markdown is supported. Use the following style guidelines:&#10;            - Begin with an introductory paragraph to provide context.&#10;            - Use bullet points (`-`) for key elements.&#10;            - Start each bullet point with a **bolded title** (e.g., `**Title**:`).&#10;            - The title and body text should touch (no blank line between them).&#10;            - Ensure the body text is concise and directly follows the title.&#10;            - Titles should use the same size as the body text but be bold for emphasis.&#10;            - Use short paragraphs to maintain readability on mobile devices.&#10;            - Avoid excessive formatting or long paragraphs for better readability.&#10;        &quot;&quot;&quot;.trimIndent(),&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIExplanation = addEditDreamState.value.dreamAIExplanation.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { response -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIExplanation = addEditDreamState.value.dreamAIExplanation.copy(&#10;                                response = response&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIResponseToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdResponse = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIAdvice -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please give advice that can be obtained or for this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    } &quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.copy(isLoading = isLoading)&#10;                        )&#10;                    },&#10;                    updateResponseState = { advice -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.copy(response = advice)&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIAdviceToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdAdvice = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateMood -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please describe the mood of this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    }&quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIMoodAnalyser = addEditDreamState.value.dreamAIMoodAnalyser.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { mood -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIMoodAnalyser = addEditDreamState.value.dreamAIMoodAnalyser.copy(&#10;                                response = mood&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdMoodToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdMood = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateStory -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please generate a very short story based on this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    } &quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { story -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.copy(&#10;                                response = story&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdStoryToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdStory = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateFromQuestion -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                getAIResponse(&#10;                    command = &quot;Please answer the following question: ${&#10;                        addEditDreamState.value.dreamAIQuestionAnswer.question&#10;                    }&quot; + &quot;as it relates to this dream: ${&#10;                        contentTextFieldState.value.text&#10;                    }&quot;,&#10;                    cost = event.cost,&#10;                    updateLoadingState = { isLoading -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.copy(&#10;                                isLoading = isLoading&#10;                            )&#10;                        )&#10;                    },&#10;                    updateResponseState = { answer -&gt;&#10;                        _addEditDreamState.value = addEditDreamState.value.copy(&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.copy(&#10;                                response = answer&#10;                            )&#10;                        )&#10;                    })&#10;            }&#10;&#10;            is AddEditDreamEvent.AdQuestionToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdQuestion = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateAIImage -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = true)&#10;                viewModelScope.launch {&#10;&#10;                    onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                    getAIDetailsResponse(event.cost).await()&#10;                    getOpenAIImageResponse(event.cost).await()&#10;                    onEvent(AddEditDreamEvent.SaveDream {&#10;                        onEvent(AddEditDreamEvent.ToggleDreamHasChanged(false))&#10;                    })&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.AdAIImageToggle -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isAdImage = event.value&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeLucidity -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamLucidity = event.lucidity&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeVividness -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamVividness = event.vividness&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeMood -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamEmotion = event.mood&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeNightmare -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsNightmare = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeRecurrence -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsRecurring = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeIsLucid -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsLucid = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeFavorite -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsFavorite = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeFalseAwakening -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamIsFalseAwakening = event.boolean&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeTimeOfDay -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamTimeOfDay = event.timeOfDay&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickGenerateFromDescription -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIImage = DreamAIImage(&#10;                        isLoading = true&#10;                    )&#10;                )&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIExplanation = DreamAIExplanation(&#10;                        isLoading = true&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDetailsOfDream -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamGeneratedDetails = DreamAIGeneratedDetails(&#10;                        response = event.value&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.DeleteDream -&gt; {&#10;                viewModelScope.launch {&#10;                    dreamUseCases.deleteDream(SavedStateHandle()[&quot;dreamId&quot;]!!)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamDate -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedDate = formatLocalDate(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamDate = formattedDate&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamWakeTime -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedWakeTime = formatLocalTime(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamWakeTime = formattedWakeTime&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeDreamSleepTime -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                val formattedSleepTime = formatLocalTime(event.value)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamInfo = addEditDreamState.value.dreamInfo.copy(&#10;                        dreamSleepTime = formattedSleepTime&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ChangeQuestionOfDream -&gt; {&#10;                onEvent(AddEditDreamEvent.ToggleDreamHasChanged(true))&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIQuestionAnswer = DreamQuestionAIAnswer(&#10;                        question = event.value&#10;                    )&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickWord -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    bottomSheetState = true,&#10;                    isClickedWordUnlocked = event.word.cost == 0,&#10;                    clickedWord = event.word&#10;                )&#10;            }&#10;&#10;            is AddEditDreamEvent.FilterDreamWordInDictionary -&gt; {&#10;                viewModelScope.launch(Dispatchers.IO) {&#10;                    val content = contentTextFieldState.value.text.toString()&#10;                    val dictionaryList = addEditDreamState.value.dictionaryWordMutableList&#10;&#10;                    // Call your repository’s filter function&#10;                    val filteredWords = dictionaryRepository.dictionaryWordsInDreamFilterList(&#10;                        dreamContent = content,&#10;                        dictionaryWordList = dictionaryList&#10;                    )&#10;&#10;                    _addEditDreamState.update { state -&gt;&#10;                        state.copy(&#10;                            dreamFilteredDictionaryWords = filteredWords,&#10;                            dreamContentChanged = false&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.LoadWords -&gt; {&#10;                viewModelScope.launch {&#10;                    loadWords()&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ContentHasChanged -&gt; {&#10;                // reduce log noise&#10;                _addEditDreamState.update {&#10;                    it.copy(dreamContentChanged = true, dreamHasChanged = true)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.GetUnlockedWords -&gt; {&#10;                viewModelScope.launch {&#10;                    authRepository.getUnlockedWords().collect { result -&gt;&#10;                        when (result) {&#10;                            is Resource.Loading -&gt; {&#10;                                // Handle loading state if needed&#10;                            }&#10;&#10;                            is Resource.Success -&gt; {&#10;                                _addEditDreamState.update { state -&gt;&#10;                                    state.copy(&#10;                                        unlockedWords = result.data?.toMutableList()&#10;                                            ?: mutableListOf()&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            is Resource.Error -&gt; {&#10;                                Logger.e(&quot;AddEditDreamViewModel&quot;) { result.message.toString() }&#10;                                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                    message = &quot;Couldn't get unlocked words :(&quot;,&#10;                                    actionLabel = &quot;Dismiss&quot;&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ClickBuyWord -&gt; {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isDreamExitOff = true&#10;                )&#10;                viewModelScope.launch {&#10;                    handleUnlockWord(event)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamImageGenerationPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamImageGenerationPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamInterpretationPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamInterpretationPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamAdvicePopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamAdvicePopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamQuestionPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamQuestionPopUpState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamStoryPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamStoryPopupState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamMoodPopUpState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamMoodPopupState = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDialogState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(dialogState = event.value)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleBottomSheetState -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(bottomSheetState = event.value)&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.SaveDream -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(dreamIsSavingLoading = true)&#10;                }&#10;&#10;                viewModelScope.launch {&#10;                    if (titleTextFieldState.value.text.isBlank() &amp;&amp; contentTextFieldState.value.text.isNotEmpty()) {&#10;                        makeAIRequest(&#10;                            command = &quot;Please generate a title for this dream with only 1 to 4 words no quotes. Don't include the word dream: ${contentTextFieldState.value.text}&quot;,&#10;                            cost = 0,&#10;                            updateResponseState = { title -&gt;&#10;                                _titleTextFieldState.value = TextFieldState(initialText = title)&#10;                            },&#10;                            updateLoadingState = {}&#10;                        )&#10;                    }&#10;&#10;                    if (_addEditDreamState.value.dreamInfo.dreamId.isNullOrEmpty()) {&#10;                        _addEditDreamState.update {&#10;                            it.copy(&#10;                                dreamInfo = it.dreamInfo.copy(&#10;                                    dreamId = Uuid.random().toString()&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    try {&#10;                        val preImage = addEditDreamState.value.dreamAIImage.response&#10;                        val preKind = when {&#10;                            preImage.startsWith(&quot;data:&quot;) -&gt; &quot;data&quot;&#10;                            preImage.startsWith(&quot;http&quot;) -&gt; &quot;http&quot;&#10;                            preImage.isBlank() -&gt; &quot;empty&quot;&#10;                            else -&gt; &quot;other&quot;&#10;                        }&#10;                        logger.d { &quot;save: start kind=$preKind&quot; }&#10;&#10;                        val dreamToSave = Dream(&#10;                            id = addEditDreamState.value.dreamInfo.dreamId,&#10;                            uid = addEditDreamState.value.dreamInfo.dreamUID,&#10;                            title = titleTextFieldState.value.text.toString(),&#10;                            content = contentTextFieldState.value.text.toString(),&#10;                            timestamp = kotlin.time.Clock.System.now().toEpochMilliseconds(),&#10;                            date = addEditDreamState.value.dreamInfo.dreamDate,&#10;                            sleepTime = addEditDreamState.value.dreamInfo.dreamSleepTime,&#10;                            wakeTime = addEditDreamState.value.dreamInfo.dreamWakeTime,&#10;                            AIResponse = addEditDreamState.value.dreamAIExplanation.response,&#10;                            isFavorite = addEditDreamState.value.dreamInfo.dreamIsFavorite,&#10;                            isLucid = addEditDreamState.value.dreamInfo.dreamIsLucid,&#10;                            isNightmare = addEditDreamState.value.dreamInfo.dreamIsNightmare,&#10;                            isRecurring = addEditDreamState.value.dreamInfo.dreamIsRecurring,&#10;                            falseAwakening = addEditDreamState.value.dreamInfo.dreamIsFalseAwakening,&#10;                            lucidityRating = addEditDreamState.value.dreamInfo.dreamLucidity,&#10;                            moodRating = addEditDreamState.value.dreamInfo.dreamEmotion,&#10;                            vividnessRating = addEditDreamState.value.dreamInfo.dreamVividness,&#10;                            timeOfDay = addEditDreamState.value.dreamInfo.dreamTimeOfDay,&#10;                            backgroundImage = addEditDreamState.value.dreamInfo.dreamBackgroundImage,&#10;                            generatedImage = addEditDreamState.value.dreamAIImage.response,&#10;                            generatedDetails = addEditDreamState.value.dreamGeneratedDetails.response,&#10;                            dreamQuestion = addEditDreamState.value.dreamAIQuestionAnswer.question,&#10;                            dreamAIQuestionAnswer = addEditDreamState.value.dreamAIQuestionAnswer.response,&#10;                            dreamAIStory = addEditDreamState.value.dreamAIStory.response,&#10;                            dreamAIAdvice = addEditDreamState.value.dreamAIAdvice.response,&#10;                            dreamAIMood = addEditDreamState.value.dreamAIMoodAnalyser.response&#10;                        )&#10;                        // no full object dump&#10;                        dreamUseCases.addDream(dreamToSave)&#10;                        logger.d { &quot;save: write initiated&quot; }&#10;&#10;                        // Re-fetch saved dream to get canonical Storage URL and push to UI&#10;                        val savedId = addEditDreamState.value.dreamInfo.dreamId&#10;                        if (!savedId.isNullOrBlank()) {&#10;                            val expectedPathPiece = &quot;/images/$savedId.jpg&quot;&#10;                            val expectedEncodedPiece = &quot;%2Fimages%2F$savedId.jpg&quot;&#10;                            var applied = false&#10;                            repeat(12) attempt@{ _ -&gt;&#10;                                 when (val refreshed = dreamUseCases.getDream(savedId)) {&#10;                                     is Resource.Success&lt;*&gt; -&gt; {&#10;                                         val latest = refreshed.data as Dream&#10;                                         val url = latest.generatedImage&#10;                                         val isFinalFirebase = url.contains(&quot;firebasestorage.googleapis.com&quot;)&#10;                                         val looksVersioned = url.contains(&quot;&amp;v=&quot;) || url.contains(&quot;?v=&quot;)&#10;                                         val matchesTarget = url.contains(expectedPathPiece) || url.contains(expectedEncodedPiece)&#10;                                         if (isFinalFirebase &amp;&amp; (matchesTarget || looksVersioned)) {&#10;                                             _addEditDreamState.update { state -&gt;&#10;                                                 state.copy(&#10;                                                     dreamAIImage = state.dreamAIImage.copy(response = url),&#10;                                                     dreamGeneratedDetails = state.dreamGeneratedDetails.copy(response = latest.generatedDetails)&#10;                                                 )&#10;                                             }&#10;                                             applied = true&#10;                                             return@attempt&#10;                                         }&#10;                                     }&#10;                                     is Resource.Error&lt;*&gt; -&gt; Unit&#10;                                     else -&gt; Unit&#10;                                 }&#10;                                 // small delay between attempts&#10;                                kotlinx.coroutines.delay(250)&#10;                             }&#10;                            logger.d { if (applied) &quot;save: applied refreshed storage url&quot; else &quot;save: no refreshed url observed&quot; }&#10;                         } else {&#10;                             // no-op&#10;                         }&#10;&#10;                        _addEditDreamState.update {&#10;                            it.copy(&#10;                                dreamIsSavingLoading = false,&#10;                                saveSuccess = true&#10;                            )&#10;                        }&#10;                        event.onSaveSuccess()&#10;                    } catch (e: InvalidDreamException) {&#10;                        _addEditDreamState.update {&#10;                            it.copy(dreamIsSavingLoading = false, saveSuccess = false)&#10;                        }&#10;                        addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                            e.message ?: &quot;Couldn't save dream :(&quot;,&#10;                            actionLabel = &quot;Dismiss&quot;,&#10;                            duration = SnackbarDuration.Long&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleDreamHasChanged -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        dreamHasChanged = event.value&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.FlagDreamContent -&gt; {&#10;                viewModelScope.launch {&#10;                    val result = dreamUseCases.flagDream(&#10;                        dreamID = addEditDreamState.value.dreamInfo.dreamId,&#10;                        imagePath = addEditDreamState.value.dreamAIImage.response&#10;                    )&#10;&#10;                    when (result) {&#10;                        is Resource.Success&lt;*&gt; -&gt; {&#10;                            addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                message = &quot;Dream flagged successfully&quot;,&#10;                                actionLabel = &quot;Dismiss&quot;&#10;                            )&#10;                        }&#10;&#10;                        is Resource.Error&lt;*&gt; -&gt; {&#10;                            addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                                message = &quot;Couldn't flag dream :(&quot;,&#10;                                actionLabel = &quot;Dismiss&quot;&#10;                            )&#10;                        }&#10;&#10;                        is Resource.Loading&lt;*&gt; -&gt; {&#10;                            // Handle loading state if needed&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                _addEditDreamState.update {&#10;                                    it.copy(&#10;                                        dreamTokens = resource.data?.toInt() ?: 0&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            is Resource.Error -&gt; {&#10;                                Logger.e(&quot;AddEditDreamViewModel&quot;) { resource.message.toString() }&#10;                            }&#10;&#10;                            is Resource.Loading -&gt; {&#10;                                // Handle loading state if needed&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.OnCleared -&gt; {&#10;&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleSleepTimePickerDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        sleepTimePickerDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleWakeTimePickerDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        wakeTimePickerDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;&#10;            is AddEditDreamEvent.ToggleCalendarDialog -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        calendarDialogState = event.show&#10;                    )&#10;                }&#10;            }&#10;            is AddEditDreamEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch {&#10;                    vibratorUtil.triggerVibration()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleUnlockWord(event: AddEditDreamEvent.ClickBuyWord) {&#10;        if (event.isAd) {&#10;            unlockWordWithAd(event.dictionaryWord)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        } else {&#10;            unlockWordWithTokens(event.dictionaryWord)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun unlockWordWithAd(dictionaryWord: DictionaryWord) {&#10;        viewModelScope.launch {&#10;            processUnlockWordResult(&#10;                result = authRepository.unlockWord(dictionaryWord.word, 0),&#10;                dictionaryWord = dictionaryWord&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun unlockWordWithTokens(dictionaryWord: DictionaryWord) {&#10;        viewModelScope.launch {&#10;            processUnlockWordResult(&#10;                result = authRepository.unlockWord(dictionaryWord.word, dictionaryWord.cost),&#10;                dictionaryWord = dictionaryWord&#10;            )&#10;        }&#10;    }&#10;&#10;    private suspend fun processUnlockWordResult(&#10;        result: Resource&lt;Boolean&gt;, dictionaryWord: DictionaryWord&#10;    ) {&#10;        when (result) {&#10;            is Resource.Error -&gt; {&#10;                _addEditDreamState.update {&#10;                    it.copy(&#10;                        bottomSheetState = false&#10;                    )&#10;                }&#10;                _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    message = &quot;${result.message}&quot;, actionLabel = &quot;Dismiss&quot;&#10;                )&#10;            }&#10;&#10;            is Resource.Success -&gt; {&#10;                updateScreenStateForUnlockedWord(dictionaryWord)&#10;            }&#10;&#10;            is Resource.Loading -&gt; {&#10;                // Handle loading state if needed&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateScreenStateForUnlockedWord(dictionaryWord: DictionaryWord) {&#10;        _addEditDreamState.update { state -&gt;&#10;            state.copy(&#10;                isClickedWordUnlocked = true,&#10;                clickedWord = dictionaryWord,&#10;                unlockedWords = state.unlockedWords.apply {&#10;                    add(dictionaryWord.word)&#10;                })&#10;        }&#10;    }&#10;&#10;    private fun getAIResponse(&#10;        command: String,&#10;        cost: Int,&#10;        updateLoadingState: (Boolean) -&gt; Unit,&#10;        updateResponseState: (String) -&gt; Unit&#10;    ) {&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            isDreamExitOff = true&#10;        )&#10;        viewModelScope.launch {&#10;            if (contentTextFieldState.value.text.toString().length &lt;= 20) {&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    isDreamExitOff = false&#10;                )&#10;                val message =&#10;                    if (contentTextFieldState.value.text.toString().isEmpty()) {&#10;                        &quot;Dream content is empty&quot;&#10;                    } else {&#10;                        &quot;Dream content is too short&quot;&#10;                    }&#10;                addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    message, duration = SnackbarDuration.Short, actionLabel = &quot;Dismiss&quot;&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            updateLoadingState(true)&#10;&#10;            makeAIRequest(command, cost, updateLoadingState, updateResponseState)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                isDreamExitOff = false&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;    private suspend fun makeAIRequest(&#10;        command: String,&#10;        cost: Int,&#10;        updateLoadingState: (Boolean) -&gt; Unit,&#10;        updateResponseState: (String) -&gt; Unit&#10;    ) {&#10;        try {&#10;            val apiKey = OpenAIApiKeyUtil.getOpenAISecretKey()&#10;            val openAI = OpenAI(apiKey)&#10;            val currentLocale = Locale.current.language&#10;&#10;            // Use cost-aware models: mini for budget, full for higher quality&#10;            val modelId = if (cost &lt;= 0) &quot;gpt-4.1-mini&quot; else &quot;gpt-4.1&quot;&#10;            val chatCompletionRequest = ChatCompletionRequest(&#10;                model = ModelId(modelId), messages = listOf(&#10;                    ChatMessage(&#10;                        role = ChatRole.User,&#10;                        content = &quot;$command.\n Respond in this language: $currentLocale&quot;&#10;                    )&#10;                ), maxTokens = 750&#10;            )&#10;&#10;            val completion = openAI.chatCompletion(chatCompletionRequest)&#10;            updateResponseState(completion.choices.firstOrNull()?.message?.content ?: &quot;&quot;)&#10;            updateLoadingState(false)&#10;&#10;            if (cost &gt; 0) authRepository.consumeDreamTokens(cost)&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;AI text gen failed: ${e.message}&quot; }&#10;            updateLoadingState(false)&#10;            _addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                &quot;Error getting AI response&quot;, &quot;Dismiss&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun getAIDetailsResponse(&#10;        eventCost: Int&#10;    ): Deferred&lt;Unit&gt; = viewModelScope.async {&#10;        // Indicate loading state&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                isLoading = true&#10;            )&#10;        )&#10;&#10;        val randomStyle =&#10;            &quot;A photograph of the scene, 4k, detailed, with vivid colors&quot; + if (eventCost &lt;= 1) {&#10;                &quot; and a very simple beautiful scene&quot;&#10;            } else {&#10;                &quot;&quot;&#10;            }&#10;&#10;        val imagePrompt = if (eventCost &lt;= 1) {&#10;            &quot;You are a dream environment builder: In the following dream, in third person and one short sentence 8 to 20 words build the visual elements, such as characters, scene, objects that stand out, or setting of the dream that follows. Make it short and straightforward: \n\n${&#10;                contentTextFieldState.value.text&#10;            } \n\nUse vivid imagery and a palette of rich, beautiful colors to highlight key objects or characters. Keep the description straightforward and focused on visuals only&quot;&#10;        } else {&#10;            &quot;You are a dream environment builder: In the following dream, in third person and one short sentence build the visual elements, such as characters, scene, objects that stand out, or setting of the dream that follows. Make it short and straightforward: \n\n${&#10;                contentTextFieldState.value.text&#10;            } \n\nUse vivid imagery and a palette of rich, beautiful colors to highlight key objects or characters.&quot;&#10;        }&#10;&#10;&#10;        val creativity = if (eventCost &lt;= 1) {&#10;            .4&#10;        } else {&#10;            1.1&#10;        }&#10;&#10;        try {&#10;            val apiKey = OpenAIApiKeyUtil.getOpenAISecretKey()&#10;            val openAI = OpenAI(apiKey)&#10;&#10;            // Use mini for budget prompts, full for higher-quality prompt shaping&#10;            val promptModel = if (eventCost &lt;= 1) &quot;gpt-4.1-mini&quot; else &quot;gpt-4.1&quot;&#10;            val chatCompletionRequest = ChatCompletionRequest(&#10;                model = ModelId(promptModel),&#10;                messages = listOf(&#10;                    ChatMessage(&#10;                        role = ChatRole.User,&#10;                        content = imagePrompt,&#10;                    )&#10;                ),&#10;                maxTokens = 175,&#10;                temperature = creativity,&#10;            )&#10;&#10;            val completion: ChatCompletion = openAI.chatCompletion(chatCompletionRequest)&#10;&#10;            // Update state with success&#10;            _addEditDreamState.update { state -&gt;&#10;                state.copy(&#10;                    dreamGeneratedDetails = state.dreamGeneratedDetails.copy(&#10;                        response = (completion.choices.firstOrNull()?.message?.content + &quot; $randomStyle&quot;),&#10;                        isLoading = false&#10;                    )&#10;                )&#10;            }&#10;        } catch (_: Exception) {&#10;            // Handle error state&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                dreamGeneratedDetails = addEditDreamState.value.dreamGeneratedDetails.copy(&#10;                    isLoading = false&#10;                )&#10;            )&#10;            // Optionally, show an error message to the user&#10;        }&#10;    }&#10;&#10;&#10;    private fun getOpenAIImageResponse(&#10;        cost: Int&#10;    ): Deferred&lt;Unit&gt; = viewModelScope.async {&#10;        // summary log only: start&#10;        logger.d { &quot;imageGen: start cost=$cost&quot; }&#10;&#10;        // Indicate loading state&#10;        _addEditDreamState.value = addEditDreamState.value.copy(&#10;            dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                isLoading = true&#10;            )&#10;        )&#10;&#10;        suspend fun tryGenerate(modelId: String, size: ImageSize, gptSizeString: String): String {&#10;            val apiKey = OpenAIApiKeyUtil.getOpenAISecretKey()&#10;            val openAI = OpenAI(apiKey)&#10;            val prompt = addEditDreamState.value.dreamGeneratedDetails.response&#10;                .ifBlank { contentTextFieldState.value.text.toString().ifBlank { &quot;A beautiful, peaceful dream scene&quot; } }&#10;&#10;            logger.d { &quot;getOpenAIImageResponse: Attempting model=$modelId size=$size (gptEffSize=$gptSizeString)&quot; }&#10;            val normalizedModel = modelId.lowercase()&#10;            // Route GPT-Image models through Ktor to avoid library's unsupported params and use valid sizes&#10;            if (normalizedModel.startsWith(&quot;gpt-image-1&quot;)) {&#10;                return generateImageWithKtor(apiKey = apiKey, model = normalizedModel, prompt = prompt, sizeString = gptSizeString)&#10;            }&#10;            // Otherwise use the SDK (DALL·E works fine here)&#10;            val imageCreation = ImageCreation(&#10;                prompt = prompt,&#10;                model = ModelId(normalizedModel),&#10;                n = 1,&#10;                size = size&#10;            )&#10;            val images = openAI.imageURL(imageCreation)&#10;            val url = images.firstOrNull()?.url.orEmpty()&#10;            if (url.isBlank()) error(&quot;Empty image URL returned by API&quot;)&#10;            return url&#10;        }&#10;&#10;        val primaryModel = if (cost &lt;= 1) &quot;gpt-image-1-mini&quot; else &quot;gpt-image-1&quot;&#10;        val fallbackModel = if (cost &lt;= 1) &quot;dall-e-2&quot; else &quot;dall-e-3&quot;&#10;        // Keep 512 for DALL·E mini budget to control cost; GPT-Image requires &gt;= 1024&#10;        val sdkSize = if (cost &lt;= 1) ImageSize.is512x512 else ImageSize.is1024x1024&#10;        val gptImageSizeString = &quot;1024x1024&quot;&#10;&#10;        try {&#10;            if (gptImageTemporarilyDisabled) {&#10;                logger.d { &quot;getOpenAIImageResponse: GPT-Image disabled for this session; using fallback=$fallbackModel&quot; }&#10;                throw IllegalStateException(&quot;skip-primary-and-use-fallback&quot;)&#10;            }&#10;            // 1) Try GPT Image first&#10;            val imageUrl = tryGenerate(primaryModel, sdkSize, gptImageSizeString)&#10;            logger.d { &quot;imageGen: ok model=$primaryModel kind=${if (imageUrl.startsWith(&quot;data:&quot;)) &quot;data&quot; else &quot;http&quot;}&quot; }&#10;&#10;            _addEditDreamState.value = addEditDreamState.value.copy(&#10;                dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                    response = imageUrl, isLoading = false&#10;                )&#10;            )&#10;            if (cost &gt; 0) authRepository.consumeDreamTokens(cost)&#10;            _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = false)&#10;        } catch (primary: Exception) {&#10;            logger.e { &quot;imageGen: fail primary: ${primary.message}&quot; }&#10;            // Always attempt fallback to DALL·E on primary failure&#10;            try {&#10;                val fallbackUrl = tryGenerate(fallbackModel, sdkSize, gptImageSizeString)&#10;                logger.d { &quot;imageGen: ok model=$fallbackModel kind=${if (fallbackUrl.startsWith(&quot;data:&quot;)) &quot;data&quot; else &quot;http&quot;} (fallback)&quot; }&#10;&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIImage = addEditDreamState.value.dreamAIImage.copy(&#10;                        response = fallbackUrl, isLoading = false&#10;                    )&#10;                )&#10;                if (cost &gt; 0) authRepository.consumeDreamTokens(cost)&#10;                _addEditDreamState.value = addEditDreamState.value.copy(isDreamExitOff = false)&#10;            } catch (fallback: Exception) {&#10;                logger.e { &quot;imageGen: fail primary+fallback: ${fallback.message ?: primary.message}&quot; }&#10;                addEditDreamState.value.snackBarHostState.value.showSnackbar(&#10;                    &quot;Error getting AI image: ${fallback.message ?: &quot;unknown error&quot;}&quot;,&#10;                    duration = SnackbarDuration.Short,&#10;                    actionLabel = &quot;Dismiss&quot;&#10;                )&#10;                _addEditDreamState.value = addEditDreamState.value.copy(&#10;                    dreamAIImage = addEditDreamState.value.dreamAIImage.copy(isLoading = false),&#10;                    isDreamExitOff = false&#10;                )&#10;            }&#10;         }&#10;     }&#10;&#10;    private suspend fun generateImageWithKtor(&#10;         apiKey: String,&#10;         model: String,&#10;         prompt: String,&#10;         sizeString: String,&#10;     ): String {&#10;         val bodyJson = &quot;&quot;&quot;&#10;             {&#10;                &quot;model&quot;: &quot;$model&quot;,&#10;                &quot;prompt&quot;: ${Json.encodeToString(prompt)},&#10;                &quot;size&quot;: &quot;$sizeString&quot;,&#10;                &quot;n&quot;: 1&#10;              }&#10;         &quot;&quot;&quot;.trimIndent()&#10;         val httpResponse = httpClient.post(&quot;https://api.openai.com/v1/images/generations&quot;) {&#10;             contentType(ContentType.Application.Json)&#10;             headers { append(&quot;Authorization&quot;, &quot;Bearer $apiKey&quot;) }&#10;             setBody(bodyJson)&#10;             timeout {&#10;                 requestTimeoutMillis = 70_000&#10;                 connectTimeoutMillis = 30_000&#10;                 socketTimeoutMillis = 70_000&#10;             }&#10;          }&#10;         val text = httpResponse.bodyAsText()&#10;         val root = Json.parseToJsonElement(text).jsonObject&#10;         val dataNode = root[&quot;data&quot;]&#10;         if (dataNode == null) {&#10;             // Surface OpenAI error if present to improve diagnostics and fallback behavior&#10;             val errorNode = root[&quot;error&quot;]?.jsonObject&#10;             val errMsg = errorNode?.get(&quot;message&quot;)?.jsonPrimitive?.content&#10;             val errType = errorNode?.get(&quot;type&quot;)?.jsonPrimitive?.content&#10;             val errMsgStr = errMsg ?: &quot;unknown&quot;&#10;             val errTypeSuffix = errType?.let { &quot; ($it)&quot; } ?: &quot;&quot;&#10;             error(&quot;OpenAI error: $errMsgStr$errTypeSuffix&quot;)&#10;         }&#10;         val data = dataNode as? JsonArray ?: error(&quot;Malformed response: data is not an array&quot;)&#10;         val first = data.firstOrNull()?.jsonObject ?: error(&quot;Empty data array in response&quot;)&#10;         // Prefer URL if present (DALL·E compat), else use b64_json (gpt-image-1 default)&#10;         val url = first[&quot;url&quot;]?.jsonPrimitive?.content&#10;         if (!url.isNullOrBlank()) return url&#10;         val b64 = first[&quot;b64_json&quot;]?.jsonPrimitive?.content&#10;         if (!b64.isNullOrBlank()) return &quot;data:image/png;base64,$b64&quot;&#10;         error(&quot;No url or b64_json in image response&quot;)&#10;     }&#10;&#10;    private fun loadWords() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Use the repository function you created&#10;            val words = dictionaryRepository.loadDictionaryWordsFromCsv(&quot;dream_dictionary.csv&quot;)&#10;&#10;            _addEditDreamState.update { state -&gt;&#10;                state.copy(&#10;                    dictionaryWordMutableList = words.toMutableList()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class AddEditDreamState(&#10;    val dreamInfo: DreamInfo = DreamInfo(&#10;        dreamId = &quot;&quot;,&#10;        dreamUID = &quot;&quot;,&#10;        dreamBackgroundImage = Dream.dreamBackgroundImages.indices.random(),&#10;        dreamIsLucid = false,&#10;        dreamIsFavorite = false,&#10;        dreamIsNightmare = false,&#10;        dreamIsRecurring = false,&#10;        dreamIsFalseAwakening = false,&#10;        dreamSleepTime = formatLocalTime(sleepTime),    // &quot;11:00 PM&quot;&#10;        dreamWakeTime = formatLocalTime(wakeTime),      // &quot;7:00 AM&quot;&#10;        dreamDate = formatLocalDate(currentDate),        // &quot;Jun 3, 2023&quot; for example&#10;        dreamTimeOfDay = &quot;&quot;,&#10;        dreamLucidity = 0,&#10;        dreamVividness = 0,&#10;        dreamEmotion = 0&#10;    ),&#10;    val dreamContentChanged: Boolean = true,&#10;    val dreamAIExplanation: DreamAIExplanation = DreamAIExplanation(&#10;        response = &quot;&quot;,&#10;        isLoading = false,&#10;        error = &quot;&quot;,&#10;    ),&#10;    val dreamAIImage: DreamAIImage = DreamAIImage(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIAdvice: DreamAIAdvice = DreamAIAdvice(&#10;        response = &quot;&quot;,&#10;        isLoading = false,&#10;        error = &quot;&quot;,&#10;    ),&#10;    val dreamGeneratedDetails: DreamAIGeneratedDetails = DreamAIGeneratedDetails(&#10;        response = &quot;&quot;, isLoading = false, isSuccessful = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIQuestionAnswer: DreamQuestionAIAnswer = DreamQuestionAIAnswer(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIStory: DreamStoryGeneration = DreamStoryGeneration(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamAIMoodAnalyser: DreamMoodAIAnalyser = DreamMoodAIAnalyser(&#10;        response = &quot;&quot;, isLoading = false, error = &quot;&quot;&#10;    ),&#10;    val dreamIsSavingLoading: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val saveSuccess: Boolean = false,&#10;    val dialogState: Boolean = false,&#10;    val calendarDialogState: Boolean = false,&#10;    val sleepTimePickerDialogState: Boolean = false,&#10;    val wakeTimePickerDialogState: Boolean = false,&#10;    val dreamImageGenerationPopUpState: Boolean = false,&#10;    val dreamInterpretationPopUpState: Boolean = false,&#10;    val dreamAdvicePopUpState: Boolean = false,&#10;    val dreamQuestionPopUpState: Boolean = false,&#10;    val dreamStoryPopupState: Boolean = false,&#10;    val dreamMoodPopupState: Boolean = false,&#10;    val isDreamExitOff: Boolean = false,&#10;    val snackBarHostState: MutableState&lt;SnackbarHostState&gt; = mutableStateOf(SnackbarHostState()),&#10;    val dictionaryWordMutableList: MutableList&lt;DictionaryWord&gt; = mutableListOf(),&#10;    val dreamFilteredDictionaryWords: List&lt;DictionaryWord&gt; = mutableListOf(),&#10;    val unlockedWords: MutableList&lt;String&gt; = mutableListOf(),&#10;    val bottomSheetState: Boolean = false,&#10;    val clickedWord: DictionaryWord = DictionaryWord(&quot;&quot;, &quot;&quot;, false, 0),&#10;    val isClickedWordUnlocked: Boolean = false,&#10;    val isDreamFilterLoading: Boolean = false,&#10;    val authRepository: AuthRepository,&#10;    val dreamTokens: Int = 0,&#10;    val dreamHasChanged: Boolean = false,&#10;    val isAdResponse: Boolean = false,&#10;    val isAdAdvice: Boolean = false,&#10;    val isAdQuestion: Boolean = false,&#10;    val isAdStory: Boolean = false,&#10;    val isAdMood: Boolean = false,&#10;    val isAdImage: Boolean = false&#10;)&#10;&#10;data class DreamAIExplanation(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamAIGeneratedDetails(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    val isSuccessful: Boolean = false, // This remains specific to this class&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamAIImage(&#10;    override val response: String = &quot;&quot;, // Specific to this class&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null&#10;) : AIData&#10;&#10;data class DreamAIAdvice(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamQuestionAIAnswer(&#10;    override val response: String = &quot;&quot;,&#10;    val question: String = &quot;&quot;, // Specific to this class&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamStoryGeneration(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamMoodAIAnalyser(&#10;    override val response: String = &quot;&quot;,&#10;    override val isLoading: Boolean = false,&#10;    override val error: String? = null,&#10;) : AIData&#10;&#10;data class DreamInfo(&#10;    val dreamId: String?,&#10;    val dreamUID: String?,&#10;    var dreamBackgroundImage: Int,&#10;    val dreamIsLucid: Boolean,&#10;    val dreamIsFavorite: Boolean,&#10;    val dreamIsNightmare: Boolean,&#10;    val dreamIsRecurring: Boolean,&#10;    val dreamIsFalseAwakening: Boolean,&#10;    val dreamSleepTime: String,&#10;    val dreamWakeTime: String,&#10;    val dreamDate: String,&#10;    val dreamTimeOfDay: String,&#10;    val dreamLucidity: Int,&#10;    val dreamVividness: Int,&#10;    val dreamEmotion: Int,&#10;)&#10;&#10;interface AIData {&#10;    val response: String&#10;    val isLoading: Boolean&#10;    val error: String?&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/data/DreamRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/data/DreamRepositoryImpl.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.data&#10;&#10;&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.firestore.CollectionReference&#10;import dev.gitlive.firebase.firestore.DocumentSnapshot&#10;import dev.gitlive.firebase.firestore.FirebaseFirestore&#10;import dev.gitlive.firebase.storage.Data&#10;import dev.gitlive.firebase.storage.storage&#10;import io.ktor.http.Url&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.withContext&#10;import org.ballistic.dreamjournalai.shared.core.Constants.USERS&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.Flag&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.util.decodeUrlPart&#10;import org.ballistic.dreamjournalai.shared.core.util.downloadImageBytes&#10;import org.ballistic.dreamjournalai.shared.core.util.toGitLiveData&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.repository.DreamRepository&#10;import kotlin.io.encoding.Base64&#10;import kotlin.io.encoding.ExperimentalEncodingApi&#10;import kotlin.time.ExperimentalTime&#10;import kotlin.uuid.ExperimentalUuidApi&#10;import kotlin.uuid.Uuid&#10;&#10;class DreamRepositoryImpl(&#10;    private val db: FirebaseFirestore&#10;) :&#10;private val readLogger = Logger.withTag(&quot;DJAI/Reads/Dreams&quot;)&#10;    DreamRepository {&#10;&#10;    private val dreamsCollection&#10;        get() = getCollectionReferenceForDreams()&#10;&#10;    private val flagsCollection: CollectionReference&#10;        get() = db.collection(&quot;flags&quot;)&#10;&#10;    private var currentDreamId: String = &quot;&quot;&#10;&#10;    // Add this function to get the current user's UID&#10;    private fun userID(): String? {&#10;        return Firebase.auth.currentUser?.uid&#10;    }&#10;    // Rough counters (client-side approximation only)&#10;    private var dreamsSnapshotEmissions: Int = 0&#10;    private var singleDocReads: Int = 0&#10;&#10;&#10;    override fun getDreams(): Flow&lt;List&lt;Dream&gt;&gt; {&#10;        val collection = getCollectionReferenceForDreams()&#10;            ?: return flowOf(emptyList())&#10;&#10;        // Keep mapping only; drop per-emission logging to reduce noise&#10;        return collection&#10;            .snapshots()&#10;            .map { querySnapshot -&gt;&#10;                    doc.toDream()&#10;                }&#10;            .onStart {&#10;                dreamsSnapshotEmissions = 0&#10;                readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ Subscribing to getDreams() snapshots for uid=${userID()} }&quot; }&#10;            }&#10;            .onEach { querySnapshot -&gt;&#10;                dreamsSnapshotEmissions += 1&#10;                val count = querySnapshot.documents.size&#10;                readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ Dreams snapshot #$dreamsSnapshotEmissions received, documents=$count }&quot; }&#10;            }&#10;            .onCompletion { cause -&gt;&#10;                if (cause == null) {&#10;                    readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ Unsubscribed from getDreams() snapshots cleanly after $dreamsSnapshotEmissions emissions }&quot; }&#10;                } else {&#10;                    readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ getDreams() snapshots completed with error: ${cause.message} after $dreamsSnapshotEmissions emissions }&quot; }&#10;                }&#10;            }&#10;            }&#10;    }&#10;&#10;    private fun DocumentSnapshot.toDream(): Dream? {&#10;        val dream = data&lt;Dream&gt;()&#10;&#10;        return dream.copy(&#10;            id = this.id,&#10;            uid = this.reference.parent.parent?.id ?: &quot;&quot;&#10;        )&#10;    }&#10;&#10;    override suspend fun getDream(id: String): Resource&lt;Dream&gt; {&#10;        return try {&#10;            val docRef = getCollectionReferenceForDreams()?.document(id)&#10;                ?: return Resource.Error(&quot;User not logged in or reference is null&quot;)&#10;&#10;        readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ getDream(id=$id) – performing single document read }&quot; }&#10;        singleDocReads += 1&#10;            val snapshot = docRef.get()&#10;            // 1) Get the doc reference from your &quot;my_dreams&quot; subcollection&#10;&#10;            if (snapshot.exists) {&#10;                Resource.Success(snapshot.getDream())&#10;            // 2) Fetch the snapshot (GitLive’s .get() is already a suspend function)&#10;            } else {&#10;                Resource.Error(&quot;Dream not found&quot;)&#10;            // 3) Check if the document exists, parse the data&#10;            }&#10;                readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ getDream(id=$id) – read success (exists=true). Total singleDocReads=$singleDocReads }&quot; }&#10;&#10;                val dream = snapshot.getDream()  // see extension below&#10;&#10;                Resource.Success(dream)&#10;        } catch (e: Exception) {&#10;                readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ getDream(id=$id) – document not found }&quot; }&#10;            Resource.Error(&quot;Error fetching dream: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;            readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ getDream(id=$id) – error: ${e.message} }&quot; }&#10;    private fun DocumentSnapshot.getDream(): Dream? {&#10;        val dream = data&lt;Dream&gt;()&#10;&#10;        return dream&#10;    }&#10;&#10;&#10;&#10;    override suspend fun getCurrentDreamId(): Resource&lt;String&gt; {&#10;        return Resource.Success(currentDreamId)&#10;    }&#10;&#10;    @OptIn(ExperimentalUuidApi::class, ExperimentalTime::class)&#10;    override suspend fun insertDream(dream: Dream): Resource&lt;Unit&gt; {&#10;        // One concise log for upsert intent&#10;        logger.d { &quot;insertDream: upsert id=${dream.id} httpImage=${dream.generatedImage.startsWith(&quot;http&quot;)}&quot; }&#10;        return try {&#10;            val existingDream = if (!dream.id.isNullOrEmpty()) getDream(dream.id) else null&#10;        logger.d { &quot;insertDream: Attempting to insert/update dream with ID: ${dream.id}&quot; }&#10;            suspend fun uploadImageIfNeeded(dreamToUpdate: Dream, oldImageUrl: String = &quot;&quot;): Dream {&#10;                 if (dreamToUpdate.generatedImage.isNotBlank() &amp;&amp;&#10;                     !dreamToUpdate.generatedImage.startsWith(&quot;https://firebasestorage.googleapis.com/&quot;)&#10;                if (dreamToUpdate.generatedImage.isNotBlank() &amp;&amp;&#10;                    !dreamToUpdate.generatedImage.startsWith(&quot;https://firebasestorage.googleapis.com/&quot;)&#10;                ) {&#10;                    logger.d { &quot;uploadImageIfNeeded: Uploading new image for dream&quot; }&#10;                         val targetPath = &quot;$uid/images/$fileKey&quot;&#10;                    return withContext(Dispatchers.IO) {&#10;                        val randomFileName = &quot;${Uuid.random()}.jpg&quot;&#10;                        logger.d { &quot;uploadImageIfNeeded: Generated random filename: $randomFileName&quot; }&#10;                         logger.d { &quot;uploadImageIfNeeded: Target path: $targetPath&quot; }&#10;                        val storageRef = Firebase.storage&#10;                            .reference(location = &quot;${userID()}/images/$randomFileName&quot;)&#10;                             val commaIdx = dreamToUpdate.generatedImage.indexOf(',')&#10;                        val imageBytes = downloadImageBytes(dreamToUpdate.generatedImage)&#10;                        logger.d { &quot;uploadImageIfNeeded: Downloaded image bytes (${imageBytes.size} bytes)&quot; }&#10;&#10;                        val gitLiveData: Data = imageBytes.toGitLiveData()&#10;                        storageRef.putData(gitLiveData)&#10;                        logger.d { &quot;uploadImageIfNeeded: Uploaded new image to Firebase Storage&quot; }&#10;                        // Add a tiny cache-busting parameter so image loaders don't reuse old bytes&#10;                        val downloadUrl = storageRef.getDownloadUrl()&#10;                        logger.d { &quot;uploadImageIfNeeded: New image download URL: $downloadUrl&quot; }&#10;                        val finalUrl = &quot;$downloadUrl&amp;v=$version&quot;&#10;                        // Parse the relative path from the oldImageUrl&#10;                        if (oldImageUrl.isNotBlank()) {&#10;                            val relativePath = parseFirebaseStoragePath(oldImageUrl)&#10;                            logger.d { &quot;uploadImageIfNeeded: Deleting old image at relative path: $relativePath&quot; }&#10;                return dreamToUpdate&#10;                            val oldRef = Firebase.storage.reference(relativePath)&#10;                            oldRef.delete()&#10;                        }&#10;                             logger.d { &quot;uploadImageIfNeeded: No old image URL provided; skipping delete&quot; }&#10;                        dreamToUpdate.copy(generatedImage = downloadUrl.toString())&#10;                    }&#10;                    logger.d { &quot;uploadImageIfNeeded: Skipping upload – already a Firebase Storage URL&quot; }&#10;                val updatedDream = existingDream.data.copy(&#10;            }&#10;                 return dreamToUpdate&#10;                    title = dream.title,&#10;                    content = dream.content,&#10;                    // Preserve original timestamp to keep list position stable&#10;                logger.d { &quot;insertDream: Dream exists, updating&quot; }&#10;&#10;                    timestamp = existingDream.data.timestamp,&#10;                    timestamp = dream.timestamp,&#10;                    wakeTime = dream.wakeTime,&#10;                    AIResponse = dream.AIResponse,&#10;                    isFavorite = dream.isFavorite,&#10;                    isLucid = dream.isLucid,&#10;                    isNightmare = dream.isNightmare,&#10;                    isRecurring = dream.isRecurring,&#10;                    falseAwakening = dream.falseAwakening,&#10;                    lucidityRating = dream.lucidityRating,&#10;                    moodRating = dream.moodRating,&#10;                    vividnessRating = dream.vividnessRating,&#10;                    timeOfDay = dream.timeOfDay,&#10;                    backgroundImage = dream.backgroundImage,&#10;                    generatedImage = dream.generatedImage,&#10;                    generatedDetails = dream.generatedDetails,&#10;                    dreamQuestion = dream.dreamQuestion,&#10;                    dreamAIQuestionAnswer = dream.dreamAIQuestionAnswer,&#10;                    dreamAIStory = dream.dreamAIStory,&#10;                    dreamAIAdvice = dream.dreamAIAdvice,&#10;                    dreamAIMood = dream.dreamAIMood,&#10;                    id = existingDream.data.id,&#10;                    uid = existingDream.data.uid&#10;                )&#10;&#10;                val updatedWithImage = uploadImageIfNeeded(updatedDream, existingDream.data.generatedImage)&#10;                getCollectionReferenceForDreams()?.document(updatedWithImage.id ?: &quot;&quot;)?.set(updatedWithImage)&#10;                logger.d { &quot;insertDream: Updated dream details: $updatedDream&quot; }&#10;                logger.d { &quot;insertDream: Updated dream details: $updatedDream (timestamp preserved=${existingDream.data.timestamp})&quot; }&#10;                val newDreamWithImage = uploadImageIfNeeded(dream)&#10;                getCollectionReferenceForDreams()?.document(dream.id ?: &quot;&quot;)?.set(newDreamWithImage)&#10;                logger.d { &quot;insertDream: Updated dream with new image details: $updatedWithImage&quot; }&#10;&#10;                val docRef = getCollectionReferenceForDreams()?.document(updatedWithImage.id ?: &quot;&quot;)&#10;                logger.d { &quot;insertDream: Firestore reference for update: ${docRef?.path}&quot; }&#10;                docRef?.set(updatedWithImage)&#10;&#10;                logger.d { &quot;insertDream: Creating new dream&quot; }&#10;&#10;            logger.d { &quot;insertDream: success id=${dream.id}&quot; }&#10;                logger.d { &quot;insertDream: New dream with image: $newDreamWithImage&quot; }&#10;&#10;                val docRef = getCollectionReferenceForDreams()?.document(dream.id ?: &quot;&quot;)&#10;                logger.d { &quot;insertDream: Firestore reference for new dream: ${docRef?.path}&quot; }&#10;                docRef?.set(newDreamWithImage)&#10;        } catch (e: Exception) {&#10;            logger.e(e) { &quot;insertDream: Error inserting dream&quot; }&#10;            logger.d { &quot;insertDream: Dream successfully inserted/updated&quot; }&#10;        }&#10;    }&#10;&#10;    fun parseFirebaseStoragePath(fullUrl: String): String {&#10;        val regex = &quot;&quot;&quot;https://firebasestorage.googleapis.com/v0/b/[^/]+/o/(.*)\?&quot;&quot;&quot;.toRegex()&#10;        val match = regex.find(fullUrl)&#10;        return match?.groupValues?.get(1)?.replace(&quot;%2F&quot;, &quot;/&quot;) // Decode URL-encoded path&#10;            ?: throw IllegalArgumentException(&quot;Invalid Firebase Storage URL: $fullUrl&quot;)&#10;    }&#10;&#10;&#10;    override suspend fun deleteDream(id: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // 1) Fetch the dream first (to remove image if present)&#10;            val dreamResult = getDream(id)&#10;            if (dreamResult is Resource.Success &amp;&amp; dreamResult.data != null) {&#10;        readLogger.d { &quot;Log.d(\&quot;DJAI/Reads/Dreams\&quot;){ deleteDream(id=$id) – will fetch dream first to remove image (additional read) }&quot; }&#10;                val dreamData = dreamResult.data&#10;            // 1) Fetch the dream first&#10;                // 2) If dream has a generated image, remove it from Firebase Storage&#10;                if (dreamData.generatedImage.isNotBlank()) {&#10;                    val imageUrl = dreamData.generatedImage&#10;&#10;                    val ktorUrl = Url(imageUrl)&#10;                    val pathPortion = ktorUrl.encodedPath.substringAfter(&quot;/o/&quot;).substringBefore(&quot;?&quot;)&#10;                    // Example URL:&#10;                    // &quot;https://firebasestorage.googleapis.com/v0/b/&lt;bucket&gt;/o/users%2Fuid%2Fimages%2Ffilename.jpg?alt=media...&quot;&#10;                    val decodedPath = decodeUrlPart(pathPortion)&#10;                    val imageRef = Firebase.storage.reference(decodedPath)&#10;                    // 2a) Parse with Ktor's Url (works in KMM)&#10;                    imageRef.delete()&#10;                    // e.g. ktorUrl.encodedPath might be: &quot;/v0/b/&lt;bucket&gt;/o/users%2Fuid%2Fimages%2Ffilename.jpg&quot;&#10;                }&#10;                    // e.g. &quot;users%2Fuid%2Fimages%2Ffilename.jpg&quot;&#10;&#10;                    // 2b) Decode the path. Ktor has decodeURLPart(...) for URL-encoded strings&#10;            }&#10;                    // e.g. &quot;users/uid/images/filename.jpg&quot;&#10;&#10;                    // 3) Build a reference in GitLive&#10;&#10;&#10;                    // 4) Delete the file (suspend call in GitLive)&#10;            // 5) Remove the dream doc from Firestore&#10;            dreamsCollection?.document(id)?.delete()&#10;            logger.d { &quot;deleteDream: success id=$id&quot; }&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Error deleting dream: ${e.message}&quot;)&#10;&#10;    }&#10;&#10;    override suspend fun flagDream(&#10;        dreamId: String?,&#10;        imageAddress: String?&#10;    ): Resource&lt;Unit&gt; {&#10;        if (dreamId.isNullOrBlank() &amp;&amp; imageAddress.isNullOrBlank()) {&#10;            return Resource.Error(&quot;Either dreamId or imageAddress must be provided to flag content.&quot;)&#10;        }&#10;&#10;        return try {&#10;            val flag = Flag(&#10;                dreamId = dreamId?.takeIf { it.isNotBlank() } ?: &quot;&quot;,&#10;                imageAddress = imageAddress?.takeIf { it.isNotBlank() } ?: &quot;&quot;&#10;            )&#10;&#10;            flagsCollection.add(flag)&#10;&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Error flagging content: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getCollectionReferenceForDreams(): CollectionReference? {&#10;        val user = Firebase.auth.currentUser&#10;&#10;        return user?.uid?.let { uid -&gt;&#10;            db.collection(USERS) // &quot;USERS&quot; is your top-level collection&#10;                .document(uid)   // user's document&#10;                .collection(&quot;my_dreams&quot;)  // the &quot;my_dreams&quot; subcollection&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.data&#10;&#10;&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.firestore.CollectionReference&#10;import dev.gitlive.firebase.firestore.DocumentSnapshot&#10;import dev.gitlive.firebase.firestore.FirebaseFirestore&#10;import dev.gitlive.firebase.storage.Data&#10;import dev.gitlive.firebase.storage.storage&#10;import io.ktor.http.Url&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.withContext&#10;import org.ballistic.dreamjournalai.shared.core.Constants.USERS&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.Flag&#10;import org.ballistic.dreamjournalai.shared.core.util.decodeUrlPart&#10;import org.ballistic.dreamjournalai.shared.core.util.downloadImageBytes&#10;import org.ballistic.dreamjournalai.shared.core.util.toGitLiveData&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.repository.DreamRepository&#10;import kotlin.io.encoding.Base64&#10;import kotlin.io.encoding.ExperimentalEncodingApi&#10;import kotlin.time.ExperimentalTime&#10;import kotlin.uuid.ExperimentalUuidApi&#10;import kotlin.uuid.Uuid&#10;&#10;private val logger = Logger.withTag(&quot;DreamRepositoryImpl&quot;)&#10;&#10;class DreamRepositoryImpl(&#10;    private val db: FirebaseFirestore&#10;) :&#10;    DreamRepository {&#10;&#10;    private val dreamsCollection&#10;        get() = getCollectionReferenceForDreams()&#10;&#10;    private val flagsCollection: CollectionReference&#10;        get() = db.collection(&quot;flags&quot;)&#10;&#10;    private var currentDreamId: String = &quot;&quot;&#10;&#10;    // Add this function to get the current user's UID&#10;    private fun userID(): String? {&#10;        return Firebase.auth.currentUser?.uid&#10;    }&#10;&#10;    override fun getDreams(): Flow&lt;List&lt;Dream&gt;&gt; {&#10;        val collection = getCollectionReferenceForDreams()&#10;            ?: return flowOf(emptyList())&#10;&#10;        // Keep mapping only; drop per-emission logging to reduce noise&#10;        return collection&#10;            .snapshots()&#10;            .map { querySnapshot -&gt;&#10;                querySnapshot.documents.mapNotNull { doc -&gt;&#10;                    doc.toDream()&#10;                }&#10;            }&#10;    }&#10;&#10;    private fun DocumentSnapshot.toDream(): Dream? {&#10;        val dream = data&lt;Dream&gt;()&#10;&#10;        return dream.copy(&#10;            id = this.id,&#10;            uid = this.reference.parent.parent?.id ?: &quot;&quot;&#10;        )&#10;    }&#10;&#10;    override suspend fun getDream(id: String): Resource&lt;Dream&gt; {&#10;        return try {&#10;            val docRef = getCollectionReferenceForDreams()?.document(id)&#10;                ?: return Resource.Error(&quot;User not logged in or reference is null&quot;)&#10;&#10;            val snapshot = docRef.get()&#10;&#10;            if (snapshot.exists) {&#10;                // Ensure id/uid are populated on single reads as well&#10;                val dream = snapshot.getDream()&#10;                Resource.Success(dream)&#10;            } else {&#10;                Resource.Error(&quot;Dream not found&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Error fetching dream: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun DocumentSnapshot.getDream(): Dream {&#10;        val base = data&lt;Dream&gt;()&#10;        return base.copy(&#10;            id = this.id,&#10;            uid = this.reference.parent.parent?.id ?: &quot;&quot;&#10;        )&#10;    }&#10;&#10;&#10;&#10;    override suspend fun getCurrentDreamId(): Resource&lt;String&gt; {&#10;        return Resource.Success(currentDreamId)&#10;    }&#10;&#10;    @OptIn(ExperimentalUuidApi::class, ExperimentalTime::class)&#10;    override suspend fun insertDream(dream: Dream): Resource&lt;Unit&gt; {&#10;        logger.d { &quot;insertDream: upsert id=${dream.id} httpImage=${dream.generatedImage.startsWith(&quot;http&quot;)}&quot; }&#10;        return try {&#10;            // Ensure a stable ID for document and storage path&#10;            val ensuredId = dream.id?.takeIf { it.isNotBlank() } ?: Uuid.random().toString()&#10;            val ensuredUid = userID() ?: &quot;&quot;&#10;&#10;            val existingDream = if (dream.id.isNullOrBlank()) null else getDream(dream.id)&#10;&#10;            @OptIn(ExperimentalEncodingApi::class)&#10;            suspend fun uploadImageIfNeeded(d: Dream): Dream {&#10;                if (d.generatedImage.isBlank()) return d&#10;                // If it's already a Firebase Storage URL, keep it&#10;                val alreadyStorageUrl = d.generatedImage.startsWith(&quot;https://firebasestorage.googleapis.com/&quot;)&#10;                if (alreadyStorageUrl) return d&#10;&#10;                return withContext(Dispatchers.IO) {&#10;                    // Overwrite in-place at a stable location derived from dream ID&#10;                    val targetPath = &quot;$ensuredUid/images/$ensuredId.jpg&quot;&#10;                    val storageRef = Firebase.storage.reference(location = targetPath)&#10;&#10;                    val isDataUrl = d.generatedImage.startsWith(&quot;data:&quot;)&#10;                    val imageBytes = if (isDataUrl) {&#10;                        val commaIdx = d.generatedImage.indexOf(',')&#10;                        val b64 = if (commaIdx &gt;= 0) d.generatedImage.substring(commaIdx + 1) else &quot;&quot;&#10;                        if (b64.isBlank()) ByteArray(0) else Base64.decode(b64)&#10;                    } else {&#10;                        downloadImageBytes(d.generatedImage)&#10;                    }&#10;&#10;                    val gitLiveData: Data = imageBytes.toGitLiveData()&#10;                    storageRef.putData(gitLiveData)&#10;                    val downloadUrl = storageRef.getDownloadUrl().toString()&#10;                    val sep = if (downloadUrl.contains('?')) '&amp;' else '?'&#10;                    val version = kotlin.time.Clock.System.now().toEpochMilliseconds()&#10;                    val finalUrl = &quot;$downloadUrl${sep}v=$version&quot;&#10;&#10;                    // No need to delete the old image; overwrite happened in-place&#10;                    d.copy(generatedImage = finalUrl)&#10;                }&#10;            }&#10;&#10;            if (existingDream is Resource.Success &amp;&amp; existingDream.data != null) {&#10;                val base = existingDream.data&#10;                val updated = base.copy(&#10;                    title = dream.title,&#10;                    content = dream.content,&#10;                    // Preserve original timestamp to keep list order stable&#10;                    timestamp = base.timestamp,&#10;                    date = dream.date,&#10;                    sleepTime = dream.sleepTime,&#10;                    wakeTime = dream.wakeTime,&#10;                    AIResponse = dream.AIResponse,&#10;                    isFavorite = dream.isFavorite,&#10;                    isLucid = dream.isLucid,&#10;                    isNightmare = dream.isNightmare,&#10;                    isRecurring = dream.isRecurring,&#10;                    falseAwakening = dream.falseAwakening,&#10;                    lucidityRating = dream.lucidityRating,&#10;                    moodRating = dream.moodRating,&#10;                    vividnessRating = dream.vividnessRating,&#10;                    timeOfDay = dream.timeOfDay,&#10;                    backgroundImage = dream.backgroundImage,&#10;                    generatedImage = dream.generatedImage,&#10;                    generatedDetails = dream.generatedDetails,&#10;                    dreamQuestion = dream.dreamQuestion,&#10;                    dreamAIQuestionAnswer = dream.dreamAIQuestionAnswer,&#10;                    dreamAIStory = dream.dreamAIStory,&#10;                    dreamAIAdvice = dream.dreamAIAdvice,&#10;                    dreamAIMood = dream.dreamAIMood,&#10;                    id = ensuredId,&#10;                    uid = ensuredUid&#10;                )&#10;                val updatedWithImage = uploadImageIfNeeded(updated)&#10;                getCollectionReferenceForDreams()?.document(ensuredId)?.set(updatedWithImage)&#10;            } else {&#10;                val newDream = dream.copy(id = ensuredId, uid = ensuredUid)&#10;                val newWithImage = uploadImageIfNeeded(newDream)&#10;                getCollectionReferenceForDreams()?.document(ensuredId)?.set(newWithImage)&#10;            }&#10;&#10;            logger.d { &quot;insertDream: success id=$ensuredId&quot; }&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            logger.e(e) { &quot;insertDream: Error inserting dream&quot; }&#10;            Resource.Error(&quot;Error inserting dream: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun parseFirebaseStoragePath(fullUrl: String): String {&#10;        val regex = &quot;&quot;&quot;https://firebasestorage.googleapis.com/v0/b/[^/]+/o/(.*)\?&quot;&quot;&quot;.toRegex()&#10;        val match = regex.find(fullUrl)&#10;        return match?.groupValues?.get(1)?.replace(&quot;%2F&quot;, &quot;/&quot;) // Decode URL-encoded path&#10;            ?: throw IllegalArgumentException(&quot;Invalid Firebase Storage URL: $fullUrl&quot;)&#10;    }&#10;&#10;&#10;    override suspend fun deleteDream(id: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // 1) Fetch the dream first (to remove image if present)&#10;            val dreamResult = getDream(id)&#10;            if (dreamResult is Resource.Success &amp;&amp; dreamResult.data != null) {&#10;                val dreamData = dreamResult.data&#10;&#10;                // 2) If dream has a generated image, remove it from Firebase Storage&#10;                if (dreamData.generatedImage.isNotBlank()) {&#10;                    val imageUrl = dreamData.generatedImage&#10;&#10;                    val ktorUrl = Url(imageUrl)&#10;                    val pathPortion = ktorUrl.encodedPath.substringAfter(&quot;/o/&quot;).substringBefore(&quot;?&quot;)&#10;                    val decodedPath = decodeUrlPart(pathPortion)&#10;                    val imageRef = Firebase.storage.reference(decodedPath)&#10;                    imageRef.delete()&#10;                }&#10;            }&#10;&#10;            // 5) Remove the dream doc from Firestore&#10;            dreamsCollection?.document(id)?.delete()&#10;            logger.d { &quot;deleteDream: success id=$id&quot; }&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Error deleting dream: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun flagDream(&#10;        dreamId: String?,&#10;        imageAddress: String?&#10;    ): Resource&lt;Unit&gt; {&#10;        if (dreamId.isNullOrBlank() &amp;&amp; imageAddress.isNullOrBlank()) {&#10;            return Resource.Error(&quot;Either dreamId or imageAddress must be provided to flag content.&quot;)&#10;        }&#10;&#10;        return try {&#10;            val flag = Flag(&#10;                dreamId = dreamId?.takeIf { it.isNotBlank() } ?: &quot;&quot;,&#10;                imageAddress = imageAddress?.takeIf { it.isNotBlank() } ?: &quot;&quot;&#10;            )&#10;&#10;            flagsCollection.add(flag)&#10;&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Error flagging content: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getCollectionReferenceForDreams(): CollectionReference? {&#10;        val user = Firebase.auth.currentUser&#10;&#10;        return user?.uid?.let { uid -&gt;&#10;            db.collection(USERS) // &quot;USERS&quot; is your top-level collection&#10;                .document(uid)   // user's document&#10;                .collection(&quot;my_dreams&quot;)  // the &quot;my_dreams&quot; subcollection&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;// Animation&#10;// Resources&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.zIndex&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.new_dream_prompt&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;        onMainEvent(MainScreenEvent.SetFloatingActionButtonState(true))&#10;        onMainEvent(MainScreenEvent.SetDrawerState(true))&#10;    }&#10;&#10;&#10;    // compute an empty-prompt boolean from the available state fields&#10;    val showEmptyPrompt = remember(dreamJournalListState.dreams, dreamJournalListState.isSearching, dreamJournalListState.isLoading) {&#10;        dreamJournalListState.dreams.isEmpty() &amp;&amp; !dreamJournalListState.isSearching &amp;&amp; !dreamJournalListState.isLoading&#10;    }&#10;&#10;    // Animatable for scale in animation used by the empty prompt&#10;    val scaleAnim = remember { Animatable(0f) }&#10;&#10;    LaunchedEffect(showEmptyPrompt) {&#10;        if (showEmptyPrompt) {&#10;            // Start from 0 and bounce to full size&#10;            scaleAnim.snapTo(0f)&#10;            scaleAnim.animateTo(&#10;    // Local top padding placeholder (replace with measured top bar inset if needed)&#10;    val topPadding = 0.dp&#10;                    dampingRatio = Spring.DampingRatioMediumBouncy,&#10;                    stiffness = Spring.StiffnessLow&#10;                )&#10;                // Undo is handled in the viewmodel via events now&#10;            },&#10;            onClickOutside = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            }&#10;        )&#10;    }&#10;&#10;                onDreamListEvent(DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!))&#10;        topBar = {&#10;            DreamListScreenTopBar(&#10;                dreamJournalListState = dreamJournalListState,&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                searchTextFieldState = searchTextFieldState,&#10;                onDreamListEvent = onDreamListEvent,&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;        // Wrap list in a Box so we can overlay the empty-state prompt above bottom nav&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .dynamicBottomNavigationPadding()&#10;                    .padding(top = topPadding, bottom = bottomPaddingValue),&#10;                contentPadding = PaddingValues(bottom = 16.dp),&#10;            ) {&#10;             },&#10;             onClickOutside = {&#10;                 onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;             }&#10;         )&#10;     }&#10;    LaunchedEffect(showEmptyPrompt) {&#10;                            null&#10;                        }&#10;                    }&#10;                        compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                            .thenByDescending { it.second.timestamp }&#10;                    )&#10;                 dreamJournalListState = dreamJournalListState,&#10;                 mainScreenViewModelState = mainScreenViewModelState,&#10;                 searchTextFieldState = searchTextFieldState,&#10;                sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;             )&#10;         },&#10;         containerColor = Color.Transparent&#10;                        DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;        // Animation state for scale-in bounce of the empty prompt&#10;        val scaleAnim = remember { Animatable(0f) }&#10;        LaunchedEffect(dreamJournalListState.showEmptyPrompt) {&#10;            if (dreamJournalListState.showEmptyPrompt) {&#10;                // Start from 0 and bounce to full size&#10;                scaleAnim.snapTo(0f)&#10;                scaleAnim.animateTo(&#10;                    targetValue = 1f,&#10;                    animationSpec = spring&lt;Float&gt;(&#10;                        dampingRatio = Spring.DampingRatioMediumBouncy,&#10;                        stiffness = Spring.StiffnessLow&#10;            // Step 1: Parse and Sort Dreams&#10;                )&#10;            } else {&#10;                // Hide instantly when prompt should not be shown&#10;                scaleAnim.snapTo(0f)&#10;            }&#10;                onDreamListEvent = onDreamListEvent,&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        }&#10;    ) { innerPadding -&gt;&#10;            scaleAnim.animateTo(&#10;                    }&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;                    val dream = pair.second&#10;                    .padding(top = topPadding, bottom = bottomPaddingValue),&#10;                .dynamicBottomNavigationPadding()&#10;                .padding(top = topPadding, bottom = bottomPaddingValue),&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        ) {&#10;                            .padding(bottom = 10.dp)&#10;                                 onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                                 onNavigateToDream(dream.id, dream.backgroundImage)&#10;                             },&#10;                             onDeleteClick = {&#10;                    items(dreams) { pair: Pair&lt;LocalDate, Dream&gt; -&gt;&#10;                        val dream = pair.second&#10;                        DreamItem(&#10;                            dream = dream,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(bottom = 10.dp)&#10;                                .padding(horizontal = 20.dp),&#10;                            onClick = {&#10;                                onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                                onNavigateToDream(dream.id, dream.backgroundImage)&#10;                            },&#10;                            onDeleteClick = {&#10;                                onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                                onDreamListEvent(&#10;                                    DreamListEvent.DreamToDelete(dream)&#10;                                )&#10;                                onDreamListEvent(&#10;                                    DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                                )&#10;                            }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                targetValue = -8f,&#10;                }&#10;            if (dreamJournalListState.showEmptyPrompt) {&#10;                    repeatMode = RepeatMode.Reverse&#10;            // Empty state prompt: floaty hint above FAB/bottom nav&#10;            if (showEmptyPrompt) {&#10;                         initialValue = 0f,&#10;                // Subtle floating animation for the prompt image&#10;                val infiniteTransition = rememberInfiniteTransition(label = &quot;float_prompt&quot;)&#10;                val floatOffset by infiniteTransition.animateFloat(&#10;                    initialValue = 0f,&#10;                    targetValue = -8f,&#10;                    animationSpec = infiniteRepeatable(&#10;                        animation = tween(durationMillis = 1600, easing = FastOutSlowInEasing),&#10;                        repeatMode = RepeatMode.Reverse&#10;                Image(&#10;                    painter = painterResource(Res.drawable.new_dream_prompt),&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        // Slightly larger but still centered&#10;                        .fillMaxWidth(0.65f)&#10;                        // Scale-in with bounce&#10;                        .scale(scaleAnim.value)&#10;                        // Keep above bottom nav and near the FAB area; tweak padding as needed&#10;                        .padding(bottom = bottomPaddingValue)&#10;                        .padding(bottom = 8.dp)&#10;                        .dynamicBottomNavigationPadding()&#10;                        // Float a bit upwards and downwards&#10;&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;// Animation&#10;// Resources&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.EnterTransition&#10;import androidx.compose.animation.ExitTransition&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.zIndex&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.new_dream_prompt&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamJournalListScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;        onMainEvent(MainScreenEvent.SetFloatingActionButtonState(true))&#10;        onMainEvent(MainScreenEvent.SetDrawerState(true))&#10;    }&#10;&#10;&#10;    // compute an empty-prompt boolean from the available state fields&#10;    val showEmptyPrompt = remember(dreamJournalListState.dreams, dreamJournalListState.isSearching, dreamJournalListState.isLoading) {&#10;        dreamJournalListState.dreams.isEmpty() &amp;&amp; !dreamJournalListState.isSearching &amp;&amp; !dreamJournalListState.isLoading&#10;    }&#10;&#10;    // Delete confirmation bottom sheet (outside Scaffold, as before)&#10;    if (dreamJournalListState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            modifier = Modifier.padding(),&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;                onDreamListEvent(&#10;                    DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!)&#10;                )&#10;                // Undo is handled in the viewmodel via events now&#10;            },&#10;            onClickOutside = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            }&#10;        )&#10;    }&#10;&#10;    // Wrap content in a Scaffold to show the top app bar&#10;    Scaffold(&#10;        containerColor = Color.Transparent,&#10;        topBar = {&#10;            DreamListScreenTopBar(&#10;                dreamJournalListState = dreamJournalListState,&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                searchTextFieldState = searchTextFieldState,&#10;                onDreamListEvent = onDreamListEvent,&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;        // Wrap list in a Box so we can overlay the empty-state prompt above bottom nav&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .dynamicBottomNavigationPadding()&#10;                    .padding(top = topPadding, bottom = bottomPaddingValue),&#10;                contentPadding = PaddingValues(bottom = 16.dp),&#10;            ) {&#10;&#10;                // Step 1: Parse and Sort Dreams&#10;                val sortedGroupedDreams = dreamJournalListState.dreams&#10;                    .mapNotNull { dream -&gt;&#10;                        try {&#10;                            val parsedDate = parseCustomDate(dream.date)&#10;                            Pair(parsedDate, dream)&#10;                        } catch (_: IllegalArgumentException) {&#10;                            null&#10;                        }&#10;                    }&#10;                    .sortedWith(&#10;                        compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                            .thenByDescending { it.second.timestamp }&#10;                    )&#10;                    .groupBy { it.first }&#10;&#10;                // Step 2: Iterate Through Groups&#10;                sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;                    // Sticky Header for the Date&#10;                    stickyHeader {&#10;                        DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;                    }&#10;&#10;                    // Items for Each Dream in the Date Group&#10;                    items(dreams) { (/*date*/ _, dream): Pair&lt;LocalDate, Dream&gt; -&gt;&#10;                         DreamItem(&#10;                             dream = dream,&#10;                             modifier = Modifier&#10;                                 .fillMaxWidth()&#10;                                 .padding(bottom = 10.dp)&#10;                                 .padding(horizontal = 20.dp),&#10;                             onClick = {&#10;                                 onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                                 onNavigateToDream(dream.id, dream.backgroundImage)&#10;                             },&#10;                             onDeleteClick = {&#10;                                 onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                                 onDreamListEvent(&#10;                                     DreamListEvent.DreamToDelete(dream)&#10;                                 )&#10;                                 onDreamListEvent(&#10;                                     DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                                 )&#10;                             }&#10;                         )&#10;                         Spacer(modifier = Modifier.height(4.dp))&#10;                     }&#10;                 }&#10;             }&#10;&#10;             // Empty state prompt: floaty hint above FAB/bottom nav (single instance)&#10;             AnimatedVisibility(&#10;                 visible = showEmptyPrompt,&#10;                 enter = EnterTransition.None,&#10;                 exit = ExitTransition.None,&#10;                 modifier = Modifier.fillMaxSize()&#10;             ) {&#10;                 // Use a Box scope so .align works correctly inside AnimatedVisibility&#10;                 Box(modifier = Modifier.fillMaxSize()) {&#10;                     val infiniteTransition = rememberInfiniteTransition(label = &quot;float_prompt&quot;)&#10;                     val floatOffset by infiniteTransition.animateFloat(&#10;                         initialValue = 0f,&#10;                         targetValue = -8f,&#10;                         animationSpec = infiniteRepeatable(&#10;                             animation = tween(durationMillis = 1600, easing = FastOutSlowInEasing),&#10;                             repeatMode = RepeatMode.Reverse&#10;                         ),&#10;                         label = &quot;float_offset&quot;&#10;                     )&#10;&#10;                     Image(&#10;                         painter = painterResource(Res.drawable.new_dream_prompt),&#10;                         contentDescription = null,&#10;                         modifier = Modifier&#10;                             .align(Alignment.BottomCenter)&#10;                             .zIndex(1f)&#10;                             .fillMaxWidth(0.65f)&#10;                             .padding(bottom = bottomPaddingValue)&#10;                             .padding(bottom = 8.dp)&#10;                             .offset(y = floatOffset.dp)&#10;                     )&#10;                 }&#10;             }&#10;         }&#10;     }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.SubcomposeAsyncImage&#10;import coil3.compose.SubcomposeAsyncImageContent&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;        }&#10;&#10;    // Only run border/shimmer animations if hasBorder is true to avoid unnecessary redraws&#10;    val borderThickness = if (hasBorder) {&#10;        val t = rememberInfiniteTransition(label = &quot;border&quot;)&#10;        t.animateFloat(&#10;            initialValue = 4f,&#10;            targetValue = 6f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;borderThickness&quot;&#10;        )&#10;    } else null&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush() else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            )&#10;            .border(&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                onLongClick = {&#10;                    isLongPressTriggered = true&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    SubcomposeAsyncImage(&#10;                        model = generatedImage,&#10;                        contentDescription = &quot;Dream Image&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop,&#10;                        loading = {&#10;                            // Fallback + shimmer while loading/empty&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Placeholder&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .shimmerEffect()&#10;                            )&#10;                        },&#10;                        error = {&#10;                            // Fallback on error&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Fallback&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                        },&#10;                        success = {&#10;                            SubcomposeAsyncImageContent()&#10;                        }&#10;                    )&#10;                } else {&#10;                     Image(&#10;                         painter = painterResource(chosenBackground),&#10;                         modifier = Modifier.fillMaxSize(),&#10;                         contentScale = ContentScale.Crop,&#10;                         contentDescription = &quot;Dream Image&quot;&#10;                     )&#10;                 }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(): Brush {&#10;    val transition = rememberInfiniteTransition(label = &quot;borderBrush&quot;)&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.SubcomposeAsyncImage&#10;import coil3.compose.SubcomposeAsyncImageContent&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.runtime.key&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;        }&#10;&#10;    // Only run border/shimmer animations if hasBorder is true to avoid unnecessary redraws&#10;    val borderThickness = if (hasBorder) {&#10;        val t = rememberInfiniteTransition(label = &quot;border&quot;)&#10;        t.animateFloat(&#10;            initialValue = 4f,&#10;            targetValue = 6f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;borderThickness&quot;&#10;        )&#10;    } else null&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush() else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            )&#10;            .border(&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                onLongClick = {&#10;                    isLongPressTriggered = true&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    // Force a fresh subcomposition when the image string changes&#10;                    key(generatedImage) {&#10;                        SubcomposeAsyncImage(&#10;                            model = generatedImage,&#10;                            contentDescription = &quot;Dream Image&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop,&#10;                            loading = {&#10;                                // Fallback + shimmer while loading/empty&#10;                                Image(&#10;                                    painter = painterResource(chosenBackground),&#10;                                    contentDescription = &quot;Dream Image Placeholder&quot;,&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    contentScale = ContentScale.Crop&#10;                                )&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .shimmerEffect()&#10;                                )&#10;                            },&#10;                            error = {&#10;                                // Fallback on error&#10;                                Image(&#10;                                    painter = painterResource(chosenBackground),&#10;                                    contentDescription = &quot;Dream Image Fallback&quot;,&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    contentScale = ContentScale.Crop&#10;                                )&#10;                            },&#10;                            success = {&#10;                                SubcomposeAsyncImageContent()&#10;                            }&#10;                        )&#10;                    }&#10;                } else {&#10;                     Image(&#10;                         painter = painterResource(chosenBackground),&#10;                         modifier = Modifier.fillMaxSize(),&#10;                         contentScale = ContentScale.Crop,&#10;                         contentDescription = &quot;Dream Image&quot;&#10;                     )&#10;                 }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(): Brush {&#10;    val transition = rememberInfiniteTransition(label = &quot;borderBrush&quot;)&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/viewmodel/DreamJournalListViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/viewmodel/DreamJournalListViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.flatMapLatest&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.util.OrderType&#10;&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class DreamJournalListViewModel(&#10;    private val dreamUseCases: DreamUseCases,&#10;    private val vibratorUtil: VibratorUtil,&#10; //   private val reviewComponent: ReviewComponent&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val UNDO_TIMEOUT_MS = 10_000L // align with SnackbarDuration.Long&#10;    }&#10;&#10;    private val _dreamJournalListState = MutableStateFlow(DreamJournalListState())&#10;    val dreamJournalListState: StateFlow&lt;DreamJournalListState&gt; = _dreamJournalListState.asStateFlow()&#10;    private val _searchTextFieldState = MutableStateFlow(TextFieldState())&#10;    val searchTextFieldState: StateFlow&lt;TextFieldState&gt; = _searchTextFieldState.asStateFlow()&#10;&#10;    private var recentlyDeletedDream: Dream? = null&#10;&#10;    // ids hidden locally until user confirms or undo timeout elapses&#10;    private val filteredOutIds = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())&#10;    // job per pending delete to cancel on undo&#10;    private val pendingDeletes = mutableMapOf&lt;String, Job&gt;()&#10;&#10;    private var getDreamJob: Job? = null&#10;&#10;    init {&#10;        onEvent(DreamListEvent.FetchDreams)&#10;    private var getDreamJob: Job? = null&#10;    fun onEvent(event: DreamListEvent) {&#10;        when (event) {&#10;            is DreamListEvent.DeleteDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val id = event.dream.id&#10;                    if (id == null) {&#10;                        // Fallback: if no id, perform immediate delete (cannot defer reliably)&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        return@launch&#10;                    }&#10;                    // Soft-delete locally: hide from list and schedule finalization&#10;                    recentlyDeletedDream = event.dream&#10;                    filteredOutIds.value = filteredOutIds.value + id&#10;                    // schedule finalize&#10;                    pendingDeletes[id]?.cancel()&#10;                    pendingDeletes[id] = launch {&#10;                        delay(UNDO_TIMEOUT_MS)&#10;                        // If still pending (no undo), perform remote delete&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        pendingDeletes.remove(id)&#10;                        if (recentlyDeletedDream?.id == id) recentlyDeletedDream = null&#10;                    }&#10;                    // Reintroduce undo snackbar via centralized controller&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { viewModelScope.launch { onEvent(DreamListEvent.RestoreDream) } }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerReview -&gt; {&#10;                // For example, check conditions before prompting&#10;                val dreamCount = dreamJournalListState.value.dreams.size&#10;                if (dreamCount &gt;= 2) {&#10;//                    viewModelScope.launch {&#10;//                        reviewComponent.requestInAppReview().collect { resultCode -&gt;&#10;//                           //TODO: Handle result code&#10;//                        }&#10;//                    }&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerVibration -&gt; {&#10;                vibratorUtil.triggerVibration()&#10;            }&#10;            is DreamListEvent.ToggleOrderSection -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isOrderSectionVisible = !dreamJournalListState.value.isOrderSectionVisible)&#10;            }&#10;            is DreamListEvent.RestoreDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val dreamToRestore = recentlyDeletedDream ?: return@launch&#10;                    val id = dreamToRestore.id&#10;                    if (id != null) {&#10;                        // Cancel pending remote delete if any and unfilter locally&#10;                        pendingDeletes[id]?.cancel()&#10;                        pendingDeletes.remove(id)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        // If remote delete already happened (race), re-add dream&#10;                        // We can't trivially detect it without an extra call; adding is idempotent enough&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    } else {&#10;                        // No id: just re-add to repository&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    }&#10;                    recentlyDeletedDream = null&#10;                }&#10;            }&#10;            is DreamListEvent.Order -&gt; {&#10;                // Update order type; the single subscription will react via flatMapLatest&#10;                if (dreamJournalListState.value.orderType != event.orderType) {&#10;                    _dreamJournalListState.value = _dreamJournalListState.value.copy(orderType = event.orderType)&#10;                    orderTypeFlow.value = event.orderType&#10;                }&#10;            }&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isSearching = event.state&#10;            is DreamListEvent.ToggleBottomDeleteCancelSheetState -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    bottomDeleteCancelSheetState = event.bottomDeleteCancelSheetState&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.DreamToDelete -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    chosenDreamToDelete = event.dream&#10;                )&#10;            }&#10;            is DreamListEvent.FetchDreams -&gt; {&#10;                // Build a single subscription that reacts to order changes and search text&#10;                var getDreamJob: Job? = null&#10;                getDreamJob?.cancel()&#10;                val orderTypeFlow = MutableStateFlow(dreamJournalListState.value.orderType)&#10;                orderTypeFlow&#10;                        else dreams.filter { it.doesMatchSearchQuery(searchText.toString()) }&#10;                    }&#10;                    .onEach { filteredDreams -&gt;&#10;                        _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                            dreams = filteredDreams,&#10;                            orderType = orderTypeFlow.value,&#10;                        )&#10;                    }&#10;                    .launchIn(viewModelScope)&#10;            }&#10;        }&#10;    }&#10;&#10;                        _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;            .combine(&#10;                snapshotFlow { searchTextFieldState.value.text }&#10;            .combine(filteredOutIds) { dreams, filteredIds -&gt;&#10;                dreams.filter { it.id == null || it.id !in filteredIds }&#10;            }&#10;            .onEach { visibleDreams -&gt;&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    dreams = visibleDreams,&#10;                    orderType = orderType,&#10;                )&#10;            }&#10;            .launchIn(viewModelScope)&#10;    }&#10;}&#10;&#10;&#10;data class DreamJournalListState(&#10;    val dreams: List&lt;Dream&gt; = emptyList(),&#10;    val bottomDeleteCancelSheetState: Boolean = false,&#10;    val chosenDreamToDelete: Dream? = null,&#10;    val orderType: OrderType = OrderType.Date,&#10;    val isOrderSectionVisible: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val isSearching: Boolean = false,&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.flatMapLatest&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.flow.onStart&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.util.OrderType&#10;&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class DreamJournalListViewModel(&#10;    private val dreamUseCases: DreamUseCases,&#10;    private val vibratorUtil: VibratorUtil,&#10; //   private val reviewComponent: ReviewComponent&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val UNDO_TIMEOUT_MS = 10_000L // align with SnackbarDuration.Long&#10;    }&#10;&#10;    private val _dreamJournalListState = MutableStateFlow(DreamJournalListState())&#10;    val dreamJournalListState: StateFlow&lt;DreamJournalListState&gt; = _dreamJournalListState.asStateFlow()&#10;    private val _searchTextFieldState = MutableStateFlow(TextFieldState())&#10;    val searchTextFieldState: StateFlow&lt;TextFieldState&gt; = _searchTextFieldState.asStateFlow()&#10;&#10;    // Backing flow for current order type used to drive the single subscription&#10;    private val orderTypeFlow: MutableStateFlow&lt;OrderType&gt; = MutableStateFlow(OrderType.Date)&#10;&#10;    private var recentlyDeletedDream: Dream? = null&#10;&#10;    // ids hidden locally until user confirms or undo timeout elapses&#10;    private val filteredOutIds = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())&#10;    // job per pending delete to cancel on undo&#10;    private val pendingDeletes = mutableMapOf&lt;String, Job&gt;()&#10;&#10;    private var getDreamJob: Job? = null&#10;&#10;    init {&#10;        onEvent(DreamListEvent.FetchDreams)&#10;    }&#10;&#10;    fun onEvent(event: DreamListEvent) {&#10;        when (event) {&#10;            is DreamListEvent.DeleteDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val id = event.dream.id&#10;                    if (id == null) {&#10;                        // Fallback: if no id, perform immediate delete (cannot defer reliably)&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        return@launch&#10;                    }&#10;                    // Soft-delete locally: hide from list and schedule finalization&#10;                    recentlyDeletedDream = event.dream&#10;                    filteredOutIds.value = filteredOutIds.value + id&#10;                    // schedule finalize&#10;                    pendingDeletes[id]?.cancel()&#10;                    pendingDeletes[id] = launch {&#10;                        delay(UNDO_TIMEOUT_MS)&#10;                        // If still pending (no undo), perform remote delete&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        pendingDeletes.remove(id)&#10;                        if (recentlyDeletedDream?.id == id) recentlyDeletedDream = null&#10;                    }&#10;                    // Reintroduce undo snackbar via centralized controller&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { viewModelScope.launch { onEvent(DreamListEvent.RestoreDream) } }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerReview -&gt; {&#10;                // For example, check conditions before prompting&#10;                val dreamCount = dreamJournalListState.value.dreams.size&#10;                if (dreamCount &gt;= 2) {&#10;                    // reserved for future in-app review prompt&#10;                    // viewModelScope.launch {&#10;                    //     reviewComponent.requestInAppReview().collect { resultCode -&gt;&#10;                    //         // TODO: Handle result code&#10;                    //     }&#10;                    // }&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerVibration -&gt; {&#10;                vibratorUtil.triggerVibration()&#10;            }&#10;            is DreamListEvent.ToggleOrderSection -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isOrderSectionVisible = !dreamJournalListState.value.isOrderSectionVisible)&#10;            }&#10;            is DreamListEvent.RestoreDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val dreamToRestore = recentlyDeletedDream ?: return@launch&#10;                    val id = dreamToRestore.id&#10;                    if (id != null) {&#10;                        // Cancel pending remote delete if any and unfilter locally&#10;                        pendingDeletes[id]?.cancel()&#10;                        pendingDeletes.remove(id)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        // If remote delete already happened (race), re-add dream&#10;                        // We can't trivially detect it without an extra call; adding is idempotent enough&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    } else {&#10;                        // No id: just re-add to repository&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    }&#10;                    recentlyDeletedDream = null&#10;                }&#10;            }&#10;            is DreamListEvent.Order -&gt; {&#10;                // Update order type; the single subscription will react via flatMapLatest&#10;                if (dreamJournalListState.value.orderType != event.orderType) {&#10;                    _dreamJournalListState.value = _dreamJournalListState.value.copy(orderType = event.orderType)&#10;                    orderTypeFlow.value = event.orderType&#10;                }&#10;            }&#10;            is DreamListEvent.SetSearchingState -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isSearching = event.state&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.ToggleBottomDeleteCancelSheetState -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    bottomDeleteCancelSheetState = event.bottomDeleteCancelSheetState&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.DreamToDelete -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    chosenDreamToDelete = event.dream&#10;                )&#10;            }&#10;            is DreamListEvent.FetchDreams -&gt; {&#10;                // Build a single subscription that reacts to order changes and search text&#10;                getDreamJob?.cancel()&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(isLoading = true)&#10;                orderTypeFlow.value = dreamJournalListState.value.orderType&#10;                orderTypeFlow&#10;                    .flatMapLatest { orderType -&gt;&#10;                        dreamUseCases.getDreams(orderType)&#10;                    }&#10;                    .combine(&#10;                        snapshotFlow { searchTextFieldState.value.text }&#10;                    ) { dreams, searchText -&gt;&#10;                        if (searchText.isBlank()) dreams&#10;                        else dreams.filter { it.doesMatchSearchQuery(searchText.toString()) }&#10;                    }&#10;                    .combine(filteredOutIds) { dreams, filteredIds -&gt;&#10;                        dreams.filter { it.id == null || it.id !in filteredIds }&#10;                    }&#10;                    .onStart {&#10;                        _dreamJournalListState.value = _dreamJournalListState.value.copy(isLoading = true)&#10;                    }&#10;                    .onEach { filteredDreams -&gt;&#10;                        _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                            dreams = filteredDreams,&#10;                            orderType = orderTypeFlow.value,&#10;                            isLoading = false,&#10;                        )&#10;                    }&#10;                    .launchIn(viewModelScope)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;data class DreamJournalListState(&#10;    val dreams: List&lt;Dream&gt; = emptyList(),&#10;    val bottomDeleteCancelSheetState: Boolean = false,&#10;    val chosenDreamToDelete: Dream? = null,&#10;    val orderType: OrderType = OrderType.Date,&#10;    val isOrderSectionVisible: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val isSearching: Boolean = false,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState())&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;MainScreenViewModel initialized&quot; }&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;onEvent: $event&quot; }&#10;        when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                // store plain string in state; composables should handle text input and emit events&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    searchedText = event.query&#10;                )&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let { msg -&gt;&#10;                        viewModelScope.launch {&#10;                            SnackbarController.sendEvent(&#10;                                org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                                    message = msg,&#10;                                    action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                            message = event.message,&#10;                            action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                // ViewModel does not own a DrawerState (Compose UI object). Instead, store intent as a boolean.&#10;                Logger.d(&quot;MainScreenViewModel&quot;) { &quot;ToggleDrawerState -&gt; ${event.drawerValue}&quot; }&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isDrawerOpen = (event.drawerValue != DrawerValue.Closed)&#10;                )&#10;            }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    // ViewModel no longer holds a Compose DrawerState; instead expose a simple boolean intent&#10;    val isDrawerOpen: Boolean = false,&#10;    // Keep search text as a plain String for stability; composables handle input&#10;    val searchedText: String = &quot;&quot;,&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState())&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;         when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                // store plain string in state; composables should handle text input and emit events&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    searchedText = event.query&#10;                )&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let { msg -&gt;&#10;                        viewModelScope.launch {&#10;                            SnackbarController.sendEvent(&#10;                                org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                                    message = msg,&#10;                                    action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                            message = event.message,&#10;                            action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                // ViewModel does not own a DrawerState (Compose UI object). Instead, store intent as a boolean.&#10;                 _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                     isDrawerOpen = (event.drawerValue != DrawerValue.Closed)&#10;                 )&#10;             }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    // ViewModel no longer holds a Compose DrawerState; instead expose a simple boolean intent&#10;    val isDrawerOpen: Boolean = false,&#10;    // Keep search text as a plain String for stability; composables handle input&#10;    val searchedText: String = &quot;&quot;,&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>