<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/data/repository/AuthRespositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_authentication/data/repository/AuthRespositoryImpl.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.data.repository&#10;&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;import dev.gitlive.firebase.auth.AuthResult&#10;import dev.gitlive.firebase.auth.EmailAuthProvider&#10;import dev.gitlive.firebase.auth.FirebaseAuth&#10;import dev.gitlive.firebase.auth.FirebaseAuthUserCollisionException&#10;import dev.gitlive.firebase.auth.FirebaseUser&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.firestore.FieldValue&#10;import dev.gitlive.firebase.firestore.FieldValue.Companion.serverTimestamp&#10;import dev.gitlive.firebase.firestore.FirebaseFirestore&#10;import dev.gitlive.firebase.firestore.firestore&#10;import dev.gitlive.firebase.functions.FirebaseFunctionsException&#10;import dev.gitlive.firebase.functions.code&#10;import dev.gitlive.firebase.functions.details&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthStateResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.ReloadUserResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SendPasswordResetEmailResponse&#10;import org.ballistic.dreamjournalai.shared.core.Constants.CREATED_AT&#10;import org.ballistic.dreamjournalai.shared.core.Constants.DISPLAY_NAME&#10;import org.ballistic.dreamjournalai.shared.core.Constants.EMAIL&#10;import org.ballistic.dreamjournalai.shared.core.Constants.USERS&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class AuthRepositoryImpl (&#10;    private val auth: FirebaseAuth,&#10;    private val db: FirebaseFirestore,&#10;) : AuthRepository {&#10;    private var anonymousUserId: String? = null&#10;&#10;    private val _dreamTokens = MutableStateFlow(0)&#10;    override val dreamTokens: StateFlow&lt;Int&gt; = _dreamTokens&#10;&#10;    private val _isUserExist = MutableStateFlow(false)&#10;    override val isUserExist: StateFlow&lt;Boolean&gt; = _isUserExist&#10;&#10;    private val _isLoggedIn = MutableStateFlow(false)&#10;    override val isLoggedIn: StateFlow&lt;Boolean&gt; = _isLoggedIn&#10;&#10;    private val _emailVerified = MutableStateFlow(false)&#10;    override val isEmailVerified: StateFlow&lt;Boolean&gt; = _emailVerified&#10;&#10;    private val _isUserAnonymous = MutableStateFlow(false)&#10;    override val isUserAnonymous: StateFlow&lt;Boolean&gt; = _isUserAnonymous&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    override suspend fun firebaseSignInWithGoogle(&#10;        googleCredential: AuthCredential&#10;    ): Flow&lt;Resource&lt;Pair&lt;AuthResult, String?&gt;&gt;&gt; {&#10;        return flow {&#10;            Logger.d { &quot;AuthRepositoryImpl: firebaseSignInWithGoogle called with credential=$googleCredential&quot; }&#10;             emit(Resource.Loading())&#10;             try {&#10;                 val anonymousUserId = if (auth.currentUser?.isAnonymous == true) {&#10;                     auth.currentUser?.uid&#10;                 } else {&#10;                     null&#10;                 }&#10;&#10;                 val result = auth.signInWithCredential(googleCredential)&#10;&#10;                Logger.d { &quot;AuthRepositoryImpl: signInWithCredential succeeded user=${result.user?.uid}, isNew=${result.additionalUserInfo?.isNewUser}&quot; }&#10;                 val isNewUser = result.additionalUserInfo?.isNewUser == true&#10;&#10;                 emit(Resource.Success(Pair(result, anonymousUserId)))&#10;             } catch (e: FirebaseAuthUserCollisionException) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;) { &quot;FirebaseAuthUserCollisionException: ${e.message}&quot; }&#10;                 emit(Resource.Error(&quot;An existing user account was found with the same credentials: ${e.message}&quot;))&#10;             } catch (e: Exception) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;) { &quot;firebaseSignInWithGoogle failed: ${e.message}&quot; }&#10;                 emit(Resource.Error(&quot;Failed to sign in with Google: ${e.message}&quot;))&#10;             }&#10;&#10;         }&#10;     }&#10;&#10;    override suspend fun consumeDreamTokens(tokensToConsume: Int): Resource&lt;Boolean&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // 1) Get the currently signed-in user from dev.gitlive.firebase.auth&#10;                val user = Firebase.auth.currentUser&#10;                    ?: return@withContext Resource.Error(&quot;User is not logged in.&quot;)&#10;&#10;                // 2) Get a reference to the &quot;USERS/{userId}&quot; document in Firestore&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // 3) Fetch the snapshot (this is already a suspend call with dev.gitlive)&#10;                val snapshot = userDocRef.get()&#10;                val data = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;)&#10;                val tokens = data.toLong()&#10;&#10;&#10;                // 4) Check if user has enough tokens, then update&#10;                if (tokens &gt;= tokensToConsume) {&#10;                    userDocRef.update(mapOf(&quot;dreamTokens&quot; to tokens - tokensToConsume))&#10;                    Resource.Success(true)&#10;                } else {&#10;                    Resource.Error(&quot;Not enough dream tokens available.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Resource.Error(&quot;Failed to consume dream tokens: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun unlockWord(word: String, tokenCost: Int): Resource&lt;Boolean&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // 1) Get the current user from dev.gitlive.auth&#10;                val user = Firebase.auth.currentUser&#10;                    ?: return@withContext Resource.Error(&quot;User is not logged in.&quot;)&#10;&#10;                // 2) Reference the user document: &quot;USERS/{uid}&quot;&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // 3) Fetch the snapshot (suspend call in dev.gitlive)&#10;                val snapshot = userDocRef.get()&#10;&#10;                // 4) Decode the snapshot's data into a Map&#10;                val unlockedWords = snapshot.get&lt;List&lt;String&gt;&gt;(&quot;unlockedWords&quot;).toMutableList()&#10;                val userTokens = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;).toLong()&#10;&#10;                // 6) If the word is already unlocked, just return success&#10;                if (unlockedWords.contains(word)) {&#10;                    return@withContext Resource.Success(true)&#10;                }&#10;&#10;                // 7) Check user has enough tokens (if cost &gt; 0)&#10;                if (tokenCost &gt; 0 &amp;&amp; userTokens &lt; tokenCost) {&#10;                    return@withContext Resource.Error(&quot;Not enough dream tokens&quot;)&#10;                }&#10;&#10;                // 8) Deduct tokens if needed (presumably calls another method in your repo)&#10;                if (tokenCost &gt; 0) {&#10;                    consumeDreamTokens(tokenCost) // must also be updated to dev.gitlive calls&#10;                }&#10;&#10;                // 9) Add new word to the unlocked list&#10;                unlockedWords.add(word)&#10;&#10;                // 10) Update the doc in Firestore&#10;                userDocRef.update(mapOf(&quot;unlockedWords&quot; to unlockedWords))&#10;&#10;                Resource.Success(true)&#10;&#10;            } catch (e: Exception) {&#10;                Resource.Error(&quot;Failed to unlock word: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getUnlockedWords(): Flow&lt;Resource&lt;List&lt;String&gt;&gt;&gt; = flow {&#10;        emit(Resource.Loading())&#10;&#10;        // Retrieve the current user&#10;        val currentUser = Firebase.auth.currentUser&#10;        if (currentUser == null) {&#10;            emit(Resource.Error(&quot;No user is logged in.&quot;))&#10;            return@flow&#10;        }&#10;&#10;        try {&#10;            // Reference to the user's document: USERS/{uid}&#10;            val userDocRef = Firebase.firestore&#10;                .collection(USERS)&#10;                .document(currentUser.uid)&#10;&#10;            // Fetch the user document (suspend call)&#10;            val snapshot = userDocRef.get()&#10;&#10;            // Check if the document exists&#10;            if (snapshot.exists) {&#10;                // Retrieve the 'unlockedWords' field as a List&lt;String&gt;&#10;                val unlockedWords = snapshot.get(&quot;unlockedWords&quot;) as? List&lt;String&gt; ?: emptyList()&#10;&#10;                Logger.d(&quot;Unlocked words: $unlockedWords&quot;)&#10;                emit(Resource.Success(unlockedWords))&#10;            } else {&#10;                emit(Resource.Error(&quot;User document does not exist.&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Logger.e(&quot;Failed to get unlocked words&quot;, e)&#10;            emit(Resource.Error(&quot;Failed to get unlocked words: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun recordUserInteraction() {&#10;        // If you need to reload the user, do it via dev.gitlive as well&#10;        reloadFirebaseUser()&#10;&#10;        val user = Firebase.auth.currentUser&#10;        if (user != null) {&#10;            try {&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // Set the 'lastActiveTimestamp' to server time, merging with existing fields&#10;                userDocRef.set(&#10;                    data = mapOf(&quot;lastActiveTimestamp&quot; to FieldValue.serverTimestamp),&#10;                    merge = true&#10;                )&#10;&#10;            } catch (e: Exception) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;){ &quot;Failed to record user interaction: $e&quot; }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private suspend fun validateUser() {&#10;        val user = Firebase.auth.currentUser&#10;&#10;        // Update your local states or flows&#10;        _isUserExist.value = user != null&#10;        _emailVerified.value = user?.isEmailVerified ?: false&#10;        _isLoggedIn.value = user != null &amp;&amp; user.isEmailVerified == true&#10;        _isUserAnonymous.value = user?.isAnonymous ?: false&#10;&#10;        // If user is verified, update FireStore&#10;        if (user != null &amp;&amp; user.isEmailVerified) {&#10;            try {&#10;                val userDocRef = Firebase&#10;                    .firestore&#10;                    .collection(USERS)&#10;                    .document(user.uid)&#10;&#10;                // 'update(...)' is a suspend function in dev.gitlive&#10;                userDocRef.update(mapOf(&quot;emailVerified&quot; to true))&#10;&#10;                // Optionally log success&#10;                // Log.d(&quot;Firestore&quot;, &quot;Email verification status updated successfully&quot;)&#10;            } catch (e: Exception) {&#10;                // Log or handle the error&#10;                // Log.e(&quot;Firestore&quot;, &quot;Error updating email verification status: &quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun anonymousSignIn(): Flow&lt;Resource&lt;AuthResult&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            val authResult = Firebase.auth.signInAnonymously()&#10;            emit(Resource.Success(authResult))&#10;        }.catch { e -&gt;&#10;            emit(Resource.Error(e.toString()))&#10;        }&#10;    }&#10;    private suspend fun addUserToFirestore(registrationTimestamp: Long) {&#10;            val user = toUser(registrationTimestamp)&#10;            db.collection(USERS).document(uid).set(user)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    override suspend fun firebaseSignUpWithEmailAndPassword(&#10;        email: String,&#10;        password: String&#10;    ): Flow&lt;Resource&lt;String&gt;&gt; {&#10;&#10;        // Check if the current user is anonymous and store the user ID if so&#10;        anonymousUserId = if (Firebase.auth.currentUser?.isAnonymous == true) {&#10;            Firebase.auth.currentUser?.uid&#10;        } else {&#10;            null&#10;        }&#10;&#10;        @Serializable&#10;        data class CreateAccountResponse(val message: String)&#10;&#10;        return flow {&#10;            emit(Resource.Loading())&#10;&#10;            try {&#10;                val data = mapOf(&#10;                    &quot;email&quot; to email,&#10;                    &quot;password&quot; to password&#10;                )&#10;&#10;                val result = Firebase.functions&#10;                    .httpsCallable(&quot;createAccountAndSendEmailVerification&quot;)&#10;                    .invoke(data)&#10;&#10;                val response = result.data&lt;CreateAccountResponse&gt;()&#10;                val message = response.message&#10;&#10;                addUserToFirestore(registrationTimestamp = kotlin.time.Clock.System.now().toEpochMilliseconds())&#10;&#10;                emit(Resource.Success(message))&#10;&#10;            } catch (e: Exception) {&#10;                emit(Resource.Error(&quot;SignUp error: ${e.message}&quot;))&#10;            }&#10;        }.catch { e -&gt;&#10;            emit(Resource.Error(e.toString()))&#10;        }&#10;    }&#10;&#10;&#10;&#10;    override suspend fun sendEmailVerification(): Flow&lt;Resource&lt;Boolean&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            try {&#10;                auth.currentUser?.sendEmailVerification()&#10;                emit(Resource.Success(true))&#10;            } catch (e: Exception) {&#10;                emit(Resource.Error(e.toString()))&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun firebaseSignInWithEmailAndPassword(&#10;        email: String,&#10;        password: String,&#10;    ): Flow&lt;Resource&lt;AuthResult&gt;&gt; {&#10;        anonymousUserId = if (auth.currentUser?.isAnonymous == true) {&#10;            auth.currentUser?.uid&#10;        } else {&#10;            null&#10;        }&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            try {&#10;                val currentUser = auth.currentUser&#10;&#10;                if (currentUser != null &amp;&amp; anonymousUserId != null &amp;&amp; anonymousUserId != &quot;&quot;) {&#10;                    val result = auth.signInWithEmailAndPassword(email, password)&#10;&#10;                    result.user?.let {&#10;                        transferDreamsFromAnonymousToPermanent(&#10;                            it.uid, anonymousUserId ?: &quot;&quot;&#10;                        )&#10;                    }&#10;                    emit(Resource.Success(result))&#10;                } else {&#10;                    val result = auth.signInWithEmailAndPassword(email, password)&#10;                    emit(Resource.Success(result))&#10;                }&#10;            } catch (e: FirebaseAuthUserCollisionException) {&#10;                val result = auth.signInWithEmailAndPassword(email, password)&#10;                emit(Resource.Success(result))&#10;            } catch (e: Exception) {&#10;                emit(Resource.Error(e.toString()))&#10;            }&#10;            validateUser()&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun reloadFirebaseUser(): ReloadUserResponse {&#10;        return try {&#10;            auth.currentUser?.reload()&#10;            Resource.Success(true)&#10;        } catch (e: Exception) {&#10;            Resource.Error(e.message ?: &quot;Unknown error&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun sendPasswordResetEmail(email: String): SendPasswordResetEmailResponse {&#10;        return try {&#10;            auth.sendPasswordResetEmail(email)&#10;            Resource.Success(true)&#10;        } catch (e: Exception) {&#10;            Resource.Error(e.message ?: &quot;Unknown error&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun signOut() = auth.signOut()&#10;&#10;    override suspend fun revokeAccess(&#10;        password: String?&#10;    ): Flow&lt;Resource&lt;Boolean&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;&#10;            try {&#10;                val user = Firebase.auth.currentUser&#10;                    ?: throw IllegalStateException(&quot;No authenticated user found&quot;)&#10;&#10;                Logger.withTag(&quot;AuthRepo&quot;).d { &quot;revokeAccess start uid=${user.uid} email=${user.email} providerData=${user.providerData.map { it.providerId }} passwordProvided=${!password.isNullOrBlank()}&quot; }&#10;&#10;                if (!password.isNullOrBlank() &amp;&amp; !user.email.isNullOrBlank()) {&#10;                    val credential = EmailAuthProvider.credential(user.email!!, password)&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;reauthenticating user=${user.uid} via EmailAuthProvider&quot; }&#10;                    user.reauthenticate(credential)&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;reauthenticate success&quot; }&#10;                } else {&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;skipping reauth (no password provided or missing email)&quot; }&#10;                }&#10;&#10;                user.delete()&#10;                Logger.withTag(&quot;AuthRepo&quot;).d { &quot;user.delete() success&quot; }&#10;&#10;                emit(Resource.Success(true))&#10;&#10;            } catch (e: Exception) {&#10;                Logger.withTag(&quot;AuthRepo&quot;).e { &quot;revokeAccess error: ${e.message}&quot; }&#10;                emit(Resource.Error(&quot;Failed to revoke access: ${e.message}&quot;, false))&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override fun getAuthState(viewModelScope: CoroutineScope): AuthStateResponse {&#10;        return Firebase.auth.authStateChanged&#10;            // Map the Flow&lt;FirebaseUser?&gt; to Flow&lt;Boolean&gt;&#10;            .map { user -&gt; user == null }&#10;            // Convert the flow to a StateFlow&lt;Boolean&gt;&#10;            .stateIn(&#10;                scope = viewModelScope,&#10;                started = SharingStarted.WhileSubscribed(),&#10;                // If currentUser is null, the initial value should be true (logged out)&#10;                initialValue = (Firebase.auth.currentUser == null)&#10;            )&#10;    }&#10;&#10;    override suspend fun transferDreamsFromAnonymousToPermanent(&#10;        permanentUid: String,&#10;        anonymousUid: String&#10;    ) {&#10;        @Serializable&#10;        data class HandleAccountLinkingResponse(&#10;            val success: Boolean = false,&#10;            val message: String? = null&#10;        )&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                val result = Firebase.functions&#10;                    .httpsCallable(&quot;handleAccountLinking&quot;)&#10;                    .invoke(&#10;                        mapOf(&quot;permanentUid&quot; to permanentUid, &quot;anonymousUid&quot; to anonymousUid)&#10;                    )&#10;&#10;                // Decode into a typed, serializable model to avoid Any serializer issues&#10;                val data = result.data&lt;HandleAccountLinkingResponse&gt;()&#10;                val success = data.success&#10;&#10;                if (success) {&#10;                    println(&quot;Dreams transferred successfully. Proceed to clean up anonymous account if needed.&quot;)&#10;                } else {&#10;                    println(&quot;Failed to transfer dreams: ${data.message}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                when (e) {&#10;                    is FirebaseFunctionsException -&gt; {&#10;                        println(&quot;Firebase Functions error: code=${e.code}, details=${e.details}&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        println(&quot;Error transferring dreams: $e&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun addDreamTokensFlowListener(): Flow&lt;Resource&lt;String&gt;&gt; {&#10;        val user = Firebase.auth.currentUser&#10;        if (user == null) {&#10;            // Immediately return a flow that emits an error&#10;            return flowOf(Resource.Error(&quot;User is not logged in&quot;))&#10;        }&#10;&#10;        val docRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;        // Create one flow with `flow {}`, then collect snapshots inside it&#10;        return flow {&#10;            // 1) Emit a loading state up front&#10;            emit(Resource.Loading())&#10;&#10;            // 2) Collect snapshots in this same flow builder&#10;            docRef.snapshots().collect { snapshot -&gt;&#10;                val data = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;)&#10;                val dreamTokens = data.toString()&#10;                _dreamTokens.value = dreamTokens.toInt()&#10;&#10;                // 3) Emit a success each time we get new data&#10;                emit(Resource.Success(dreamTokens))&#10;            }&#10;        }.catch { e -&gt;&#10;            // 4) Catch any exceptions thrown in the flow&#10;            emit(Resource.Error(e.message ?: &quot;Unknown error&quot;))&#10;        }&#10;    }&#10;}&#10;&#10;    DISPLAY_NAME to displayName,&#10;    EMAIL to email,&#10;    CREATED_AT to serverTimestamp,&#10;    &quot;registrationTimestamp&quot; to registrationTimestamp,&#10;    &quot;lastSignInTimestamp&quot; to serverTimestamp,&#10;)&#10;&#10; )&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_authentication.data.repository&#10;&#10;import co.touchlab.kermit.Logger&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.AuthCredential&#10;import dev.gitlive.firebase.auth.AuthResult&#10;import dev.gitlive.firebase.auth.EmailAuthProvider&#10;import dev.gitlive.firebase.auth.FirebaseAuth&#10;import dev.gitlive.firebase.auth.FirebaseAuthUserCollisionException&#10;import dev.gitlive.firebase.auth.FirebaseUser&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.firestore.FieldValue&#10;import dev.gitlive.firebase.firestore.FieldValue.Companion.serverTimestamp&#10;import dev.gitlive.firebase.firestore.FirebaseFirestore&#10;import dev.gitlive.firebase.firestore.firestore&#10;import dev.gitlive.firebase.functions.FirebaseFunctionsException&#10;import dev.gitlive.firebase.functions.code&#10;import dev.gitlive.firebase.functions.details&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.IO&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthStateResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.ReloadUserResponse&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.SendPasswordResetEmailResponse&#10;import org.ballistic.dreamjournalai.shared.core.Constants.CREATED_AT&#10;import org.ballistic.dreamjournalai.shared.core.Constants.DISPLAY_NAME&#10;import org.ballistic.dreamjournalai.shared.core.Constants.EMAIL&#10;import org.ballistic.dreamjournalai.shared.core.Constants.USERS&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class AuthRepositoryImpl (&#10;    private val auth: FirebaseAuth,&#10;    private val db: FirebaseFirestore,&#10;) : AuthRepository {&#10;    private var anonymousUserId: String? = null&#10;&#10;    private val _dreamTokens = MutableStateFlow(0)&#10;    override val dreamTokens: StateFlow&lt;Int&gt; = _dreamTokens&#10;&#10;    private val _isUserExist = MutableStateFlow(false)&#10;    override val isUserExist: StateFlow&lt;Boolean&gt; = _isUserExist&#10;&#10;    private val _isLoggedIn = MutableStateFlow(false)&#10;    override val isLoggedIn: StateFlow&lt;Boolean&gt; = _isLoggedIn&#10;&#10;    private val _emailVerified = MutableStateFlow(false)&#10;    override val isEmailVerified: StateFlow&lt;Boolean&gt; = _emailVerified&#10;&#10;    private val _isUserAnonymous = MutableStateFlow(false)&#10;    override val isUserAnonymous: StateFlow&lt;Boolean&gt; = _isUserAnonymous&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    override suspend fun firebaseSignInWithGoogle(&#10;        googleCredential: AuthCredential&#10;    ): Flow&lt;Resource&lt;Pair&lt;AuthResult, String?&gt;&gt;&gt; {&#10;        return flow {&#10;            Logger.d { &quot;AuthRepositoryImpl: firebaseSignInWithGoogle called with credential=$googleCredential&quot; }&#10;             emit(Resource.Loading())&#10;             try {&#10;                 val anonymousUserId = if (auth.currentUser?.isAnonymous == true) {&#10;                     auth.currentUser?.uid&#10;                 } else {&#10;                     null&#10;                 }&#10;&#10;                 val result = auth.signInWithCredential(googleCredential)&#10;&#10;                Logger.d { &quot;AuthRepositoryImpl: signInWithCredential succeeded user=${result.user?.uid}, isNew=${result.additionalUserInfo?.isNewUser}&quot; }&#10;                 val isNewUser = result.additionalUserInfo?.isNewUser == true&#10;&#10;                // For brand-new Google users, create the Firestore doc with safe defaults.&#10;                if (isNewUser) {&#10;                    addUserToFirestore(registrationTimestamp = kotlin.time.Clock.System.now().toEpochMilliseconds())&#10;                }&#10;&#10;                 emit(Resource.Success(Pair(result, anonymousUserId)))&#10;             } catch (e: FirebaseAuthUserCollisionException) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;) { &quot;FirebaseAuthUserCollisionException: ${e.message}&quot; }&#10;                 emit(Resource.Error(&quot;An existing user account was found with the same credentials: ${e.message}&quot;))&#10;             } catch (e: Exception) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;) { &quot;firebaseSignInWithGoogle failed: ${e.message}&quot; }&#10;                 emit(Resource.Error(&quot;Failed to sign in with Google: ${e.message}&quot;))&#10;             }&#10;&#10;         }&#10;     }&#10;&#10;    override suspend fun consumeDreamTokens(tokensToConsume: Int): Resource&lt;Boolean&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // 1) Get the currently signed-in user from dev.gitlive.firebase.auth&#10;                val user = Firebase.auth.currentUser&#10;                    ?: return@withContext Resource.Error(&quot;User is not logged in.&quot;)&#10;&#10;                // 2) Get a reference to the &quot;USERS/{userId}&quot; document in Firestore&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // 3) Fetch the snapshot (this is already a suspend call with dev.gitlive)&#10;                val snapshot = userDocRef.get()&#10;                val data = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;)&#10;                val tokens = data.toLong()&#10;&#10;&#10;                // 4) Check if user has enough tokens, then update&#10;                if (tokens &gt;= tokensToConsume) {&#10;                    userDocRef.update(mapOf(&quot;dreamTokens&quot; to tokens - tokensToConsume))&#10;                    Resource.Success(true)&#10;                } else {&#10;                    Resource.Error(&quot;Not enough dream tokens available.&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Resource.Error(&quot;Failed to consume dream tokens: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun unlockWord(word: String, tokenCost: Int): Resource&lt;Boolean&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // 1) Get the current user from dev.gitlive.auth&#10;                val user = Firebase.auth.currentUser&#10;                    ?: return@withContext Resource.Error(&quot;User is not logged in.&quot;)&#10;&#10;                // 2) Reference the user document: &quot;USERS/{uid}&quot;&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // 3) Fetch the snapshot (suspend call in dev.gitlive)&#10;                val snapshot = userDocRef.get()&#10;&#10;                // 4) Decode the snapshot's data into a Map&#10;                val unlockedWords = snapshot.get&lt;List&lt;String&gt;&gt;(&quot;unlockedWords&quot;).toMutableList()&#10;                val userTokens = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;).toLong()&#10;&#10;                // 6) If the word is already unlocked, just return success&#10;                if (unlockedWords.contains(word)) {&#10;                    return@withContext Resource.Success(true)&#10;                }&#10;&#10;                // 7) Check user has enough tokens (if cost &gt; 0)&#10;                if (tokenCost &gt; 0 &amp;&amp; userTokens &lt; tokenCost) {&#10;                    return@withContext Resource.Error(&quot;Not enough dream tokens&quot;)&#10;                }&#10;&#10;                // 8) Deduct tokens if needed (presumably calls another method in your repo)&#10;                if (tokenCost &gt; 0) {&#10;                    consumeDreamTokens(tokenCost) // must also be updated to dev.gitlive calls&#10;                }&#10;&#10;                // 9) Add new word to the unlocked list&#10;                unlockedWords.add(word)&#10;&#10;                // 10) Update the doc in Firestore&#10;                userDocRef.update(mapOf(&quot;unlockedWords&quot; to unlockedWords))&#10;&#10;                Resource.Success(true)&#10;&#10;            } catch (e: Exception) {&#10;                Resource.Error(&quot;Failed to unlock word: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getUnlockedWords(): Flow&lt;Resource&lt;List&lt;String&gt;&gt;&gt; = flow {&#10;        emit(Resource.Loading())&#10;&#10;        // Retrieve the current user&#10;        val currentUser = Firebase.auth.currentUser&#10;        if (currentUser == null) {&#10;            emit(Resource.Error(&quot;No user is logged in.&quot;))&#10;            return@flow&#10;        }&#10;&#10;        try {&#10;            // Reference to the user's document: USERS/{uid}&#10;            val userDocRef = Firebase.firestore&#10;                .collection(USERS)&#10;                .document(currentUser.uid)&#10;&#10;            // Fetch the user document (suspend call)&#10;            val snapshot = userDocRef.get()&#10;&#10;            // Check if the document exists&#10;            if (snapshot.exists) {&#10;                // Retrieve the 'unlockedWords' field as a List&lt;String&gt;&#10;                val unlockedWords = snapshot.get(&quot;unlockedWords&quot;) as? List&lt;String&gt; ?: emptyList()&#10;&#10;                Logger.d(&quot;Unlocked words: $unlockedWords&quot;)&#10;                emit(Resource.Success(unlockedWords))&#10;            } else {&#10;                emit(Resource.Error(&quot;User document does not exist.&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Logger.e(&quot;Failed to get unlocked words&quot;, e)&#10;            emit(Resource.Error(&quot;Failed to get unlocked words: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun recordUserInteraction() {&#10;        // If you need to reload the user, do it via dev.gitlive as well&#10;        reloadFirebaseUser()&#10;&#10;        val user = Firebase.auth.currentUser&#10;        if (user != null) {&#10;            try {&#10;                val userDocRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;                // Set the 'lastActiveTimestamp' to server time, merging with existing fields&#10;                userDocRef.set(&#10;                    data = mapOf(&quot;lastActiveTimestamp&quot; to FieldValue.serverTimestamp),&#10;                    merge = true&#10;                )&#10;&#10;            } catch (e: Exception) {&#10;                Logger.e(&quot;AuthRepositoryImpl&quot;){ &quot;Failed to record user interaction: $e&quot; }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private suspend fun validateUser() {&#10;        val user = Firebase.auth.currentUser&#10;&#10;        // Update your local states or flows&#10;        _isUserExist.value = user != null&#10;        _emailVerified.value = user?.isEmailVerified ?: false&#10;        _isLoggedIn.value = user != null &amp;&amp; user.isEmailVerified == true&#10;        _isUserAnonymous.value = user?.isAnonymous ?: false&#10;&#10;        // If user is verified, update FireStore&#10;        if (user != null &amp;&amp; user.isEmailVerified) {&#10;            try {&#10;                val userDocRef = Firebase&#10;                    .firestore&#10;                    .collection(USERS)&#10;                    .document(user.uid)&#10;&#10;                // 'update(...)' is a suspend function in dev.gitlive&#10;                userDocRef.update(mapOf(&quot;emailVerified&quot; to true))&#10;&#10;                // Optionally log success&#10;                // Log.d(&quot;Firestore&quot;, &quot;Email verification status updated successfully&quot;)&#10;            } catch (e: Exception) {&#10;                // Log or handle the error&#10;                // Log.e(&quot;Firestore&quot;, &quot;Error updating email verification status: &quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun anonymousSignIn(): Flow&lt;Resource&lt;AuthResult&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            val authResult = Firebase.auth.signInAnonymously()&#10;            emit(Resource.Success(authResult))&#10;        }.catch { e -&gt;&#10;            emit(Resource.Error(e.toString()))&#10;        }&#10;    }&#10;    private suspend fun addUserToFirestore(registrationTimestamp: Long) {&#10;        auth.currentUser?.apply {&#10;            val docRef = db.collection(USERS).document(uid)&#10;            val snapshot = try { docRef.get() } catch (_: Exception) { null }&#10;&#10;            val hasDoc = snapshot?.exists == true&#10;            val hasTokens = try { snapshot?.get&lt;Any&gt;(&quot;dreamTokens&quot;) != null } catch (_: Exception) { false }&#10;&#10;            if (!hasDoc) {&#10;                // Create brand-new user doc with safe defaults (includes starting tokens)&#10;                val user = toUser(registrationTimestamp)&#10;                docRef.set(user)&#10;            } else if (!hasTokens) {&#10;                // Doc exists but tokens missing: set only missing fields without touching existing values&#10;                docRef.update(&#10;                    mapOf(&#10;                        &quot;dreamTokens&quot; to 25L,&#10;                        &quot;unlockedWords&quot; to emptyList&lt;String&gt;()&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    override suspend fun firebaseSignUpWithEmailAndPassword(&#10;        email: String,&#10;        password: String&#10;    ): Flow&lt;Resource&lt;String&gt;&gt; {&#10;&#10;        // Check if the current user is anonymous and store the user ID if so&#10;        anonymousUserId = if (Firebase.auth.currentUser?.isAnonymous == true) {&#10;            Firebase.auth.currentUser?.uid&#10;        } else {&#10;            null&#10;        }&#10;&#10;        @Serializable&#10;        data class CreateAccountResponse(val message: String)&#10;&#10;        return flow {&#10;            emit(Resource.Loading())&#10;&#10;            try {&#10;                val data = mapOf(&#10;                    &quot;email&quot; to email,&#10;                    &quot;password&quot; to password&#10;                )&#10;&#10;                val result = Firebase.functions&#10;                    .httpsCallable(&quot;createAccountAndSendEmailVerification&quot;)&#10;                    .invoke(data)&#10;&#10;                val response = result.data&lt;CreateAccountResponse&gt;()&#10;                val message = response.message&#10;&#10;                addUserToFirestore(registrationTimestamp = kotlin.time.Clock.System.now().toEpochMilliseconds())&#10;&#10;                emit(Resource.Success(message))&#10;&#10;            } catch (e: Exception) {&#10;                emit(Resource.Error(&quot;SignUp error: ${e.message}&quot;))&#10;            }&#10;        }.catch { e -&gt;&#10;            emit(Resource.Error(e.toString()))&#10;        }&#10;    }&#10;&#10;&#10;&#10;    override suspend fun sendEmailVerification(): Flow&lt;Resource&lt;Boolean&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            try {&#10;                auth.currentUser?.sendEmailVerification()&#10;                emit(Resource.Success(true))&#10;            } catch (e: Exception) {&#10;                emit(Resource.Error(e.toString()))&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun firebaseSignInWithEmailAndPassword(&#10;        email: String,&#10;        password: String,&#10;    ): Flow&lt;Resource&lt;AuthResult&gt;&gt; {&#10;        anonymousUserId = if (auth.currentUser?.isAnonymous == true) {&#10;            auth.currentUser?.uid&#10;        } else {&#10;            null&#10;        }&#10;        return flow {&#10;            emit(Resource.Loading())&#10;            try {&#10;                val currentUser = auth.currentUser&#10;&#10;                if (currentUser != null &amp;&amp; anonymousUserId != null &amp;&amp; anonymousUserId != &quot;&quot;) {&#10;                    val result = auth.signInWithEmailAndPassword(email, password)&#10;&#10;                    result.user?.let {&#10;                        transferDreamsFromAnonymousToPermanent(&#10;                            it.uid, anonymousUserId ?: &quot;&quot;&#10;                        )&#10;                    }&#10;                    emit(Resource.Success(result))&#10;                } else {&#10;                    val result = auth.signInWithEmailAndPassword(email, password)&#10;                    emit(Resource.Success(result))&#10;                }&#10;            } catch (e: FirebaseAuthUserCollisionException) {&#10;                 val result = auth.signInWithEmailAndPassword(email, password)&#10;                 emit(Resource.Success(result))&#10;             } catch (e: Exception) {&#10;                 emit(Resource.Error(e.toString()))&#10;             }&#10;            validateUser()&#10;        }&#10;    }&#10;&#10;&#10;    override suspend fun reloadFirebaseUser(): ReloadUserResponse {&#10;        return try {&#10;            auth.currentUser?.reload()&#10;            Resource.Success(true)&#10;        } catch (e: Exception) {&#10;            Resource.Error(e.message ?: &quot;Unknown error&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun sendPasswordResetEmail(email: String): SendPasswordResetEmailResponse {&#10;        return try {&#10;            auth.sendPasswordResetEmail(email)&#10;            Resource.Success(true)&#10;        } catch (e: Exception) {&#10;            Resource.Error(e.message ?: &quot;Unknown error&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun signOut() = auth.signOut()&#10;&#10;    override suspend fun revokeAccess(&#10;        password: String?&#10;    ): Flow&lt;Resource&lt;Boolean&gt;&gt; {&#10;        return flow {&#10;            emit(Resource.Loading())&#10;&#10;            try {&#10;                val user = Firebase.auth.currentUser&#10;                    ?: throw IllegalStateException(&quot;No authenticated user found&quot;)&#10;&#10;                Logger.withTag(&quot;AuthRepo&quot;).d { &quot;revokeAccess start uid=${user.uid} email=${user.email} providerData=${user.providerData.map { it.providerId }} passwordProvided=${!password.isNullOrBlank()}&quot; }&#10;&#10;                if (!password.isNullOrBlank() &amp;&amp; !user.email.isNullOrBlank()) {&#10;                    val credential = EmailAuthProvider.credential(user.email!!, password)&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;reauthenticating user=${user.uid} via EmailAuthProvider&quot; }&#10;                    user.reauthenticate(credential)&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;reauthenticate success&quot; }&#10;                } else {&#10;                    Logger.withTag(&quot;AuthRepo&quot;).d { &quot;skipping reauth (no password provided or missing email)&quot; }&#10;                }&#10;&#10;                user.delete()&#10;                Logger.withTag(&quot;AuthRepo&quot;).d { &quot;user.delete() success&quot; }&#10;&#10;                emit(Resource.Success(true))&#10;&#10;            } catch (e: Exception) {&#10;                Logger.withTag(&quot;AuthRepo&quot;).e { &quot;revokeAccess error: ${e.message}&quot; }&#10;                emit(Resource.Error(&quot;Failed to revoke access: ${e.message}&quot;, false))&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    override fun getAuthState(viewModelScope: CoroutineScope): AuthStateResponse {&#10;        return Firebase.auth.authStateChanged&#10;            // Map the Flow&lt;FirebaseUser?&gt; to Flow&lt;Boolean&gt;&#10;            .map { user -&gt; user == null }&#10;            // Convert the flow to a StateFlow&lt;Boolean&gt;&#10;            .stateIn(&#10;                scope = viewModelScope,&#10;                started = SharingStarted.WhileSubscribed(),&#10;                // If currentUser is null, the initial value should be true (logged out)&#10;                initialValue = (Firebase.auth.currentUser == null)&#10;            )&#10;    }&#10;&#10;    override suspend fun transferDreamsFromAnonymousToPermanent(&#10;        permanentUid: String,&#10;        anonymousUid: String&#10;    ) {&#10;        @Serializable&#10;        data class HandleAccountLinkingResponse(&#10;            val success: Boolean = false,&#10;            val message: String? = null&#10;        )&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                val result = Firebase.functions&#10;                    .httpsCallable(&quot;handleAccountLinking&quot;)&#10;                    .invoke(&#10;                        mapOf(&quot;permanentUid&quot; to permanentUid, &quot;anonymousUid&quot; to anonymousUid)&#10;                    )&#10;&#10;                // Decode into a typed, serializable model to avoid Any serializer issues&#10;                val data = result.data&lt;HandleAccountLinkingResponse&gt;()&#10;                val success = data.success&#10;&#10;                if (success) {&#10;                    println(&quot;Dreams transferred successfully. Proceed to clean up anonymous account if needed.&quot;)&#10;                } else {&#10;                    println(&quot;Failed to transfer dreams: ${data.message}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                when (e) {&#10;                    is FirebaseFunctionsException -&gt; {&#10;                        println(&quot;Firebase Functions error: code=${e.code}, details=${e.details}&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        println(&quot;Error transferring dreams: $e&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun addDreamTokensFlowListener(): Flow&lt;Resource&lt;String&gt;&gt; {&#10;        val user = Firebase.auth.currentUser&#10;        if (user == null) {&#10;            // Immediately return a flow that emits an error&#10;            return flowOf(Resource.Error(&quot;User is not logged in&quot;))&#10;        }&#10;&#10;        val docRef = Firebase.firestore.collection(USERS).document(user.uid)&#10;&#10;        // Create one flow with `flow {}`, then collect snapshots inside it&#10;        return flow {&#10;            // 1) Emit a loading state up front&#10;            emit(Resource.Loading())&#10;&#10;            // 2) Collect snapshots in this same flow builder&#10;            docRef.snapshots().collect { snapshot -&gt;&#10;                val data = snapshot.get&lt;String&gt;(&quot;dreamTokens&quot;)&#10;                val dreamTokens = data&#10;                 _dreamTokens.value = dreamTokens.toInt()&#10;&#10;                 // 3) Emit a success each time we get new data&#10;                 emit(Resource.Success(dreamTokens))&#10;             }&#10;        }.catch { e -&gt;&#10;            // 4) Catch any exceptions thrown in the flow&#10;            emit(Resource.Error(e.message ?: &quot;Unknown error&quot;))&#10;        }&#10;    }&#10;}&#10;&#10;fun FirebaseUser.toUser(registrationTimestamp: Long) = mapOf(&#10;     DISPLAY_NAME to displayName,&#10;     EMAIL to email,&#10;     CREATED_AT to serverTimestamp,&#10;     &quot;registrationTimestamp&quot; to registrationTimestamp,&#10;     &quot;lastSignInTimestamp&quot; to serverTimestamp,&#10;    // Defaults for a brand new account (only applied on first doc creation)&#10;    &quot;dreamTokens&quot; to 25L,&#10;    &quot;unlockedWords&quot; to emptyList&lt;String&gt;(),&#10; )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/DreamFavoriteScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_favorites/presentation/DreamFavoriteScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.domain.FavoriteEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components.DreamFavoriteScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamFavoriteScreen(&#10;    dreamFavoriteScreenState: DreamFavoriteScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (FavoriteEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit // Add onMainEvent parameter&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load dreams once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(FavoriteEvent.LoadDreams)&#10;    }&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamFavoriteScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                scope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { onEvent(FavoriteEvent.RestoreDream) }&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamFavoriteScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { paddingValues -&gt;&#10;        if (dreamFavoriteScreenState.dreamFavoriteList.isEmpty()) {&#10;            // Show an empty state&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(&#10;                        top = paddingValues.calculateTopPadding(),&#10;                        bottom = bottomPaddingValue&#10;                    )&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no favorites. Add some!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, show the favorites list&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize(),&#10;            contentPadding = PaddingValues(bottom = 16.dp)&#10;        ) {&#10;            // 1) Parse and sort by LocalDate, descending, like DreamJournalListScreen&#10;            val sortedGroupedDreams = dreamFavoriteScreenState.dreamFavoriteList&#10;                .mapNotNull { dream -&gt;&#10;                    // parseCustomDate(...) might throw an exception if invalid&#10;                    // or return null if you wrap it in a try/catch&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        // Return a pair (LocalDate, Dream)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                // Sort descending by date, then descending by dream.timestamp&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                // Group by the parsed LocalDate&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, display a sticky header + items&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(FavoriteEvent.DreamToDelete(dream))&#10;                            onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_favorites.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.domain.FavoriteEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.components.DreamFavoriteScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenState&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamFavoriteScreen(&#10;    dreamFavoriteScreenState: DreamFavoriteScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (FavoriteEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Load dreams once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(FavoriteEvent.LoadDreams)&#10;    }&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamFavoriteScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                scope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { onEvent(FavoriteEvent.RestoreDream) }&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamFavoriteScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;    ) { paddingValues -&gt;&#10;        if (dreamFavoriteScreenState.dreamFavoriteList.isEmpty()) {&#10;            // Show an empty state&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(&#10;                        top = paddingValues.calculateTopPadding(),&#10;                        bottom = bottomPaddingValue&#10;                    )&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no favorites. Add some!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, show the favorites list&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding()&#10;                .fillMaxSize(),&#10;            contentPadding = PaddingValues(bottom = 16.dp)&#10;        ) {&#10;            // 1) Parse and sort by LocalDate, descending, like DreamJournalListScreen&#10;            val sortedGroupedDreams = dreamFavoriteScreenState.dreamFavoriteList&#10;                .mapNotNull { dream -&gt;&#10;                    // parseCustomDate(...) might throw an exception if invalid&#10;                    // or return null if you wrap it in a try/catch&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        // Return a pair (LocalDate, Dream)&#10;                        parsedDate to dream&#10;                    } catch (_: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                // Sort descending by date, then descending by dream.timestamp&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                // Group by the parsed LocalDate&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, display a sticky header + items&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(FavoriteEvent.DreamToDelete(dream))&#10;                            onEvent(FavoriteEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/DreamJournalListScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;    val dreamState by rememberUpdatedState(dreamJournalListState.dreams)&#10;    val dreamCount = dreamJournalListState.dreams.size&#10;    val isRecentlySaved = mainScreenViewModelState.isDreamRecentlySaved&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;    val dreamCount = dreamJournalListState.dreams.size&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;//    // The key part: trigger in-app review from the VM if conditions are met&#10;//    LaunchedEffect(isRecentlySaved) {&#10;//        if (dreamCount &gt;= 2 &amp;&amp; isRecentlySaved) {&#10;//            delay(1000)&#10;//            // Dispatch the &quot;TriggerReview&quot; event to the VM&#10;//            onDreamListEvent(DreamListEvent.TriggerReview)&#10;//        }&#10;                scope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) {&#10;                                onDreamListEvent(DreamListEvent.RestoreDream)&#10;                            },&#10;                        )&#10;                    )&#10;                }&#10;            },&#10;            onClickOutside = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            }&#10;        )&#10;    }&#10;        ActionBottomSheet(&#10;            modifier = Modifier.padding(),&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;                onDreamListEvent(DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!))&#10;                // Undo is handled in the viewmodel via events now&#10;             },&#10;             onClickOutside = {&#10;                 onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;             }&#10;         )&#10;     }&#10;                dreamJournalListState = dreamJournalListState,&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                searchTextFieldState = searchTextFieldState,&#10;            DreamListScreenTopBar(&#10;                onOpenDrawer = { onMainEvent(MainScreenEvent.ToggleDrawerState(DrawerValue.Open)) },&#10;            )&#10;        },&#10;        containerColor = Color.Transparent&#10;                onDreamListEvent = onDreamListEvent,&#10;             )&#10;         },&#10;         containerColor = Color.Transparent&#10;    ) { innerPadding -&gt;&#10;&#10;                    } catch (e: IllegalArgumentException) {&#10;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .dynamicBottomNavigationPadding()&#10;                .padding(top = topPadding, bottom = bottomPaddingValue),&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        ) {&#10;            // Step 1: Parse and Sort Dreams&#10;            val sortedGroupedDreams = dreamJournalListState.dreams&#10;                .mapNotNull { dream -&gt;&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        Pair(parsedDate, dream)&#10;                    } catch (_: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // Step 2: Iterate Through Groups&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;                // Sticky Header for the Date&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;                }&#10;&#10;                // Items for Each Dream in the Date Group&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 20.dp),&#10;                        onClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onDreamListEvent(&#10;                                DreamListEvent.DreamToDelete(dream)&#10;                            )&#10;                            onDreamListEvent(&#10;                                DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                            )&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamListScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListState&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamJournalListScreen(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    searchTextFieldState: TextFieldState,&#10;    dreamJournalListState: DreamJournalListState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onDreamListEvent: (DreamListEvent) -&gt; Unit = {},&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    DisposableEffect(lifecycleOwner) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_RESUME) {&#10;                onDreamListEvent(DreamListEvent.FetchDreams)&#10;            }&#10;        }&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.SetBottomBarVisibilityState(true))&#10;        onMainEvent(MainScreenEvent.SetFloatingActionButtonState(true))&#10;        onMainEvent(MainScreenEvent.SetDrawerState(true))&#10;    }&#10;&#10;    if (dreamJournalListState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            modifier = Modifier.padding(),&#10;            title = &quot;Delete this Dream?&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            onClick = {&#10;                onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;                onDreamListEvent(DreamListEvent.DeleteDream(dream = dreamJournalListState.chosenDreamToDelete!!))&#10;                // Undo is handled in the viewmodel via events now&#10;             },&#10;             onClickOutside = {&#10;                 onDreamListEvent(DreamListEvent.ToggleBottomDeleteCancelSheetState(false))&#10;             }&#10;         )&#10;     }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamListScreenTopBar(&#10;                 dreamJournalListState = dreamJournalListState,&#10;                 mainScreenViewModelState = mainScreenViewModelState,&#10;                 searchTextFieldState = searchTextFieldState,&#10;                onDreamListEvent = onDreamListEvent,&#10;             )&#10;         },&#10;         containerColor = Color.Transparent&#10;    ) { innerPadding -&gt;&#10;&#10;        val topPadding = innerPadding.calculateTopPadding()&#10;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .dynamicBottomNavigationPadding()&#10;                .padding(top = topPadding, bottom = bottomPaddingValue),&#10;            contentPadding = PaddingValues(bottom = 16.dp),&#10;        ) {&#10;            // Step 1: Parse and Sort Dreams&#10;            val sortedGroupedDreams = dreamJournalListState.dreams&#10;                .mapNotNull { dream -&gt;&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        Pair(parsedDate, dream)&#10;                    } catch (_: IllegalArgumentException) {&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // Step 2: Iterate Through Groups&#10;            sortedGroupedDreams.forEach { (date, dreams) -&gt;&#10;&#10;                // Sticky Header for the Date&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date), paddingStart = 20)&#10;                }&#10;&#10;                // Items for Each Dream in the Date Group&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 20.dp),&#10;                        onClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onDreamListEvent(DreamListEvent.TriggerVibration)&#10;                            onDreamListEvent(&#10;                                DreamListEvent.DreamToDelete(dream)&#10;                            )&#10;                            onDreamListEvent(&#10;                                DreamListEvent.ToggleBottomDeleteCancelSheetState(true)&#10;                            )&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/components/DreamItem.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.InfiniteTransition&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.AsyncImagePainter&#10;import coil3.compose.SubcomposeAsyncImage&#10;import coil3.compose.SubcomposeAsyncImageContent&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;        }&#10;&#10;    // Only run border/shimmer animations if hasBorder is true to avoid unnecessary redraws&#10;    val borderThickness = if (hasBorder) {&#10;        val t = rememberInfiniteTransition(label = &quot;border&quot;)&#10;        t.animateFloat(&#10;            initialValue = 4f,&#10;            targetValue = 6f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;borderThickness&quot;&#10;        )&#10;    } else null&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush() else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            )&#10;            .border(&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                onLongClick = {&#10;                    isLongPressTriggered = true&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    SubcomposeAsyncImage(&#10;                        model = generatedImage,&#10;                        contentDescription = &quot;Dream Image&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop,&#10;                        loading = {&#10;                            // Fallback + shimmer while loading/empty&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Placeholder&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .shimmerEffect()&#10;                            )&#10;                        },&#10;                        error = {&#10;                            // Fallback on error&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Fallback&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                        },&#10;                        success = {&#10;                            SubcomposeAsyncImageContent()&#10;                        }&#10;                    )&#10;                } else {&#10;                     Image(&#10;                         painter = painterResource(chosenBackground),&#10;                         modifier = Modifier.fillMaxSize(),&#10;                         contentScale = ContentScale.Crop,&#10;                         contentDescription = &quot;Dream Image&quot;&#10;                     )&#10;                 }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(): Brush {&#10;    val transition = rememberInfiniteTransition(label = &quot;borderBrush&quot;)&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components&#10;&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.LinearOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.basicMarquee&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme.typography&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.composed&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil3.compose.SubcomposeAsyncImage&#10;import coil3.compose.SubcomposeAsyncImageContent&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_cached_24&#10;import dreamjournalai.composeapp.shared.generated.resources.baseline_star_24&#10;import dreamjournalai.composeapp.shared.generated.resources.false_awakening_icon&#10;import dreamjournalai.composeapp.shared.generated.resources.lighthouse_vector&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_closed&#10;import dreamjournalai.composeapp.shared.generated.resources.nightmare_ghost_open&#10;import kotlinx.coroutines.delay&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream.Companion.dreamBackgroundImages&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.BrighterWhite&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Green&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.LightBlack&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Purple&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.RedOrange&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.SkyBlue&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.White&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.Yellow&#10;import org.jetbrains.compose.resources.painterResource&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.draw.alpha&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamItem(&#10;    modifier: Modifier = Modifier,&#10;    dream: Dream,&#10;    hasBorder: Boolean = false,&#10;    onClick: () -&gt; Unit,&#10;    onDeleteClick: () -&gt; Unit = {}&#10;) {&#10;    val imageResId =&#10;        if (dream.backgroundImage &gt;= 0 &amp;&amp; dream.backgroundImage &lt; dreamBackgroundImages.size) {&#10;            dreamBackgroundImages[dream.backgroundImage]&#10;        } else {&#10;            Res.drawable.background_during_day&#10;        }&#10;&#10;    // Only run border/shimmer animations if hasBorder is true to avoid unnecessary redraws&#10;    val borderThickness = if (hasBorder) {&#10;        val t = rememberInfiniteTransition(label = &quot;border&quot;)&#10;        t.animateFloat(&#10;            initialValue = 4f,&#10;            targetValue = 6f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 3000, easing = LinearOutSlowInEasing),&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;borderThickness&quot;&#10;        )&#10;    } else null&#10;&#10;    val shimmerBrush = if (hasBorder) shimmerBrush() else null&#10;    val glowColor = Color.White&#10;&#10;    val chosenModifier = if (hasBorder) {&#10;        modifier&#10;            .shadow(&#10;                elevation = 8.dp,&#10;                shape = RoundedCornerShape(8.dp),&#10;                clip = false,&#10;                ambientColor = glowColor&#10;            )&#10;            .border(&#10;            width = (borderThickness?.value ?: 4f).dp,&#10;            brush = shimmerBrush!!,&#10;            shape = RoundedCornerShape(8.dp)&#10;        )&#10;    } else {&#10;        modifier&#10;    }&#10;    var isLongPressTriggered by remember { mutableStateOf(false) }&#10;    Box(&#10;        modifier = chosenModifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(LightBlack.copy(alpha = 0.8f))&#10;            .combinedClickable(&#10;                onClick = {&#10;                    if (!isLongPressTriggered) {&#10;                        onClick()&#10;                    }&#10;                },&#10;                onLongClick = {&#10;                    isLongPressTriggered = true&#10;                    if (isLongPressTriggered) onDeleteClick()&#10;                    isLongPressTriggered = false // Reset after handling&#10;                }&#10;            )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .height(IntrinsicSize.Min),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(12.dp, 12.dp, 4.dp, 12.dp)&#10;                    .size(116.dp)&#10;                    .background(Color.Transparent)&#10;                    .shadow(4.dp, RoundedCornerShape(8.dp), true)&#10;&#10;            ) {&#10;                val generatedImage = if (dream.generatedImage != &quot;&quot;) {&#10;                    dream.generatedImage&#10;                } else {&#10;                    null&#10;                }&#10;&#10;                val chosenBackground = imageResId&#10;&#10;                if (generatedImage != null) {&#10;                    SubcomposeAsyncImage(&#10;                        model = generatedImage,&#10;                        contentDescription = &quot;Dream Image&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop,&#10;                        loading = {&#10;                            // Fallback + shimmer while loading/empty&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Placeholder&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .shimmerEffect()&#10;                            )&#10;                        },&#10;                        error = {&#10;                            // Fallback on error&#10;                            Image(&#10;                                painter = painterResource(chosenBackground),&#10;                                contentDescription = &quot;Dream Image Fallback&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Crop&#10;                            )&#10;                        },&#10;                        success = {&#10;                            SubcomposeAsyncImageContent()&#10;                        }&#10;                    )&#10;                } else {&#10;                     Image(&#10;                         painter = painterResource(chosenBackground),&#10;                         modifier = Modifier.fillMaxSize(),&#10;                         contentScale = ContentScale.Crop,&#10;                         contentDescription = &quot;Dream Image&quot;&#10;                     )&#10;                 }&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(0.dp, 12.dp, 0.dp, 12.dp)&#10;            ) {&#10;                Text(&#10;                    text = dream.title,&#10;                    style = typography.titleSmall,&#10;                    fontSize = 16.sp,&#10;                    color = BrighterWhite,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.basicMarquee()&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(3.dp))&#10;&#10;                Text(&#10;                    text = dream.content,&#10;                    style = typography.bodySmall,&#10;                    fontSize = 13.sp,&#10;                    color = White,&#10;                    maxLines = 3,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(0.dp, 8.dp, 8.dp, 8.dp)&#10;                    .fillMaxHeight(1f),&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (dream.isFavorite) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_star_24),&#10;                        tint = Yellow,&#10;                        contentDescription = &quot;Favorite&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isNightmare) {&#10;                    NightmareGhostAnimatedIcon(&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isRecurring) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.baseline_cached_24),&#10;                        tint = Green,&#10;                        contentDescription = &quot;Recurring&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.isLucid) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.lighthouse_vector),&#10;                        tint = SkyBlue,&#10;                        contentDescription = &quot;Lucid&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;&#10;                if (dream.falseAwakening) {&#10;                    Icon(&#10;                        painter = painterResource(Res.drawable.false_awakening_icon),&#10;                        tint = Purple,&#10;                        contentDescription = &quot;Day Dream&quot;,&#10;                        modifier = Modifier&#10;                            .size(26.dp)&#10;                            .padding(bottom = 4.dp),&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun shimmerBrush(): Brush {&#10;    val transition = rememberInfiniteTransition(label = &quot;borderBrush&quot;)&#10;    val translateAnim by transition.animateFloat(&#10;        initialValue = -1000f,&#10;        targetValue = 1000f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 4000, easing = LinearOutSlowInEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;&quot;&#10;    )&#10;&#10;    return Brush.linearGradient(&#10;        colors = listOf(&#10;            Color.White.copy(alpha = 0.6f),&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White,&#10;            Color.White.copy(alpha = 0.9f),&#10;            Color.White.copy(alpha = 0.6f)&#10;        ),&#10;        start = Offset(translateAnim - 300f, translateAnim - 300f),&#10;        end = Offset(translateAnim + 300f, translateAnim + 300f)&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun Modifier.shimmerEffect(): Modifier = composed {&#10;    var size by remember { mutableStateOf(IntSize.Zero) }&#10;    val transition = rememberInfiniteTransition(label = &quot;&quot;)&#10;&#10;    // Animate the shimmer's offset&#10;    val startOffsetX by transition.animateFloat(&#10;        initialValue = -2 * size.width.toFloat(), // Start from the left beyond the component&#10;        targetValue = 2 * size.width.toFloat(),   // End to the right beyond the component&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 1000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    background(&#10;        brush = Brush.linearGradient(&#10;            colors = listOf(&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;                Color(0xFFF8F8F8), // Very light gray, nearly white for the center&#10;                Color(0xFFBEBEBE), // Light gray for the edges&#10;            ),&#10;            start = Offset(startOffsetX, 0f),        // Start position of the gradient&#10;            end = Offset(startOffsetX + size.width, 0f) // End position of the gradient&#10;        )&#10;    ).onGloballyPositioned {&#10;        size = it.size  // Update the size when the layout changes&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NightmareGhostAnimatedIcon(&#10;    modifier: Modifier = Modifier,&#10;    tintOpen: Color = RedOrange,&#10;    tintClosed: Color = White,         // closed is white&#10;    holdOpenMillis: Int = 5000,        // hold at full open ~5s&#10;    closedHoldMillis: Int = 900,       // brief closed pause&#10;    crossfadeMillis: Int = 260,        // snappy swap&#10;    moveDurationMillis: Int = 800,     // slower move/grow/shrink (was 420)&#10;    moveDistanceDp: Float = 2f         // further ascend/descend (was 3f)&#10;) {&#10;    var isOpen by remember { mutableStateOf(false) } // start closed&#10;&#10;    // Controlled scale and vertical position (dp)&#10;    val scale = remember { Animatable(0.94f) }&#10;    val offsetY = remember { Animatable(0f) } // dp units; 0 when open, -moveDistance when closed&#10;&#10;    // Timeline: closed (hold) -&gt; open (descend+grow) -&gt; hold -&gt; closed (ascend+shrink)&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            // Closed hold at current position&#10;            delay(closedHoldMillis.toLong())&#10;&#10;            // Open: crossfade to red and animate down to baseline while growing&#10;            isOpen = true&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(1.06f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(0f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;&#10;            // Hold fully open&#10;            delay(holdOpenMillis.toLong())&#10;&#10;            // Close: crossfade to white and animate up a bit while shrinking&#10;            isOpen = false&#10;            kotlinx.coroutines.coroutineScope {&#10;                launch { scale.animateTo(0.90f, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;                launch { offsetY.animateTo(-moveDistanceDp, animationSpec = tween(durationMillis = moveDurationMillis, easing = LinearOutSlowInEasing)) }&#10;            }&#10;            // loop repeats (will hold closed again)&#10;        }&#10;    }&#10;&#10;    Crossfade(targetState = isOpen, animationSpec = tween(crossfadeMillis, easing = LinearOutSlowInEasing), label = &quot;&quot;) { open -&gt;&#10;        val painter = painterResource(if (open) Res.drawable.nightmare_ghost_open else Res.drawable.nightmare_ghost_closed)&#10;        val tint = if (open) tintOpen else tintClosed&#10;        Icon(&#10;            painter = painter,&#10;            contentDescription = if (open) &quot;Nightmare (open)&quot; else &quot;Nightmare (closed)&quot;,&#10;            tint = tint,&#10;            modifier = modifier&#10;                .offset(y = offsetY.value.dp)&#10;                .graphicsLayer {&#10;                    scaleX = scale.value&#10;                    scaleY = scale.value&#10;                }&#10;                .alpha(if (open) 1f else 0.77f)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/viewmodel/DreamJournalListViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_journal_list/presentation/viewmodel/DreamJournalListViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.runtime.Stable&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.collections.immutable.immutableListOf&#10;import kotlinx.collections.immutable.persistentListOf&#10;import kotlinx.collections.immutable.toImmutableList&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.util.OrderType&#10;&#10;&#10;class DreamJournalListViewModel(&#10;&#10;    companion object {&#10;        private const val UNDO_TIMEOUT_MS = 10_000L // align with SnackbarDuration.Long&#10;    }&#10;&#10;    private val _dreamJournalListState = MutableStateFlow(DreamJournalListState())&#10;    val dreamJournalListState: StateFlow&lt;DreamJournalListState&gt; = _dreamJournalListState.asStateFlow()&#10;&#10;    private val _searchTextFieldState = MutableStateFlow(TextFieldState())&#10;    // ids hidden locally until user confirms or undo timeout elapses&#10;    private val filteredOutIds = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())&#10;    // job per pending delete to cancel on undo&#10;    private val pendingDeletes = mutableMapOf&lt;String, Job&gt;()&#10;&#10;    private var getDreamJob: Job? = null&#10;&#10;    init {&#10;        getDreams(OrderType.Date)&#10;    }&#10;                    dreamUseCases.deleteDream(event.dream)&#10;                        // Fallback: if no id, perform immediate delete (cannot defer reliably)&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { viewModelScope.launch { onEvent(DreamListEvent.RestoreDream) } }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerReview -&gt; {&#10;                // For example, check conditions before prompting&#10;                val dreamCount = dreamJournalListState.value.dreams.size&#10;                // or load from DB, or pass in from the composable, etc.&#10;&#10;                if (dreamCount &gt;= 2) {&#10;//                    viewModelScope.launch {&#10;//                        reviewComponent.requestInAppReview().collect { resultCode -&gt;&#10;//                           //TODO: Handle result code&#10;//                        }&#10;//                    }&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerVibration -&gt; {&#10;                vibratorUtil.triggerVibration()&#10;            }&#10;            is DreamListEvent.ToggleOrderSection -&gt; {&#10;                    val dreamToRestore = recentlyDeletedDream?.copy(generatedImage = &quot;&quot;) ?: return@launch&#10;                    dreamUseCases.addDream(dreamToRestore)&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    } else {&#10;                        // No id: just re-add to repository&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    }&#10;                    recentlyDeletedDream = null&#10;                }&#10;            }&#10;            is DreamListEvent.Order -&gt; {&#10;                if (dreamJournalListState.value.orderType == event.orderType) {&#10;                    return&#10;                }&#10;                getDreams(event.orderType)&#10;            }&#10;            is DreamListEvent.SetSearchingState -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isSearching = event.state&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.ToggleBottomDeleteCancelSheetState -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    bottomDeleteCancelSheetState = event.bottomDeleteCancelSheetState&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.DreamToDelete -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    chosenDreamToDelete = event.dream&#10;                )&#10;            }&#10;            is DreamListEvent.FetchDreams -&gt; {&#10;                getDreams(dreamJournalListState.value.orderType)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getDreams(orderType: OrderType) {&#10;                if (searchText.isBlank()) {&#10;                    dreams&#10;                } else {&#10;                    dreams.filter { it.doesMatchSearchQuery(searchText.toString()) }&#10;                }&#10;            ) { dreams, searchText -&gt;&#10;            .onEach { filteredDreams -&gt;&#10;            }&#10;                    dreams = filteredDreams,&#10;                dreams.filter { it.id == null || it.id !in filteredIds }&#10;            }&#10;            .onEach { visibleDreams -&gt;&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    dreams = visibleDreams.toImmutableList(),&#10;                    orderType = orderType,&#10;                )&#10;            }&#10;            .launchIn(viewModelScope)&#10;    }&#10;}&#10;&#10;&#10;data class DreamJournalListState(&#10;    val dreams: ImmutableList&lt;Dream&gt; = persistentListOf(),&#10;    val bottomDeleteCancelSheetState: Boolean = false,&#10;    val chosenDreamToDelete: Dream? = null,&#10;    val orderType: OrderType = OrderType.Date,&#10;    val isOrderSectionVisible: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val isSearching: Boolean = false,&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.text.input.TextFieldState&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.SnackbarAction&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.SnackbarEvent&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.DreamListEvent&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.use_case.DreamUseCases&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.util.OrderType&#10;&#10;&#10;class DreamJournalListViewModel(&#10;    private val dreamUseCases: DreamUseCases,&#10;    private val vibratorUtil: VibratorUtil,&#10; //   private val reviewComponent: ReviewComponent&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val UNDO_TIMEOUT_MS = 10_000L // align with SnackbarDuration.Long&#10;    }&#10;&#10;    private val _dreamJournalListState = MutableStateFlow(DreamJournalListState())&#10;    val dreamJournalListState: StateFlow&lt;DreamJournalListState&gt; = _dreamJournalListState.asStateFlow()&#10;&#10;    private val _searchTextFieldState = MutableStateFlow(TextFieldState())&#10;&#10;    val searchTextFieldState: StateFlow&lt;TextFieldState&gt; = _searchTextFieldState.asStateFlow()&#10;&#10;    private var recentlyDeletedDream: Dream? = null&#10;&#10;    // ids hidden locally until user confirms or undo timeout elapses&#10;    private val filteredOutIds = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())&#10;    // job per pending delete to cancel on undo&#10;    private val pendingDeletes = mutableMapOf&lt;String, Job&gt;()&#10;&#10;    private var getDreamJob: Job? = null&#10;&#10;    init {&#10;        getDreams(OrderType.Date)&#10;    }&#10;&#10;    fun onEvent(event: DreamListEvent) {&#10;        when (event) {&#10;            is DreamListEvent.DeleteDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val id = event.dream.id&#10;                    if (id == null) {&#10;                        // Fallback: if no id, perform immediate delete (cannot defer reliably)&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        return@launch&#10;                    }&#10;                    // Soft-delete locally: hide from list and schedule finalization&#10;                    recentlyDeletedDream = event.dream&#10;                    filteredOutIds.value = filteredOutIds.value + id&#10;                    // schedule finalize&#10;                    pendingDeletes[id]?.cancel()&#10;                    pendingDeletes[id] = launch {&#10;                        delay(UNDO_TIMEOUT_MS)&#10;                        // If still pending (no undo), perform remote delete&#10;                        dreamUseCases.deleteDream(event.dream)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        pendingDeletes.remove(id)&#10;                        if (recentlyDeletedDream?.id == id) recentlyDeletedDream = null&#10;                    }&#10;                    // Reintroduce undo snackbar via centralized controller&#10;                    SnackbarController.sendEvent(&#10;                        SnackbarEvent(&#10;                            message = &quot;Dream deleted&quot;,&#10;                            action = SnackbarAction(&quot;Undo&quot;) { viewModelScope.launch { onEvent(DreamListEvent.RestoreDream) } }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerReview -&gt; {&#10;                // For example, check conditions before prompting&#10;                val dreamCount = dreamJournalListState.value.dreams.size&#10;                // or load from DB, or pass in from the composable, etc.&#10;&#10;                if (dreamCount &gt;= 2) {&#10;//                    viewModelScope.launch {&#10;//                        reviewComponent.requestInAppReview().collect { resultCode -&gt;&#10;//                           //TODO: Handle result code&#10;//                        }&#10;//                    }&#10;                }&#10;            }&#10;            is DreamListEvent.TriggerVibration -&gt; {&#10;                vibratorUtil.triggerVibration()&#10;            }&#10;            is DreamListEvent.ToggleOrderSection -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isOrderSectionVisible = !dreamJournalListState.value.isOrderSectionVisible)&#10;            }&#10;            is DreamListEvent.RestoreDream -&gt; {&#10;                viewModelScope.launch {&#10;                    val dreamToRestore = recentlyDeletedDream ?: return@launch&#10;                    val id = dreamToRestore.id&#10;                    if (id != null) {&#10;                        // Cancel pending remote delete if any and unfilter locally&#10;                        pendingDeletes[id]?.cancel()&#10;                        pendingDeletes.remove(id)&#10;                        filteredOutIds.value = filteredOutIds.value - id&#10;                        // If remote delete already happened (race), re-add dream&#10;                        // We can't trivially detect it without an extra call; adding is idempotent enough&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    } else {&#10;                        // No id: just re-add to repository&#10;                        dreamUseCases.addDream(dreamToRestore)&#10;                    }&#10;                    recentlyDeletedDream = null&#10;                }&#10;            }&#10;            is DreamListEvent.Order -&gt; {&#10;                if (dreamJournalListState.value.orderType == event.orderType) {&#10;                    return&#10;                }&#10;                getDreams(event.orderType)&#10;            }&#10;            is DreamListEvent.SetSearchingState -&gt; {&#10;                _dreamJournalListState.value = _dreamJournalListState.value.copy(&#10;                    isSearching = event.state&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.ToggleBottomDeleteCancelSheetState -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    bottomDeleteCancelSheetState = event.bottomDeleteCancelSheetState&#10;                )&#10;            }&#10;&#10;            is DreamListEvent.DreamToDelete -&gt; {&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    chosenDreamToDelete = event.dream&#10;                )&#10;            }&#10;            is DreamListEvent.FetchDreams -&gt; {&#10;                getDreams(dreamJournalListState.value.orderType)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getDreams(orderType: OrderType) {&#10;        getDreamJob?.cancel()&#10;        getDreamJob = dreamUseCases.getDreams(orderType)&#10;            .combine(&#10;                snapshotFlow { searchTextFieldState.value.text }&#10;            ) { dreams, searchText -&gt;&#10;                if (searchText.isBlank()) dreams else dreams.filter { it.doesMatchSearchQuery(searchText.toString()) }&#10;            }&#10;            .combine(filteredOutIds) { dreams, filteredIds -&gt;&#10;                dreams.filter { it.id == null || it.id !in filteredIds }&#10;            }&#10;            .onEach { visibleDreams -&gt;&#10;                _dreamJournalListState.value = dreamJournalListState.value.copy(&#10;                    dreams = visibleDreams,&#10;                    orderType = orderType,&#10;                )&#10;            }&#10;            .launchIn(viewModelScope)&#10;    }&#10;}&#10;&#10;&#10;data class DreamJournalListState(&#10;    val dreams: List&lt;Dream&gt; = emptyList(),&#10;    val bottomDeleteCancelSheetState: Boolean = false,&#10;    val chosenDreamToDelete: Dream? = null,&#10;    val orderType: OrderType = OrderType.Date,&#10;    val isOrderSectionVisible: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val isSearching: Boolean = false,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberDrawerState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import co.touchlab.kermit.Logger&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.Permission&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import dev.icerock.moko.permissions.compose.PermissionsControllerFactory&#10;import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.navigation.DrawerNavigation&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                } catch (deniedAlways: DeniedAlwaysException) {&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (_: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Dont ask again).&#10;                } catch (denied: DeniedException) {&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (_: DeniedException) {&#10;                    // The user has denied the permission (but not dont ask again).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;    // Local drawer state owned by the composable for Compose stability. The ViewModel exposes&#10;    // an intent flag `isDrawerOpen`; we react to it below.&#10;    val drawerState = rememberDrawerState(DrawerValue.Closed)&#10;&#10;    // Track when we're driving the drawer programmatically to avoid echo-loops&#10;    var programmaticChangeInProgress = remember { mutableStateOf(false) }&#10;&#10;    // Drive the drawer from a simple controller to avoid VM&lt;-&gt;UI races&#10;    ObserveAsEvents(DrawerController.events, key1 = drawerState) { cmd -&gt;&#10;        Logger.d(&quot;MainScreen&quot;) { &quot;DrawerCommand: $cmd | current=${drawerState.currentValue} anim=${drawerState.isAnimationRunning}&quot; }&#10;        programmaticChangeInProgress.value = true&#10;        coroutineScope.launch {&#10;            try {&#10;                when (cmd) {&#10;                    is DrawerCommand.Open -&gt; if (drawerState.currentValue != DrawerValue.Open) drawerState.open()&#10;                    is DrawerCommand.Close -&gt; if (drawerState.currentValue != DrawerValue.Closed) drawerState.close()&#10;                    is DrawerCommand.Toggle -&gt; if (drawerState.currentValue == DrawerValue.Open) drawerState.close() else drawerState.open()&#10;                }&#10;            } finally {&#10;                programmaticChangeInProgress.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(drawerState) {&#10;        snapshotFlow { drawerState.currentValue }&#10;            .collectLatest { current -&gt;&#10;                Logger.d(&quot;MainScreen&quot;) { &quot;Drawer currentValue=$current | anim=${drawerState.isAnimationRunning} | programmatic=${programmaticChangeInProgress.value}&quot; }&#10;            }&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            AnimatedHeartIcon(animate = drawerState.currentValue == DrawerValue.Open)&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                    onClick = {&#10;                                         onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                         coroutineScope.launch {&#10;                                             drawerState.close()&#10;                                         }&#10;                                     selectedItem.value = item&#10;&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                             onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                                 popUpTo(DrawerNavigation.DreamJournalScreen.route) {&#10;                                             navController.navigate(item.route) {&#10;                                                 popUpTo(Route.DreamJournalScreen) {&#10;                                                     saveState = true&#10;                                                 }&#10;                                                 launchSingleTop = true&#10;                                                 restoreState = true&#10;                                             }&#10;                                         }&#10;                                     },&#10;                                    modifier = Modifier&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        content = {&#10;            // Local snackbar host state  main view model no longer holds snackbar UI state.&#10;            val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;            // Observe events from the centralized controller and show them on the local host.&#10;            ObserveAsEvents(SnackbarController.events) { event -&gt;&#10;                coroutineScope.launch {&#10;                    snackbarHostState.currentSnackbarData?.dismiss()&#10;                    val result = snackbarHostState.showSnackbar(&#10;                        message = event.message,&#10;                        actionLabel = event.action?.name,&#10;                        duration = SnackbarDuration.Long&#10;                    )&#10;                    if (result == SnackbarResult.ActionPerformed) {&#10;                        event.action?.action?.invoke()&#10;                    }&#10;                }&#10;            }&#10;&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(snackbarHostState)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                            val currentRoute = navBackStackEntry?.destination?.route&#10;                            BottomNavigation(&#10;                                currentRoute = currentRoute,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState,&#10;                                onMainEvent = onMainEvent,&#10;                                        popUpTo(org.ballistic.dreamjournalai.shared.navigation.Route.DreamJournalScreen) {&#10;                                    navController.navigate(route) {&#10;                                        popUpTo(Route.DreamJournalScreen) {&#10;                                            saveState = true&#10;                                        }&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.align(Alignment.BottomCenter)&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        // Temporarily disable bottom navigation to avoid rapid taps navigating elsewhere&#10;                                        onMainEvent(MainScreenEvent.SetBottomBarEnabledState(false))&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                        // Re-enable bottom bar shortly after navigation starts&#10;                                        coroutineScope.launch {&#10;                                            delay(700)&#10;                                            onMainEvent(MainScreenEvent.SetBottomBarEnabledState(true))&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;&#10;                    ScreenGraph(&#10;                        navController = navController,&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon(animate: Boolean = true) {&#10;    if (animate) {&#10;        val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;        val size by infiniteTransition.animateFloat(&#10;            initialValue = 24f,&#10;            targetValue = 28f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 800),  // Slower animation&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;&quot;&#10;        )&#10;&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Animated Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(size.dp)&#10;        )&#10;    } else {&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarDuration&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.SnackbarResult&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberDrawerState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.snapshotFlow&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import co.touchlab.kermit.Logger&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.Permission&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import dev.icerock.moko.permissions.compose.PermissionsControllerFactory&#10;import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.ObserveAsEvents&#10;import org.ballistic.dreamjournalai.shared.DrawerController&#10;import org.ballistic.dreamjournalai.shared.DrawerCommand&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.navigation.DrawerNavigation&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                    // Request the permission&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (_: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Dont ask again).&#10;                    // Handle your fallback scenario here  e.g., show a dialog explaining&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (_: DeniedException) {&#10;                    // The user has denied the permission (but not dont ask again).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;    // Local drawer state owned by the composable for Compose stability. The ViewModel exposes&#10;    // an intent flag `isDrawerOpen`; we react to it below.&#10;    val drawerState = rememberDrawerState(DrawerValue.Closed)&#10;&#10;    // Track when we're driving the drawer programmatically to avoid echo-loops&#10;    val programmaticChangeInProgress = remember { mutableStateOf(false) }&#10;&#10;    // Drive the drawer from a simple controller to avoid VM&lt;-&gt;UI races&#10;    ObserveAsEvents(DrawerController.events, key1 = drawerState) { cmd -&gt;&#10;        Logger.d(&quot;MainScreen&quot;) { &quot;DrawerCommand: $cmd | current=${drawerState.currentValue} anim=${drawerState.isAnimationRunning}&quot; }&#10;        programmaticChangeInProgress.value = true&#10;        coroutineScope.launch {&#10;            try {&#10;                when (cmd) {&#10;                    is DrawerCommand.Open -&gt; if (drawerState.currentValue != DrawerValue.Open) drawerState.open()&#10;                    is DrawerCommand.Close -&gt; if (drawerState.currentValue != DrawerValue.Closed) drawerState.close()&#10;                    is DrawerCommand.Toggle -&gt; if (drawerState.currentValue == DrawerValue.Open) drawerState.close() else drawerState.open()&#10;                }&#10;            } finally {&#10;                programmaticChangeInProgress.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(drawerState) {&#10;        snapshotFlow { drawerState.currentValue }&#10;            .collectLatest { current -&gt;&#10;                Logger.d(&quot;MainScreen&quot;) { &quot;Drawer currentValue=$current | anim=${drawerState.isAnimationRunning} | programmatic=${programmaticChangeInProgress.value}&quot; }&#10;            }&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            AnimatedHeartIcon(animate = drawerState.currentValue == DrawerValue.Open)&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                    onClick = {&#10;                                         onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                         coroutineScope.launch {&#10;                                             drawerState.close()&#10;                                         }&#10;                                     selectedItem.value = item&#10;&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                             onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                         } else {&#10;                                             navController.navigate(item.route) {&#10;                                                 popUpTo(Route.DreamJournalScreen) {&#10;                                                     saveState = true&#10;                                                 }&#10;                                                 launchSingleTop = true&#10;                                                 restoreState = true&#10;                                             }&#10;                                         }&#10;                                     },&#10;                                    modifier = Modifier&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        content = {&#10;            // Local snackbar host state  main view model no longer holds snackbar UI state.&#10;            val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;            // Observe events from the centralized controller and show them on the local host.&#10;            ObserveAsEvents(SnackbarController.events) { event -&gt;&#10;                coroutineScope.launch {&#10;                    snackbarHostState.currentSnackbarData?.dismiss()&#10;                    val result = snackbarHostState.showSnackbar(&#10;                        message = event.message,&#10;                        actionLabel = event.action?.name,&#10;                        duration = SnackbarDuration.Long&#10;                    )&#10;                    if (result == SnackbarResult.ActionPerformed) {&#10;                        event.action?.action?.invoke()&#10;                    }&#10;                }&#10;            }&#10;&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(snackbarHostState)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                            val currentRoute = navBackStackEntry?.destination?.route&#10;                            BottomNavigation(&#10;                                currentRoute = currentRoute,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState,&#10;                                onMainEvent = onMainEvent,&#10;                                onNavigate = { route -&gt;&#10;                                    navController.navigate(route) {&#10;                                        popUpTo(Route.DreamJournalScreen) {&#10;                                            saveState = true&#10;                                        }&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.align(Alignment.BottomCenter)&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        // Temporarily disable bottom navigation to avoid rapid taps navigating elsewhere&#10;                                        onMainEvent(MainScreenEvent.SetBottomBarEnabledState(false))&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                        // Re-enable bottom bar shortly after navigation starts&#10;                                        coroutineScope.launch {&#10;                                            delay(700)&#10;                                            onMainEvent(MainScreenEvent.SetBottomBarEnabledState(true))&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;&#10;                    ScreenGraph(&#10;                        navControllerProvider = { navController },&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;&#10;             }&#10;         }&#10;     )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon(animate: Boolean = true) {&#10;    if (animate) {&#10;        val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;        val size by infiniteTransition.animateFloat(&#10;            initialValue = 24f,&#10;            targetValue = 28f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = tween(durationMillis = 800),  // Slower animation&#10;                repeatMode = RepeatMode.Reverse&#10;            ), label = &quot;&quot;&#10;        )&#10;&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Animated Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(size.dp)&#10;        )&#10;    } else {&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = &quot;Heart&quot;,&#10;            tint = Color.Red,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/viewmodel/MainScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState(authRepo = repo))&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;MainScreenViewModel initialized&quot; }&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;onEvent: $event&quot; }&#10;        when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                // store plain string in state; composables should handle text input and emit events&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    searchedText = event.query&#10;                )&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let { msg -&gt;&#10;                        viewModelScope.launch {&#10;                            org.ballistic.dreamjournalai.shared.SnackbarController.sendEvent(&#10;                                org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                                    message = msg,&#10;                                    action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                            message = event.message,&#10;                            action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                // ViewModel does not own a DrawerState (Compose UI object). Instead, store intent as a boolean.&#10;                Logger.d(&quot;MainScreenViewModel&quot;) { &quot;ToggleDrawerState -&gt; ${event.drawerValue}&quot; }&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isDrawerOpen = (event.drawerValue != DrawerValue.Closed)&#10;                )&#10;            }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    // ViewModel no longer holds a Compose DrawerState; instead expose a simple boolean intent&#10;    val isDrawerOpen: Boolean = false,&#10;    val authRepo: AuthRepository,&#10;    // Keep search text as a plain String for stability; composables handle input&#10;    val searchedText: String = &quot;&quot;,&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel&#10;&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.background_during_day&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.datetime.TimeZone&#10;import kotlinx.datetime.toLocalDateTime&#10;import org.ballistic.dreamjournalai.shared.SnackbarController&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.core.domain.VibratorUtil&#10;import org.ballistic.dreamjournalai.shared.core.util.StoreLinkOpener&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.jetbrains.compose.resources.DrawableResource&#10;import kotlin.time.ExperimentalTime&#10;&#10;class MainScreenViewModel(&#10;    private val repo: AuthRepository,&#10;    private val vibratorUtil: VibratorUtil,&#10;    private val storeLinkOpener: StoreLinkOpener&#10;) : ViewModel() {&#10;    private val _mainScreenViewModelState = MutableStateFlow(MainScreenViewModelState())&#10;    val mainScreenViewModelState: StateFlow&lt;MainScreenViewModelState&gt; = _mainScreenViewModelState.asStateFlow()&#10;&#10;    init {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;MainScreenViewModel initialized&quot; }&#10;        updateBackgroundPeriodically()&#10;        _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;            backgroundResource = getBackgroundResource()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun getBackgroundResource(): DrawableResource {&#10;        val currentTime =  kotlin.time.Clock.System.now().toLocalDateTime(TimeZone.UTC)&#10;        val currentHour = currentTime.hour&#10;&#10;        return if (currentHour in 20..23 || currentHour in 0..5) {&#10;            Res.drawable.blue_lighthouse&#10;        } else {&#10;            Res.drawable.blue_lighthouse&#10;        }&#10;    }&#10;&#10;    private fun updateBackgroundPeriodically() {&#10;        viewModelScope.launch {&#10;            while (isActive) {&#10;                val newResource = getBackgroundResource()&#10;                if (newResource != _mainScreenViewModelState.value.backgroundResource) {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        backgroundResource = newResource&#10;                    )&#10;                }&#10;                delay(60000) // Check every minute&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent (event: MainScreenEvent) = viewModelScope.launch {&#10;        Logger.d(&quot;MainScreenViewModel&quot;) { &quot;onEvent: $event&quot; }&#10;        when (event) {&#10;            is MainScreenEvent.SetBottomBarVisibilityState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                            bottomBarState = event.state&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SetSearchingState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        isUserSearching = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetTopBarState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        topBarState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetFloatingActionButtonState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    scaffoldState = _mainScreenViewModelState.value.scaffoldState.copy(&#10;                        floatingActionButtonState = event.state&#10;                    )&#10;                )&#10;            }&#10;            is MainScreenEvent.SetDrawerState -&gt; {&#10;                viewModelScope.launch {&#10;                    _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                        isDrawerEnabled = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.SearchDreams -&gt; {&#10;                // store plain string in state; composables should handle text input and emit events&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    searchedText = event.query&#10;                )&#10;            }&#10;            is MainScreenEvent.ConsumeDreamTokens -&gt; {&#10;                val result = repo.consumeDreamTokens(event.tokensToConsume)&#10;                if (result is Resource.Error) {&#10;                    result.message?.let { msg -&gt;&#10;                        viewModelScope.launch {&#10;                            SnackbarController.sendEvent(&#10;                                org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                                    message = msg,&#10;                                    action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            is MainScreenEvent.ShowSnackBar -&gt; {&#10;                viewModelScope.launch {&#10;                    SnackbarController.sendEvent(&#10;                        org.ballistic.dreamjournalai.shared.SnackbarEvent(&#10;                            message = event.message,&#10;                            action = org.ballistic.dreamjournalai.shared.SnackbarAction(&quot;Dismiss&quot;) { }&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.ToggleDrawerState -&gt; {&#10;                // ViewModel does not own a DrawerState (Compose UI object). Instead, store intent as a boolean.&#10;                Logger.d(&quot;MainScreenViewModel&quot;) { &quot;ToggleDrawerState -&gt; ${event.drawerValue}&quot; }&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isDrawerOpen = (event.drawerValue != DrawerValue.Closed)&#10;                )&#10;            }&#10;            is MainScreenEvent.UserInteracted -&gt; {&#10;                repo.recordUserInteraction()&#10;            }&#10;            is MainScreenEvent.GetAuthState -&gt; {&#10;                repo.getAuthState(viewModelScope)&#10;            }&#10;&#10;            is MainScreenEvent.SetBottomBarEnabledState -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    isBottomBarEnabledState = event.state&#10;                )&#10;            }&#10;            is MainScreenEvent.UpdatePaddingValues -&gt; {&#10;                _mainScreenViewModelState.value = _mainScreenViewModelState.value.copy(&#10;                    paddingValues = event.paddingValues&#10;                )&#10;            }&#10;&#10;            is MainScreenEvent.SetDreamRecentlySaved -&gt; {&#10;                _mainScreenViewModelState.update{&#10;                    it.copy(&#10;                        isDreamRecentlySaved = event.state&#10;                    )&#10;                }&#10;            }&#10;            is MainScreenEvent.TriggerVibration -&gt; {&#10;                viewModelScope.launch { vibratorUtil.triggerVibration() }&#10;            }&#10;            is MainScreenEvent.OpenStoreLink -&gt; {&#10;                storeLinkOpener.openStoreLink()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainScreenViewModelState(&#10;    val scaffoldState: ScaffoldState = ScaffoldState(),&#10;    val isDrawerEnabled : Boolean = true,&#10;    val isBottomBarEnabledState : Boolean = true,&#10;    // ViewModel no longer holds a Compose DrawerState; instead expose a simple boolean intent&#10;    val isDrawerOpen: Boolean = false,&#10;    // Keep search text as a plain String for stability; composables handle input&#10;    val searchedText: String = &quot;&quot;,&#10;    val dreamTokens: Int = 0,&#10;    val backgroundResource: DrawableResource = Res.drawable.background_during_day,&#10;    val paddingValues: PaddingValues = PaddingValues(0.dp),&#10;    val isDreamRecentlySaved: Boolean = false&#10;)&#10;data class ScaffoldState (&#10;    val bottomBarState: Boolean = true,&#10;    val topBarState: Boolean = true,&#10;    val floatingActionButtonState: Boolean = true,&#10;    val isUserSearching : Boolean = false,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/DreamNightmareScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_nightmares/presentation/DreamNightmareScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.domain.NightmareEvent&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components.DreamNightmareScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenState&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamNightmareScreen(&#10;    dreamNightmareScreenState: DreamNightmareScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (NightmareEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamNightmareScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            onClick = {&#10;                dreamNightmareScreenState.dreamToDelete?.let { NightmareEvent.DeleteDream(it) }&#10;                    ?.let { onEvent(it) }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    // Load the nightmares once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(NightmareEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamNightmareScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) { paddingValues -&gt;&#10;&#10;        // If we have no nightmares, show an empty-state message&#10;        if (dreamNightmareScreenState.dreamNightmareList.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no nightmares. Hopefully you never do!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, display them in a LazyColumn&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding(),&#10;            contentPadding = PaddingValues(bottom = 40.dp),&#10;        ) {&#10;            // 1) Parse and sort by LocalDate (descending), then by dream.timestamp (descending)&#10;            val sortedGroupedNightmares = dreamNightmareScreenState.dreamNightmareList&#10;                .mapNotNull { dream -&gt;&#10;                    // Try to parse the dream.date using your custom parser&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        parsedDate to dream&#10;                    } catch (e: IllegalArgumentException) {&#10;                        // If parse fails, skip this dream or handle differently&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, show a sticky header, then items&#10;            sortedGroupedNightmares.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(NightmareEvent.DreamToDelete(dream))&#10;                            onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_nightmares.presentation&#10;&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.datetime.LocalDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.domain.model.Dream&#10;import org.ballistic.dreamjournalai.shared.theme.OriginalXmlColors.DarkBlue&#10;import org.ballistic.dreamjournalai.shared.core.components.ActionBottomSheet&#10;import org.ballistic.dreamjournalai.shared.core.components.TypewriterText&#10;import org.ballistic.dreamjournalai.shared.core.components.dynamicBottomNavigationPadding&#10;import org.ballistic.dreamjournalai.shared.core.util.formatCustomDate&#10;import org.ballistic.dreamjournalai.shared.core.util.parseCustomDate&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DateHeader&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.components.DreamItem&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.domain.NightmareEvent&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.components.DreamNightmareScreenTopBar&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenState&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun DreamNightmareScreen(&#10;    dreamNightmareScreenState: DreamNightmareScreenState,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onEvent: (NightmareEvent) -&gt; Unit,&#10;    onNavigateToDream: (dreamID: String?, backgroundID: Int) -&gt; Unit,&#10;    onMainEvent: (org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent) -&gt; Unit = {}&#10;) {&#10;&#10;    // Bottom sheet if deleting a dream&#10;    if (dreamNightmareScreenState.bottomDeleteCancelSheetState) {&#10;        ActionBottomSheet(&#10;            title = &quot;Delete this Dream?&quot;,&#10;            buttonText = &quot;Delete&quot;,&#10;            message = &quot;Are you sure you want to delete this dream?&quot;,&#10;            onClick = {&#10;                dreamNightmareScreenState.dreamToDelete?.let { NightmareEvent.DeleteDream(it) }&#10;                    ?.let { onEvent(it) }&#10;            },&#10;            onClickOutside = {&#10;                onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(false))&#10;            },&#10;        )&#10;    }&#10;&#10;    // Load the nightmares once&#10;    LaunchedEffect(Unit) {&#10;        onEvent(NightmareEvent.LoadDreams)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            DreamNightmareScreenTopBar(&#10;                mainScreenViewModelState = mainScreenViewModelState,&#10;                onOpenDrawer = { onMainEvent(org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent.ToggleDrawerState(androidx.compose.material3.DrawerValue.Open)) }&#10;            )&#10;        },&#10;        containerColor = Color.Transparent,&#10;    ) { paddingValues -&gt;&#10;&#10;        // If we have no nightmares, show an empty-state message&#10;        if (dreamNightmareScreenState.dreamNightmareList.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .dynamicBottomNavigationPadding(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    contentAlignment = Alignment.Center,&#10;                    modifier = Modifier&#10;                        .verticalScroll(rememberScrollState())&#10;                        .padding(horizontal = 16.dp)&#10;                        .background(&#10;                            color = DarkBlue.copy(alpha = 0.8f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        )&#10;                ) {&#10;                    TypewriterText(&#10;                        text = &quot;You currently have no nightmares. Hopefully you never do!&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        textAlign = TextAlign.Center,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Otherwise, display them in a LazyColumn&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(&#10;                    top = paddingValues.calculateTopPadding(),&#10;                    bottom = bottomPaddingValue&#10;                )&#10;                .dynamicBottomNavigationPadding(),&#10;            contentPadding = PaddingValues(bottom = 40.dp),&#10;        ) {&#10;            // 1) Parse and sort by LocalDate (descending), then by dream.timestamp (descending)&#10;            val sortedGroupedNightmares = dreamNightmareScreenState.dreamNightmareList&#10;                .mapNotNull { dream -&gt;&#10;                    // Try to parse the dream.date using your custom parser&#10;                    try {&#10;                        val parsedDate = parseCustomDate(dream.date)&#10;                        parsedDate to dream&#10;                    } catch (_: IllegalArgumentException) {&#10;                        // If parse fails, skip this dream or handle differently&#10;                        null&#10;                    }&#10;                }&#10;                .sortedWith(&#10;                    compareByDescending&lt;Pair&lt;LocalDate, Dream&gt;&gt; { it.first }&#10;                        .thenByDescending { it.second.timestamp }&#10;                )&#10;                .groupBy { it.first }&#10;&#10;            // 2) For each date group, show a sticky header, then items&#10;            sortedGroupedNightmares.forEach { (date, dreams) -&gt;&#10;                stickyHeader {&#10;                    DateHeader(dateString = formatCustomDate(date))&#10;                }&#10;                items(dreams) { (_, dream) -&gt;&#10;                    DreamItem(&#10;                        dream = dream,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(bottom = 10.dp)&#10;                            .padding(horizontal = 12.dp),&#10;                        onClick = {&#10;                            onNavigateToDream(dream.id, dream.backgroundImage)&#10;                        },&#10;                        onDeleteClick = {&#10;                            onEvent(NightmareEvent.DreamToDelete(dream))&#10;                            onEvent(NightmareEvent.ToggleBottomDeleteCancelSheetState(true))&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        logger.d { &quot;Store products available: ${storeProducts.map { it.id }}&quot; }&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/navigation/ScreenGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/navigation/ScreenGraph.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.navigation&#10;&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionLayout&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.toRoute&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.dream_account.AccountSettingsScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.AddEditDreamScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel.AddEditDreamViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.DreamFavoriteScreen&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenImageScreen&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.DreamJournalListScreen&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_maintenance.MaintenanceScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.DreamNightmareScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.DreamStatisticScreen&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.StoreScreen&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel.StoreScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.SymbolScreen&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryScreenViewModel&#10;import org.koin.compose.viewmodel.koinViewModel&#10;import org.koin.core.parameter.parametersOf&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun ScreenGraph(&#10;    navController: NavHostController,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;) {&#10;&#10;    SharedTransitionLayout{&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = Route.DreamJournalScreen,&#10;            modifier = Modifier.fillMaxSize(),&#10;            enterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            exitTransition = { fadeOut(animationSpec = tween(500)) },&#10;            popEnterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            popExitTransition = { fadeOut(animationSpec = tween(500)) }&#10;        ) {&#10;            composable&lt;Route.DreamJournalScreen&gt; {&#10;                val dreamJournalListViewModel = koinViewModel&lt;DreamJournalListViewModel&gt;()&#10;                val searchTextFieldState =&#10;                    dreamJournalListViewModel.searchTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamJournalListState =&#10;                    dreamJournalListViewModel.dreamJournalListState.collectAsStateWithLifecycle().value&#10;                DreamJournalListScreen(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState,&#10;                    dreamJournalListState = dreamJournalListState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onDreamListEvent = { dreamJournalListViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            //store&#10;            composable&lt;Route.StoreScreen&gt; {&#10;                val storeScreenViewModel = koinViewModel&lt;StoreScreenViewModel&gt;()&#10;                val storeScreenViewModelState = storeScreenViewModel.storeScreenViewModelState&#10;                    .collectAsStateWithLifecycle().value&#10;                StoreScreen(&#10;                    storeScreenViewModelState = storeScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onStoreEvent = { storeScreenViewModel.onEvent(it) },&#10;                    navigateToAccountScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.AccountSettings)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AddEditDreamScreen&gt; { backStackEntry -&gt;&#10;                val args = backStackEntry.toRoute&lt;Route.AddEditDreamScreen&gt;()&#10;                val image = args.backgroundID&#10;&#10;                backStackEntry.savedStateHandle[&quot;dreamID&quot;] = args.dreamID&#10;&#10;                val addEditDreamViewModel = koinViewModel&lt;AddEditDreamViewModel&gt;(&#10;                    parameters = { parametersOf(backStackEntry.savedStateHandle) }&#10;                )&#10;&#10;&#10;&#10;                Box(Modifier.fillMaxSize()) {&#10;                    Text(&#10;                        text = &quot;Dream ID: ${backStackEntry.savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;,&#10;                        fontSize = 24.sp,&#10;                        color = Color.Black,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                val addEditDreamState =&#10;                    addEditDreamViewModel.addEditDreamState.collectAsStateWithLifecycle().value&#10;                val dreamTitle =&#10;                    addEditDreamViewModel.titleTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamContent =&#10;                    addEditDreamViewModel.contentTextFieldState.collectAsStateWithLifecycle().value&#10;&#10;                //println(&quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;)&#10;                Logger.d(&quot;ScreenGraph&quot;) { &quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot; }&#10;                AddEditDreamScreen(&#10;                    dreamImage = image,&#10;                    dreamTitleState = dreamTitle,&#10;                    dreamContentState = dreamContent,&#10;                    addEditDreamState = addEditDreamState,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onAddEditDreamEvent = { addEditDreamViewModel.onEvent(it) },&#10;                    animateVisibilityScope = this,&#10;                    onNavigateToDreamJournalScreen = {&#10;                        navController.popBackStack()&#10;                        navController.navigate(Route.DreamJournalScreen)&#10;                    },&#10;                    onImageClick = { imageID -&gt;&#10;                        navController.navigate(&#10;                            Route.FullScreenImageScreen(imageID)&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.FullScreenImageScreen&gt;{ it -&gt;&#10;                val args = it.toRoute&lt;Route.FullScreenImageScreen&gt;()&#10;                val fullScreenViewModel = koinViewModel&lt;FullScreenViewModel&gt;()&#10;&#10;                FullScreenImageScreen(&#10;                    imageID = args.imageID,&#10;                    animatedVisibilityScope = this,&#10;                    onBackPress = {&#10;                        navController.navigateUp()&#10;                    },&#10;                    onFullScreenEvent = {&#10;                        fullScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = { onMainEvent(it) }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Favorites&gt; {&#10;                val dreamFavoriteScreenViewModel = koinViewModel&lt;DreamFavoriteScreenViewModel&gt;()&#10;                val dreamFavoriteScreenState = dreamFavoriteScreenViewModel.dreamFavoriteScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                DreamFavoriteScreen(&#10;                    dreamFavoriteScreenState = dreamFavoriteScreenState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamFavoriteScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    },&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AccountSettings&gt; {&#10;                val loginViewModel = koinViewModel&lt;LoginViewModel&gt;()&#10;                val signupViewModel = koinViewModel&lt;SignupViewModel&gt;()&#10;&#10;                val loginViewModelState = loginViewModel.state.collectAsStateWithLifecycle().value&#10;                val signupViewModelState = signupViewModel.state.collectAsStateWithLifecycle().value&#10;&#10;                AccountSettingsScreen(&#10;                    loginViewModelState = loginViewModelState,&#10;                    signupViewModelState = signupViewModelState,&#10;                    navigateToOnboardingScreen = onNavigateToOnboardingScreen,&#10;                    onLoginEvent = { loginViewModel.onEvent(it) },&#10;                    onSignupEvent = { signupViewModel.onEvent(it) },&#10;                    navigateToDreamJournalScreen = {&#10;                        navController.navigate(Route.DreamJournalScreen) {&#10;                            // Clear up to DreamJournalScreen so it becomes the root after login&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                inclusive = true&#10;                            }&#10;                            launchSingleTop = true&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.DreamToolGraphScreen&gt; {&#10;                DreamToolsGraph(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = onMainEvent,&#10;                    onNavigate = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(dreamID = dreamID, backgroundID = backgroundID)&#10;                        ) {&#10;                            popUpTo(Route.DreamJournalScreen) {&#10;                                saveState = true&#10;                                inclusive = true&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Statistics&gt; {&#10;                val dreamStatisticScreenViewModel = koinViewModel&lt;DreamStatisticScreenViewModel&gt;()&#10;                val dreamStatisticScreenState = dreamStatisticScreenViewModel.dreamStatisticScreen&#10;                    .collectAsStateWithLifecycle()&#10;&#10;                DreamStatisticScreen(&#10;                    dreamStatisticScreenState = dreamStatisticScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = {&#10;                        dreamStatisticScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            //TODO: This is for notifications&#10;            composable&lt;Route.AboutMeScreen&gt; {&#10;//                val dreamNotificationScreenViewModel = koinViewModel&lt;NotificationScreenViewModel&gt;()&#10;//                val dreamNotificationScreenState =&#10;//                    dreamNotificationScreenViewModel.notificationScreenState&#10;//                        .collectAsStateWithLifecycle()&#10;//&#10;//                DreamNotificationSettingScreen(&#10;//                    mainScreenViewModelState = mainScreenViewModelState,&#10;//                    notificationScreenState = dreamNotificationScreenState.value,&#10;//                    bottomPaddingValue = bottomPaddingValue,&#10;//                ) {&#10;//                    dreamNotificationScreenViewModel.onEvent(it)&#10;//                }&#10;                //TODO implement notifications&#10;                MaintenanceScreen()&#10;            }&#10;&#10;            composable&lt;Route.Nightmares&gt; {&#10;                val dreamNightmareScreenViewModel = koinViewModel&lt;DreamNightmareScreenViewModel&gt;()&#10;                val dreamNightmareScreenState =&#10;                    dreamNightmareScreenViewModel.dreamNightmareScreenState&#10;                        .collectAsStateWithLifecycle()&#10;                DreamNightmareScreen(&#10;                    dreamNightmareScreenState = dreamNightmareScreenState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamNightmareScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        navController.popBackStack()&#10;                        navController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Symbol&gt; {&#10;                val dictionaryScreenViewModel = koinViewModel&lt;DictionaryScreenViewModel&gt;()&#10;                val dictionaryScreenState = dictionaryScreenViewModel.symbolScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                val searchTextFieldState = dictionaryScreenViewModel.searchTextFieldState&#10;                    .collectAsStateWithLifecycle()&#10;                SymbolScreen(&#10;                    symbolScreenState = dictionaryScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onEvent = { dictionaryScreenViewModel.onEvent(it) },&#10;                )&#10;            }&#10;&#10;//        composable(route = Screens.DreamSettings.route) {&#10;//            FeatureComingSoonScreen(&#10;//                onNavigateToAboutMeScreen = {&#10;//                    navController.popBackStack()&#10;//                    navController.navigate(Screens.AboutMe.route)&#10;//                }&#10;//            )&#10;//        }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.navigation&#10;&#10;import androidx.compose.animation.ExperimentalSharedTransitionApi&#10;import androidx.compose.animation.SharedTransitionLayout&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.toRoute&#10;import co.touchlab.kermit.Logger&#10;import org.ballistic.dreamjournalai.shared.dream_account.AccountSettingsScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.AddEditDreamScreen&#10;import org.ballistic.dreamjournalai.shared.dream_add_edit.presentation.viewmodel.AddEditDreamViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.LoginViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.presentation.signup_screen.viewmodel.SignupViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.DreamFavoriteScreen&#10;import org.ballistic.dreamjournalai.shared.dream_favorites.presentation.viewmodel.DreamFavoriteScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenImageScreen&#10;import org.ballistic.dreamjournalai.shared.dream_fullscreen.FullScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.DreamJournalListScreen&#10;import org.ballistic.dreamjournalai.shared.dream_journal_list.presentation.viewmodel.DreamJournalListViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.dream_maintenance.MaintenanceScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.DreamNightmareScreen&#10;import org.ballistic.dreamjournalai.shared.dream_nightmares.presentation.viewmodel.DreamNightmareScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.DreamStatisticScreen&#10;import org.ballistic.dreamjournalai.shared.dream_statistics.presentation.viewmodel.DreamStatisticScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.StoreScreen&#10;import org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel.StoreScreenViewModel&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.SymbolScreen&#10;import org.ballistic.dreamjournalai.shared.dream_symbols.presentation.viewmodel.DictionaryScreenViewModel&#10;import org.koin.compose.viewmodel.koinViewModel&#10;import org.koin.core.parameter.parametersOf&#10;&#10;@OptIn(ExperimentalSharedTransitionApi::class)&#10;@Composable&#10;fun ScreenGraph(&#10;    navControllerProvider: () -&gt; NavHostController,&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    bottomPaddingValue: Dp,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;) {&#10;&#10;    // Accept a provider lambda instead of a raw NavHostController parameter so the&#10;    // composable signature stays stable. We then read the controller and keep a&#10;    // rememberUpdatedState reference to it for safe, up-to-date usage inside the&#10;    // NavHost and any navigation lambdas.&#10;    val providedNavController = navControllerProvider()&#10;    val currentNavController by rememberUpdatedState(providedNavController)&#10;&#10;    SharedTransitionLayout{&#10;        NavHost(&#10;            navController = currentNavController,&#10;            startDestination = Route.DreamJournalScreen,&#10;            modifier = Modifier.fillMaxSize(),&#10;            enterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            exitTransition = { fadeOut(animationSpec = tween(500)) },&#10;            popEnterTransition = { fadeIn(animationSpec = tween(500)) },&#10;            popExitTransition = { fadeOut(animationSpec = tween(500)) }&#10;        ) {&#10;            composable&lt;Route.DreamJournalScreen&gt; {&#10;                val dreamJournalListViewModel = koinViewModel&lt;DreamJournalListViewModel&gt;()&#10;                val searchTextFieldState =&#10;                    dreamJournalListViewModel.searchTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamJournalListState =&#10;                    dreamJournalListViewModel.dreamJournalListState.collectAsStateWithLifecycle().value&#10;                DreamJournalListScreen(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState,&#10;                    dreamJournalListState = dreamJournalListState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onDreamListEvent = { dreamJournalListViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            //store&#10;            composable&lt;Route.StoreScreen&gt; {&#10;                val storeScreenViewModel = koinViewModel&lt;StoreScreenViewModel&gt;()&#10;                val storeScreenViewModelState = storeScreenViewModel.storeScreenViewModelState&#10;                    .collectAsStateWithLifecycle().value&#10;                StoreScreen(&#10;                    storeScreenViewModelState = storeScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onStoreEvent = { storeScreenViewModel.onEvent(it) },&#10;                    navigateToAccountScreen = {&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(Route.AccountSettings)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AddEditDreamScreen&gt; { backStackEntry -&gt;&#10;                val args = backStackEntry.toRoute&lt;Route.AddEditDreamScreen&gt;()&#10;                val image = args.backgroundID&#10;&#10;                backStackEntry.savedStateHandle[&quot;dreamID&quot;] = args.dreamID&#10;&#10;                val addEditDreamViewModel = koinViewModel&lt;AddEditDreamViewModel&gt;(&#10;                    parameters = { parametersOf(backStackEntry.savedStateHandle) }&#10;                )&#10;&#10;&#10;&#10;                Box(Modifier.fillMaxSize()) {&#10;                    Text(&#10;                        text = &quot;Dream ID: ${backStackEntry.savedStateHandle.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;,&#10;                        fontSize = 24.sp,&#10;                        color = Color.Black,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                val addEditDreamState =&#10;                    addEditDreamViewModel.addEditDreamState.collectAsStateWithLifecycle().value&#10;                val dreamTitle =&#10;                    addEditDreamViewModel.titleTextFieldState.collectAsStateWithLifecycle().value&#10;                val dreamContent =&#10;                    addEditDreamViewModel.contentTextFieldState.collectAsStateWithLifecycle().value&#10;&#10;                //println(&quot;Dream ID: ${navController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot;)&#10;                Logger.d(&quot;ScreenGraph&quot;) { &quot;Dream ID: ${currentNavController.currentBackStackEntry?.savedStateHandle?.get&lt;String&gt;(&quot;dreamID&quot;)}&quot; }&#10;                AddEditDreamScreen(&#10;                    dreamImage = image,&#10;                    dreamTitleState = dreamTitle,&#10;                    dreamContentState = dreamContent,&#10;                    addEditDreamState = addEditDreamState,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onAddEditDreamEvent = { addEditDreamViewModel.onEvent(it) },&#10;                    animateVisibilityScope = this,&#10;                    onNavigateToDreamJournalScreen = {&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(Route.DreamJournalScreen)&#10;                    },&#10;                    onImageClick = { imageID -&gt;&#10;                        currentNavController.navigate(&#10;                            Route.FullScreenImageScreen(imageID)&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.FullScreenImageScreen&gt;{ it -&gt;&#10;                val args = it.toRoute&lt;Route.FullScreenImageScreen&gt;()&#10;                val fullScreenViewModel = koinViewModel&lt;FullScreenViewModel&gt;()&#10;&#10;                FullScreenImageScreen(&#10;                    imageID = args.imageID,&#10;                    animatedVisibilityScope = this,&#10;                    onBackPress = {&#10;                        currentNavController.navigateUp()&#10;                    },&#10;                    onFullScreenEvent = {&#10;                        fullScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = { onMainEvent(it) }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Favorites&gt; {&#10;                val dreamFavoriteScreenViewModel = koinViewModel&lt;DreamFavoriteScreenViewModel&gt;()&#10;                val dreamFavoriteScreenState = dreamFavoriteScreenViewModel.dreamFavoriteScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                DreamFavoriteScreen(&#10;                    dreamFavoriteScreenState = dreamFavoriteScreenState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamFavoriteScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    },&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.AccountSettings&gt; {&#10;                val loginViewModel = koinViewModel&lt;LoginViewModel&gt;()&#10;                val signupViewModel = koinViewModel&lt;SignupViewModel&gt;()&#10;&#10;                val loginViewModelState = loginViewModel.state.collectAsStateWithLifecycle().value&#10;                val signupViewModelState = signupViewModel.state.collectAsStateWithLifecycle().value&#10;&#10;                AccountSettingsScreen(&#10;                     loginViewModelState = loginViewModelState,&#10;                     signupViewModelState = signupViewModelState,&#10;                     navigateToOnboardingScreen = onNavigateToOnboardingScreen,&#10;                     onLoginEvent = { loginViewModel.onEvent(it) },&#10;                     onSignupEvent = { signupViewModel.onEvent(it) },&#10;                     navigateToDreamJournalScreen = {&#10;                        currentNavController.navigate(Route.DreamJournalScreen) {&#10;                             // Clear up to DreamJournalScreen so it becomes the root after login&#10;                             popUpTo(Route.DreamJournalScreen) {&#10;                                 inclusive = true&#10;                             }&#10;                             launchSingleTop = true&#10;                         }&#10;                     }&#10;                 )&#10;             }&#10;&#10;            composable&lt;Route.DreamToolGraphScreen&gt; {&#10;                DreamToolsGraph(&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = onMainEvent,&#10;                    onNavigate = { dreamID, backgroundID -&gt;&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(&#10;                             Route.AddEditDreamScreen(dreamID = dreamID, backgroundID = backgroundID)&#10;                         ) {&#10;                             popUpTo(Route.DreamJournalScreen) {&#10;                                 saveState = true&#10;                                 inclusive = true&#10;                             }&#10;                         }&#10;                     }&#10;                 )&#10;             }&#10;&#10;            composable&lt;Route.Statistics&gt; {&#10;                val dreamStatisticScreenViewModel = koinViewModel&lt;DreamStatisticScreenViewModel&gt;()&#10;                val dreamStatisticScreenState = dreamStatisticScreenViewModel.dreamStatisticScreen&#10;                    .collectAsStateWithLifecycle()&#10;&#10;                DreamStatisticScreen(&#10;                    dreamStatisticScreenState = dreamStatisticScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = {&#10;                        dreamStatisticScreenViewModel.onEvent(it)&#10;                    },&#10;                    onMainEvent = onMainEvent&#10;                )&#10;            }&#10;&#10;            //TODO: This is for notifications&#10;            composable&lt;Route.AboutMeScreen&gt; {&#10;//                val dreamNotificationScreenViewModel = koinViewModel&lt;NotificationScreenViewModel&gt;()&#10;//                val dreamNotificationScreenState =&#10;//                    dreamNotificationScreenViewModel.notificationScreenState&#10;//                        .collectAsStateWithLifecycle()&#10;//&#10;//                DreamNotificationSettingScreen(&#10;//                    mainScreenViewModelState = mainScreenViewModelState,&#10;//                    notificationScreenState = dreamNotificationScreenState.value,&#10;//                    bottomPaddingValue = bottomPaddingValue,&#10;//                ) {&#10;//                    dreamNotificationScreenViewModel.onEvent(it)&#10;//                }&#10;                //TODO implement notifications&#10;                MaintenanceScreen()&#10;            }&#10;&#10;            composable&lt;Route.Nightmares&gt; {&#10;                val dreamNightmareScreenViewModel = koinViewModel&lt;DreamNightmareScreenViewModel&gt;()&#10;                val dreamNightmareScreenState =&#10;                    dreamNightmareScreenViewModel.dreamNightmareScreenState&#10;                        .collectAsStateWithLifecycle()&#10;                DreamNightmareScreen(&#10;                    dreamNightmareScreenState = dreamNightmareScreenState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onEvent = { dreamNightmareScreenViewModel.onEvent(it) },&#10;                    onNavigateToDream = { dreamID, backgroundID -&gt;&#10;                        currentNavController.popBackStack()&#10;                        currentNavController.navigate(&#10;                            Route.AddEditDreamScreen(&#10;                                dreamID = dreamID,&#10;                                backgroundID = backgroundID&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable&lt;Route.Symbol&gt; {&#10;                val dictionaryScreenViewModel = koinViewModel&lt;DictionaryScreenViewModel&gt;()&#10;                val dictionaryScreenState = dictionaryScreenViewModel.symbolScreenState&#10;                    .collectAsStateWithLifecycle()&#10;                val searchTextFieldState = dictionaryScreenViewModel.searchTextFieldState&#10;                    .collectAsStateWithLifecycle()&#10;                SymbolScreen(&#10;                    symbolScreenState = dictionaryScreenState.value,&#10;                    mainScreenViewModelState = mainScreenViewModelState,&#10;                    searchTextFieldState = searchTextFieldState.value,&#10;                    bottomPaddingValue = bottomPaddingValue,&#10;                    onMainEvent = { onMainEvent(it) },&#10;                    onEvent = { dictionaryScreenViewModel.onEvent(it) },&#10;                )&#10;            }&#10;&#10;//        composable(route = Screens.DreamSettings.route) {&#10;//            FeatureComingSoonScreen(&#10;//                onNavigateToAboutMeScreen = {&#10;//                    navController.popBackStack()&#10;//                    navController.navigate(Screens.AboutMe.route)&#10;//                }&#10;//            )&#10;//        }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>