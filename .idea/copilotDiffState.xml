<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_main/presentation/MainScreen.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.Permission&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import dev.icerock.moko.permissions.compose.PermissionsControllerFactory&#10;import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.navigation.DrawerNavigation&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                    // Request the permission&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (deniedAlways: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Don’t ask again).&#10;                    // Handle your fallback scenario here — e.g., show a dialog explaining&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (denied: DeniedException) {&#10;                    // The user has denied the permission (but not “don’t ask again”).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = mainScreenViewModelState.drawerMain,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            AnimatedHeartIcon()&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                    onClick = {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        coroutineScope.launch {&#10;                                            mainScreenViewModelState.drawerMain.close()&#10;                                        }&#10;                                        selectedItem.value = item&#10;&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                        } else {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(DrawerNavigation.DreamJournalScreen.route) {&#10;                                                    saveState = true&#10;                                                }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        content = {&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(mainScreenViewModelState.scaffoldState.snackBarHostState.value)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            BottomNavigation(&#10;                                navController = navController,&#10;                                modifier = Modifier.align(Alignment.BottomCenter),&#10;                                onMainEvent = onMainEvent,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;                AnimatedVisibility(visible = true, enter = fadeIn(), exit = fadeOut()) {&#10;                    ScreenGraph(&#10;                        navController = navController,&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon() {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;    val size by infiniteTransition.animateFloat(&#10;        initialValue = 24f,&#10;        targetValue = 28f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 800),  // Slower animation&#10;            repeatMode = RepeatMode.Reverse&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    Icon(&#10;        imageVector = Icons.Default.Favorite,&#10;        contentDescription = &quot;Animated Heart&quot;,&#10;        tint = Color.Red,&#10;        modifier = Modifier.size(size.dp)&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_main.presentation&#10;&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.slideInVertically&#10;import androidx.compose.animation.slideOutVertically&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.navigationBarsPadding&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationDrawerItem&#10;import androidx.compose.material3.NavigationDrawerItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import dev.icerock.moko.permissions.DeniedAlwaysException&#10;import dev.icerock.moko.permissions.DeniedException&#10;import dev.icerock.moko.permissions.Permission&#10;import dev.icerock.moko.permissions.PermissionsController&#10;import dev.icerock.moko.permissions.compose.BindEffect&#10;import dev.icerock.moko.permissions.compose.PermissionsControllerFactory&#10;import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory&#10;import dreamjournalai.composeapp.shared.generated.resources.Res&#10;import dreamjournalai.composeapp.shared.generated.resources.blue_lighthouse&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import org.ballistic.dreamjournalai.shared.core.platform.getPlatformName&#10;import org.ballistic.dreamjournalai.shared.dream_main.domain.MainScreenEvent&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.BottomNavigation&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.components.DrawerGroupHeading&#10;import org.ballistic.dreamjournalai.shared.dream_main.presentation.viewmodel.MainScreenViewModelState&#10;import org.ballistic.dreamjournalai.shared.navigation.DrawerNavigation&#10;import org.ballistic.dreamjournalai.shared.navigation.Route&#10;import org.ballistic.dreamjournalai.shared.navigation.ScreenGraph&#10;import org.jetbrains.compose.resources.painterResource&#10;&#10;@Composable&#10;fun MainScreenView(&#10;    mainScreenViewModelState: MainScreenViewModelState,&#10;    onMainEvent: (MainScreenEvent) -&gt; Unit = {},&#10;    onNavigateToOnboardingScreen: () -&gt; Unit = {},&#10;    onDataLoaded: () -&gt; Unit&#10;) {&#10;    val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory()&#10;    val controller: PermissionsController = remember(factory) { factory.createPermissionsController() }&#10;    val coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;    BindEffect(controller)&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            // Check if permission is already granted&#10;            val alreadyGranted = controller.isPermissionGranted(Permission.REMOTE_NOTIFICATION)&#10;            if (!alreadyGranted) {&#10;                try {&#10;                    // Request the permission&#10;                    controller.providePermission(Permission.REMOTE_NOTIFICATION)&#10;                } catch (deniedAlways: DeniedAlwaysException) {&#10;                    // The user has denied the permission *always* (Don’t ask again).&#10;                    // Handle your fallback scenario here — e.g., show a dialog explaining&#10;                    // that notifications won't work, or navigate the user somewhere else.&#10;                } catch (denied: DeniedException) {&#10;                    // The user has denied the permission (but not “don’t ask again”).&#10;                    // You could decide to ask again or show rationale to the user.&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onDataLoaded()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        onMainEvent(MainScreenEvent.GetAuthState)&#10;        onMainEvent(MainScreenEvent.UserInteracted)&#10;    }&#10;&#10;    val navController = rememberNavController()&#10;    val drawerGroups = listOf(&#10;        DrawerGroup(&#10;            title = &quot;Pages&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.DreamJournalScreen,&#10;                DrawerNavigation.StoreScreen,&#10;                DrawerNavigation.Favorites,&#10;                DrawerNavigation.Nightmares,&#10;                DrawerNavigation.DreamToolGraphScreen,&#10;                DrawerNavigation.Statistics,&#10;                DrawerNavigation.Symbol,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Settings&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.AccountSettings,&#10;                //   DrawerNavigation.NotificationSettings,&#10;                //    Screens.DreamSettings,&#10;            )&#10;        ),&#10;        DrawerGroup(&#10;            title = &quot;Others&quot;,&#10;            items = listOf(&#10;                DrawerNavigation.RateMyApp,&#10;                //  Screens.AboutMe&#10;            )&#10;        )&#10;    )&#10;    val selectedItem = remember { mutableStateOf(drawerGroups.first().items.first()) }&#10;&#10;    DisposableEffect(navController) {&#10;        val listener = NavController.OnDestinationChangedListener { _, destination, _ -&gt;&#10;            val route = destination.route ?: return@OnDestinationChangedListener&#10;            val matchedScreen = drawerGroups.flatMap { it.items }.firstOrNull {&#10;                it.route::class.qualifiedName == route&#10;            }&#10;            if (matchedScreen != null) {&#10;                selectedItem.value = matchedScreen&#10;            }&#10;        }&#10;&#10;        navController.addOnDestinationChangedListener(listener)&#10;        onDispose { navController.removeOnDestinationChangedListener(listener) }&#10;    }&#10;&#10;    Image(&#10;        painter = painterResource(Res.drawable.blue_lighthouse),&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .blur(15.dp),&#10;        contentDescription = &quot;Background Image&quot;&#10;    )&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = mainScreenViewModelState.drawerMain,&#10;        gesturesEnabled = mainScreenViewModelState.isDrawerEnabled,&#10;        drawerContent = {&#10;            ModalDrawerSheet(modifier = Modifier.fillMaxHeight()) {&#10;                Column(modifier = Modifier.fillMaxHeight()) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(rememberScrollState())&#10;                    ) {&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        drawerGroups.forEach { group -&gt;&#10;                            DrawerGroupHeading(title = group.title)&#10;&#10;                            group.items.forEach { item -&gt;&#10;                                NavigationDrawerItem(&#10;                                    icon = {&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            AnimatedHeartIcon()&#10;                                        } else {&#10;                                            Icon(&#10;                                                item.icon,&#10;                                                contentDescription = null&#10;                                            )&#10;                                        }&#10;                                    },&#10;                                    label = { Text(item.title ?: &quot;&quot;) },&#10;                                    selected = item == selectedItem.value,&#10;                                    onClick = {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        coroutineScope.launch {&#10;                                            mainScreenViewModelState.drawerMain.close()&#10;                                        }&#10;                                        selectedItem.value = item&#10;&#10;                                        if (item == DrawerNavigation.RateMyApp) {&#10;                                            onMainEvent(MainScreenEvent.OpenStoreLink)&#10;                                        } else {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(DrawerNavigation.DreamJournalScreen.route) {&#10;                                                    saveState = true&#10;                                                }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                    modifier = Modifier&#10;                                        .padding(NavigationDrawerItemDefaults.ItemPadding)&#10;                                        .fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Version: 1.2.8&quot;,&#10;                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,&#10;                        modifier = Modifier&#10;                            .padding(bottom = 16.dp, top = 8.dp)&#10;                            .align(Alignment.CenterHorizontally),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        content = {&#10;            Scaffold(&#10;                snackbarHost = {&#10;                    SnackbarHost(mainScreenViewModelState.scaffoldState.snackBarHostState.value)&#10;                },&#10;                bottomBar = {&#10;                    AnimatedVisibility(&#10;                        visible = mainScreenViewModelState.scaffoldState.bottomBarState,&#10;                        enter = slideInVertically(initialOffsetY = { it + 100 }),&#10;                        exit = slideOutVertically(targetOffsetY = { it + 100 })&#10;                    ) {&#10;                        val bottomPadding = if (getPlatformName() == &quot;iOS&quot;) 0.dp else 16.dp&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .padding(start = 8.dp, end = 8.dp, bottom = bottomPadding)&#10;                                .navigationBarsPadding()&#10;                                .height(72.dp)&#10;                                .fillMaxWidth(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;&#10;                            // Glassmorphic background with gradient&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .clip(RoundedCornerShape(20.dp))&#10;                                    .background(&#10;                                        Brush.horizontalGradient(&#10;                                            colors = listOf(&#10;                                                Color(128, 0, 128, 153), // Vibrant Purple with transparency&#10;                                                Color(255, 20, 147, 128),  // Deep Pink with transparency&#10;                                                Color(128, 0, 128, 153) // Vibrant Purple with transparency&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                    .blur(10.dp)&#10;                            )&#10;&#10;                            // BottomNavigation aligned to the bottom of the Box&#10;                            BottomNavigation(&#10;                                navController = navController,&#10;                                modifier = Modifier.align(Alignment.BottomCenter),&#10;                                onMainEvent = onMainEvent,&#10;                                isNavigationEnabled = mainScreenViewModelState.isBottomBarEnabledState&#10;                            )&#10;&#10;                            // FAB aligned to the top-center of the Box&#10;                            FloatingActionButton(&#10;                                onClick = {&#10;                                    if (mainScreenViewModelState.isBottomBarEnabledState) {&#10;                                        onMainEvent(MainScreenEvent.TriggerVibration)&#10;                                        // Temporarily disable bottom navigation to avoid rapid taps navigating elsewhere&#10;                                        onMainEvent(MainScreenEvent.SetBottomBarEnabledState(false))&#10;                                        navController.navigate(&#10;                                            Route.AddEditDreamScreen(&#10;                                                dreamID = &quot;&quot;,&#10;                                                backgroundID = -1&#10;                                            )&#10;                                        ) {&#10;                                            popUpTo(Route.DreamJournalScreen) {&#10;                                                saveState = false&#10;                                                inclusive = true&#10;                                            }&#10;                                        }&#10;                                        // Re-enable bottom bar shortly after navigation starts&#10;                                        coroutineScope.launch {&#10;                                            delay(700)&#10;                                            onMainEvent(MainScreenEvent.SetBottomBarEnabledState(true))&#10;                                        }&#10;                                    }&#10;                                },&#10;                                elevation = FloatingActionButtonDefaults.elevation(3.dp, 4.dp),&#10;                                shape = CircleShape,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopCenter)&#10;                                    .offset(y = (-18).dp)&#10;                                    .size(68.dp),&#10;                                containerColor = Color.Transparent&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(&#10;                                            brush = Brush.verticalGradient(&#10;                                                colors = listOf(&#10;                                                    Color(255, 105, 180),&#10;                                                    Color(110, 40, 110)&#10;                                                )&#10;                                            ),&#10;                                            shape = CircleShape&#10;                                        ),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        Icons.Filled.Add,&#10;                                        tint = Color.White,&#10;                                        contentDescription = &quot;Add dream&quot;,&#10;                                        modifier = Modifier.size(32.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                containerColor = Color.Transparent,&#10;            ) { innerPadding -&gt;&#10;                onMainEvent(MainScreenEvent.UpdatePaddingValues(innerPadding))&#10;&#10;                AnimatedVisibility(visible = true, enter = fadeIn(), exit = fadeOut()) {&#10;                    ScreenGraph(&#10;                        navController = navController,&#10;                        mainScreenViewModelState = mainScreenViewModelState,&#10;                        bottomPaddingValue = mainScreenViewModelState.paddingValues.calculateBottomPadding(),&#10;                        onMainEvent = { onMainEvent(it) },&#10;                        onNavigateToOnboardingScreen = { onNavigateToOnboardingScreen() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;data class DrawerGroup(&#10;    val title: String,&#10;    val items: List&lt;DrawerNavigation&gt;&#10;)&#10;&#10;@Composable&#10;fun AnimatedHeartIcon() {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;&quot;)&#10;    val size by infiniteTransition.animateFloat(&#10;        initialValue = 24f,&#10;        targetValue = 28f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 800),  // Slower animation&#10;            repeatMode = RepeatMode.Reverse&#10;        ), label = &quot;&quot;&#10;    )&#10;&#10;    Icon(&#10;        imageVector = Icons.Default.Favorite,&#10;        contentDescription = &quot;Animated Heart&quot;,&#10;        tint = Color.Red,&#10;        modifier = Modifier.size(size.dp)&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/composeApp/shared/src/commonMain/kotlin/org/ballistic/dreamjournalai/shared/dream_store/presentation/store_screen/viewmodel/StoreScreenViewModel.kt" />
              <option name="originalContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
              <option name="updatedContent" value="package org.ballistic.dreamjournalai.shared.dream_store.presentation.store_screen.viewmodel&#10;&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import co.touchlab.kermit.Logger&#10;import com.revenuecat.purchases.kmp.models.StoreProduct&#10;import com.revenuecat.purchases.kmp.models.StoreTransaction&#10;import dev.gitlive.firebase.Firebase&#10;import dev.gitlive.firebase.auth.auth&#10;import dev.gitlive.firebase.functions.functions&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.serialization.Serializable&#10;import org.ballistic.dreamjournalai.shared.core.Resource&#10;import org.ballistic.dreamjournalai.shared.dream_authentication.domain.repository.AuthRepository&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.StoreEvent&#10;import org.ballistic.dreamjournalai.shared.dream_store.domain.repository.BillingRepository&#10;&#10;private val logger = Logger.withTag(&quot;StoreScreenViewModel&quot;)&#10;&#10;class StoreScreenViewModel(&#10;    private val billingRepository: BillingRepository,&#10;    private val authRepository: AuthRepository&#10;) : ViewModel() {&#10;&#10;&#10;&#10;    private val _storeScreenViewModelState = MutableStateFlow(StoreScreenViewModelState())&#10;    val storeScreenViewModelState: StateFlow&lt;StoreScreenViewModelState&gt; = _storeScreenViewModelState&#10;&#10;    private val productIds = listOf(&quot;dream_token_100&quot;, &quot;dream_tokens_500&quot;)&#10;    private var authStateJob: Job? = null&#10;&#10;    init {&#10;        logger.d { &quot;Initializing StoreScreenViewModel&quot; }&#10;&#10;        onEvent(StoreEvent.GetDreamTokens)&#10;&#10;        val user = Firebase.auth.currentUser&#10;        _storeScreenViewModelState.update {&#10;            it.copy(isUserAnonymous = user?.isAnonymous == true)&#10;        }&#10;&#10;        beginAuthStateListener()&#10;    }&#10;&#10;    private fun beginAuthStateListener() {&#10;        if (authStateJob != null) return&#10;        authStateJob = viewModelScope.launch {&#10;            logger.d { &quot;Starting auth state listener&quot; }&#10;            Firebase.auth.authStateChanged.collect { user -&gt;&#10;                logger.d { &quot;Auth state changed: isAnonymous=${user?.isAnonymous}&quot; }&#10;                _storeScreenViewModelState.update { currentState -&gt;&#10;                    currentState.copy(isUserAnonymous = user?.isAnonymous == true)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopAuthStateListener() {&#10;        logger.d { &quot;Stopping auth state listener&quot; }&#10;        authStateJob?.cancel()&#10;        authStateJob = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        stopAuthStateListener()&#10;    }&#10;&#10;    fun onEvent(event: StoreEvent) {&#10;        logger.d { &quot;Event received: $event&quot; }&#10;        when (event) {&#10;            is StoreEvent.Buy100DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_token_100&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.Buy500DreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    purchaseDreamTokens(&quot;dream_tokens_500&quot;)&#10;                }&#10;            }&#10;            is StoreEvent.ToggleLoading -&gt; {&#10;                _storeScreenViewModelState.update {&#10;                    it.copy(isBillingClientLoading = event.isLoading)&#10;                }&#10;            }&#10;            is StoreEvent.GetDreamTokens -&gt; {&#10;                viewModelScope.launch {&#10;                    logger.d { &quot;Fetching dream tokens...&quot; }&#10;                    authRepository.addDreamTokensFlowListener().collect { resource -&gt;&#10;                        when (resource) {&#10;                            is Resource.Success -&gt; {&#10;                                logger.d { &quot;Dream tokens updated: ${resource.data}&quot; }&#10;                                _storeScreenViewModelState.update {&#10;                                    it.copy(dreamTokens = resource.data?.toInt() ?: 0)&#10;                                }&#10;                            }&#10;                            is Resource.Error -&gt; {&#10;                                logger.e { &quot;Error fetching dream tokens: ${resource.message}&quot; }&#10;                            }&#10;                            is Resource.Loading -&gt; {&#10;                                logger.d { &quot;Loading dream tokens...&quot; }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun purchaseDreamTokens(productId: String) {&#10;        logger.d { &quot;Starting purchase flow for productId: $productId&quot; }&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = true) }&#10;&#10;        val storeProducts = fetchStoreProducts()&#10;        logger.d { &quot;Store products available: ${storeProducts.map { it.id }}&quot; }&#10;        val storeProduct = storeProducts.find { it.id == productId }&#10;&#10;        if (storeProduct != null) {&#10;            logger.d { &quot;Product found: $storeProduct&quot; }&#10;            billingRepository.purchaseProduct(&#10;                product = storeProduct,&#10;                onError = { error, userCancelled -&gt;&#10;                    logger.e { &quot;Purchase failed for $productId: $error, userCancelled=$userCancelled&quot; }&#10;                    _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                },&#10;                onSuccess = { storeTransaction, customerInfo -&gt;&#10;                    logger.d { &quot;Purchase successful: Transaction=$storeTransaction&quot; }&#10;                    viewModelScope.launch {&#10;                        handlePurchaseVerification(storeTransaction)&#10;                    }&#10;                }&#10;            )&#10;        } else {&#10;            logger.e { &quot;Product not found for productId: $productId&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;        }&#10;    }&#10;&#10;    private suspend fun handlePurchaseVerification(storeTransaction: StoreTransaction) {&#10;        logger.d { &quot;Verifying single-item purchase.&quot; }&#10;&#10;        // 1) Get the first (and only) product ID&#10;        val productId = storeTransaction.productIds.firstOrNull()&#10;        if (productId == null) {&#10;            logger.e { &quot;No productId found in storeTransaction!&quot; }&#10;            _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;            return&#10;        }&#10;&#10;        // 2) Determine how many tokens to award for this product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; {&#10;                logger.e { &quot;Invalid productId: $productId&quot; }&#10;                _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;                return&#10;            }&#10;        }&#10;&#10;        // 3) Verify the purchase on your server&#10;        val verified = verifyPurchaseOnServer(&#10;            productId = productId,&#10;            transactionId = storeTransaction.transactionId.orEmpty(),&#10;            purchaseTime = storeTransaction.purchaseTime&#10;        )&#10;&#10;        // 4) If verified, award tokens&#10;        if (verified) {&#10;            logger.d { &quot;Purchase verified for $productId, awarding $tokensToAward tokens&quot; }&#10;            _storeScreenViewModelState.update { state -&gt;&#10;                state.copy(dreamTokens = state.dreamTokens + tokensToAward)&#10;            }&#10;        } else {&#10;            logger.e { &quot;Purchase verification failed for $productId&quot; }&#10;        }&#10;&#10;        // 5) Stop loading indicator&#10;        _storeScreenViewModelState.update { it.copy(isBillingClientLoading = false) }&#10;    }&#10;&#10;&#10;    private suspend fun fetchStoreProducts(): List&lt;StoreProduct&gt; =&#10;        suspendCancellableCoroutine { cont -&gt;&#10;            logger.d { &quot;Fetching store products...&quot; }&#10;            billingRepository.fetchProducts(&#10;                productIds = productIds,&#10;                onError = { error -&gt;&#10;                    logger.e { &quot;Error fetching products: $error&quot; }&#10;                    cont.resume(emptyList()) { cause, _, _ -&gt; }&#10;                },&#10;                onSuccess = { storeProducts -&gt;&#10;                    logger.d { &quot;Products fetched successfully: $storeProducts&quot; }&#10;                    cont.resume(storeProducts) { cause, _, _ -&gt; }&#10;                }&#10;            )&#10;        }&#10;&#10;    private suspend fun verifyPurchaseOnServer(&#10;        productId: String,&#10;        transactionId: String,&#10;        purchaseTime: Long&#10;    ): Boolean {&#10;        val userId = Firebase.auth.currentUser?.uid ?: return false&#10;&#10;        // Determine tokens for this one product&#10;        val tokensToAward = when (productId) {&#10;            &quot;dream_token_100&quot;  -&gt; 100&#10;            &quot;dream_tokens_500&quot; -&gt; 500&#10;            else -&gt; 0&#10;        }&#10;        if (tokensToAward == 0) {&#10;            logger.e { &quot;Invalid productId: $productId&quot; }&#10;            return false&#10;        }&#10;&#10;        val data = hashMapOf(&#10;            &quot;purchaseToken&quot; to transactionId,&#10;            &quot;purchaseTime&quot; to purchaseTime,&#10;            &quot;orderId&quot; to transactionId,&#10;            &quot;userId&quot; to userId,&#10;            &quot;dreamTokens&quot; to tokensToAward&#10;        )&#10;&#10;        return try {&#10;            val response = Firebase.functions&#10;                .httpsCallable(&quot;handlePurchaseVerification&quot;)&#10;                .invoke(data)&#10;&#10;            // Deserialize the response&#10;            val verificationResponse = response.data&lt;VerificationResponse&gt;()&#10;            logger.d {&#10;                &quot;Server verification response: success=${verificationResponse.success}, &quot; +&#10;                        &quot;tokens=$tokensToAward&quot;&#10;            }&#10;            verificationResponse.success&#10;        } catch (e: Exception) {&#10;            logger.e { &quot;Server verification failed: $e&quot; }&#10;            false&#10;        }&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;data class StoreScreenViewModelState(&#10;    val isBillingClientLoading: Boolean = false,&#10;    val isUserAnonymous: Boolean = false,&#10;    val dreamTokens: Int = 0&#10;)&#10;&#10;@Serializable&#10;data class VerificationResponse(&#10;    val success: Boolean&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>